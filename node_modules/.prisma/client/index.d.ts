
/**
 * Client
**/

import * as runtime from '@prisma/client/runtime/library.js';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model Roles
 * 
 */
export type Roles = $Result.DefaultSelection<Prisma.$RolesPayload>
/**
 * Model Users
 * 
 */
export type Users = $Result.DefaultSelection<Prisma.$UsersPayload>
/**
 * Model Futsals
 * 
 */
export type Futsals = $Result.DefaultSelection<Prisma.$FutsalsPayload>
/**
 * Model FutsalImage
 * 
 */
export type FutsalImage = $Result.DefaultSelection<Prisma.$FutsalImagePayload>
/**
 * Model PriceLists
 * 
 */
export type PriceLists = $Result.DefaultSelection<Prisma.$PriceListsPayload>
/**
 * Model Bookings
 * 
 */
export type Bookings = $Result.DefaultSelection<Prisma.$BookingsPayload>
/**
 * Model TimeSlots
 * 
 */
export type TimeSlots = $Result.DefaultSelection<Prisma.$TimeSlotsPayload>
/**
 * Model MatchRequest
 * 
 */
export type MatchRequest = $Result.DefaultSelection<Prisma.$MatchRequestPayload>
/**
 * Model Matches
 * 
 */
export type Matches = $Result.DefaultSelection<Prisma.$MatchesPayload>

/**
 * Enums
 */
export namespace $Enums {
  export const FutsalType: {
  FiveA: 'FiveA',
  SevenA: 'SevenA'
};

export type FutsalType = (typeof FutsalType)[keyof typeof FutsalType]


export const BookingStatus: {
  Pending: 'Pending',
  Confirmed: 'Confirmed',
  Cancelled: 'Cancelled'
};

export type BookingStatus = (typeof BookingStatus)[keyof typeof BookingStatus]


export const Payment: {
  Pending: 'Pending',
  Paid: 'Paid'
};

export type Payment = (typeof Payment)[keyof typeof Payment]


export const RequestStatus: {
  Pending: 'Pending',
  Accepted: 'Accepted',
  Cancelled: 'Cancelled'
};

export type RequestStatus = (typeof RequestStatus)[keyof typeof RequestStatus]


export const MatchStatus: {
  Cancelled: 'Cancelled',
  Scheduled: 'Scheduled'
};

export type MatchStatus = (typeof MatchStatus)[keyof typeof MatchStatus]

}

export type FutsalType = $Enums.FutsalType

export const FutsalType: typeof $Enums.FutsalType

export type BookingStatus = $Enums.BookingStatus

export const BookingStatus: typeof $Enums.BookingStatus

export type Payment = $Enums.Payment

export const Payment: typeof $Enums.Payment

export type RequestStatus = $Enums.RequestStatus

export const RequestStatus: typeof $Enums.RequestStatus

export type MatchStatus = $Enums.MatchStatus

export const MatchStatus: typeof $Enums.MatchStatus

/**
 * ##  Prisma Client ʲˢ
 * 
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Roles
 * const roles = await prisma.roles.findMany()
 * ```
 *
 * 
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  ClientOptions extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  U = 'log' extends keyof ClientOptions ? ClientOptions['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<ClientOptions['log']> : never : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   * 
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Roles
   * const roles = await prisma.roles.findMany()
   * ```
   *
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<ClientOptions, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): void;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

  /**
   * Add a middleware
   * @deprecated since 4.16.0. For new code, prefer client extensions instead.
   * @see https://pris.ly/d/extensions
   */
  $use(cb: Prisma.Middleware): void

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<R>


  $extends: $Extensions.ExtendsHook<"extends", Prisma.TypeMapCb, ExtArgs>

      /**
   * `prisma.roles`: Exposes CRUD operations for the **Roles** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Roles
    * const roles = await prisma.roles.findMany()
    * ```
    */
  get roles(): Prisma.RolesDelegate<ExtArgs>;

  /**
   * `prisma.users`: Exposes CRUD operations for the **Users** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Users
    * const users = await prisma.users.findMany()
    * ```
    */
  get users(): Prisma.UsersDelegate<ExtArgs>;

  /**
   * `prisma.futsals`: Exposes CRUD operations for the **Futsals** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Futsals
    * const futsals = await prisma.futsals.findMany()
    * ```
    */
  get futsals(): Prisma.FutsalsDelegate<ExtArgs>;

  /**
   * `prisma.futsalImage`: Exposes CRUD operations for the **FutsalImage** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more FutsalImages
    * const futsalImages = await prisma.futsalImage.findMany()
    * ```
    */
  get futsalImage(): Prisma.FutsalImageDelegate<ExtArgs>;

  /**
   * `prisma.priceLists`: Exposes CRUD operations for the **PriceLists** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more PriceLists
    * const priceLists = await prisma.priceLists.findMany()
    * ```
    */
  get priceLists(): Prisma.PriceListsDelegate<ExtArgs>;

  /**
   * `prisma.bookings`: Exposes CRUD operations for the **Bookings** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Bookings
    * const bookings = await prisma.bookings.findMany()
    * ```
    */
  get bookings(): Prisma.BookingsDelegate<ExtArgs>;

  /**
   * `prisma.timeSlots`: Exposes CRUD operations for the **TimeSlots** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more TimeSlots
    * const timeSlots = await prisma.timeSlots.findMany()
    * ```
    */
  get timeSlots(): Prisma.TimeSlotsDelegate<ExtArgs>;

  /**
   * `prisma.matchRequest`: Exposes CRUD operations for the **MatchRequest** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more MatchRequests
    * const matchRequests = await prisma.matchRequest.findMany()
    * ```
    */
  get matchRequest(): Prisma.MatchRequestDelegate<ExtArgs>;

  /**
   * `prisma.matches`: Exposes CRUD operations for the **Matches** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Matches
    * const matches = await prisma.matches.findMany()
    * ```
    */
  get matches(): Prisma.MatchesDelegate<ExtArgs>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError
  export import NotFoundError = runtime.NotFoundError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql

  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics 
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 5.17.0
   * Query Engine version: 393aa359c9ad4a4bb28630fb5613f9c281cde053
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion 

  /**
   * Utility Types
   */

  /**
   * From https://github.com/sindresorhus/type-fest/
   * Matches a JSON object.
   * This type can be useful to enforce some input to be JSON-compatible or as a super-type to be extended from. 
   */
  export type JsonObject = {[Key in string]?: JsonValue}

  /**
   * From https://github.com/sindresorhus/type-fest/
   * Matches a JSON array.
   */
  export interface JsonArray extends Array<JsonValue> {}

  /**
   * From https://github.com/sindresorhus/type-fest/
   * Matches any valid JSON value.
   */
  export type JsonValue = string | number | boolean | JsonObject | JsonArray | null

  /**
   * Matches a JSON object.
   * Unlike `JsonObject`, this type allows undefined and read-only properties.
   */
  export type InputJsonObject = {readonly [Key in string]?: InputJsonValue | null}

  /**
   * Matches a JSON array.
   * Unlike `JsonArray`, readonly arrays are assignable to this type.
   */
  export interface InputJsonArray extends ReadonlyArray<InputJsonValue | null> {}

  /**
   * Matches any valid value that can be used as an input for operations like
   * create and update as the value of a JSON field. Unlike `JsonValue`, this
   * type allows read-only arrays and read-only object properties and disallows
   * `null` at the top level.
   *
   * `null` cannot be used as the value of a JSON field because its meaning
   * would be ambiguous. Use `Prisma.JsonNull` to store the JSON null value or
   * `Prisma.DbNull` to clear the JSON value and set the field to the database
   * NULL value instead.
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-by-null-values
   */
  export type InputJsonValue = string | number | boolean | InputJsonObject | InputJsonArray | { toJSON(): unknown }

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  type SelectAndOmit = {
    select: any
    omit: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : T extends SelectAndOmit
        ? 'Please either choose `select` or `omit`.'
        : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? K : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    Roles: 'Roles',
    Users: 'Users',
    Futsals: 'Futsals',
    FutsalImage: 'FutsalImage',
    PriceLists: 'PriceLists',
    Bookings: 'Bookings',
    TimeSlots: 'TimeSlots',
    MatchRequest: 'MatchRequest',
    Matches: 'Matches'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }

  interface TypeMapCb extends $Utils.Fn<{extArgs: $Extensions.InternalArgs, clientOptions: PrismaClientOptions }, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs'], this['params']['clientOptions']>
  }

  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> = {
    meta: {
      modelProps: "roles" | "users" | "futsals" | "futsalImage" | "priceLists" | "bookings" | "timeSlots" | "matchRequest" | "matches"
      txIsolationLevel: Prisma.TransactionIsolationLevel
    }
    model: {
      Roles: {
        payload: Prisma.$RolesPayload<ExtArgs>
        fields: Prisma.RolesFieldRefs
        operations: {
          findUnique: {
            args: Prisma.RolesFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolesPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.RolesFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolesPayload>
          }
          findFirst: {
            args: Prisma.RolesFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolesPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.RolesFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolesPayload>
          }
          findMany: {
            args: Prisma.RolesFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolesPayload>[]
          }
          create: {
            args: Prisma.RolesCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolesPayload>
          }
          createMany: {
            args: Prisma.RolesCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.RolesCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolesPayload>[]
          }
          delete: {
            args: Prisma.RolesDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolesPayload>
          }
          update: {
            args: Prisma.RolesUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolesPayload>
          }
          deleteMany: {
            args: Prisma.RolesDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.RolesUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.RolesUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolesPayload>
          }
          aggregate: {
            args: Prisma.RolesAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateRoles>
          }
          groupBy: {
            args: Prisma.RolesGroupByArgs<ExtArgs>
            result: $Utils.Optional<RolesGroupByOutputType>[]
          }
          count: {
            args: Prisma.RolesCountArgs<ExtArgs>
            result: $Utils.Optional<RolesCountAggregateOutputType> | number
          }
        }
      }
      Users: {
        payload: Prisma.$UsersPayload<ExtArgs>
        fields: Prisma.UsersFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UsersFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UsersPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UsersFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UsersPayload>
          }
          findFirst: {
            args: Prisma.UsersFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UsersPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UsersFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UsersPayload>
          }
          findMany: {
            args: Prisma.UsersFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UsersPayload>[]
          }
          create: {
            args: Prisma.UsersCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UsersPayload>
          }
          createMany: {
            args: Prisma.UsersCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UsersCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UsersPayload>[]
          }
          delete: {
            args: Prisma.UsersDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UsersPayload>
          }
          update: {
            args: Prisma.UsersUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UsersPayload>
          }
          deleteMany: {
            args: Prisma.UsersDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UsersUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.UsersUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UsersPayload>
          }
          aggregate: {
            args: Prisma.UsersAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUsers>
          }
          groupBy: {
            args: Prisma.UsersGroupByArgs<ExtArgs>
            result: $Utils.Optional<UsersGroupByOutputType>[]
          }
          count: {
            args: Prisma.UsersCountArgs<ExtArgs>
            result: $Utils.Optional<UsersCountAggregateOutputType> | number
          }
        }
      }
      Futsals: {
        payload: Prisma.$FutsalsPayload<ExtArgs>
        fields: Prisma.FutsalsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.FutsalsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FutsalsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.FutsalsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FutsalsPayload>
          }
          findFirst: {
            args: Prisma.FutsalsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FutsalsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.FutsalsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FutsalsPayload>
          }
          findMany: {
            args: Prisma.FutsalsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FutsalsPayload>[]
          }
          create: {
            args: Prisma.FutsalsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FutsalsPayload>
          }
          createMany: {
            args: Prisma.FutsalsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.FutsalsCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FutsalsPayload>[]
          }
          delete: {
            args: Prisma.FutsalsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FutsalsPayload>
          }
          update: {
            args: Prisma.FutsalsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FutsalsPayload>
          }
          deleteMany: {
            args: Prisma.FutsalsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.FutsalsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.FutsalsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FutsalsPayload>
          }
          aggregate: {
            args: Prisma.FutsalsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateFutsals>
          }
          groupBy: {
            args: Prisma.FutsalsGroupByArgs<ExtArgs>
            result: $Utils.Optional<FutsalsGroupByOutputType>[]
          }
          count: {
            args: Prisma.FutsalsCountArgs<ExtArgs>
            result: $Utils.Optional<FutsalsCountAggregateOutputType> | number
          }
        }
      }
      FutsalImage: {
        payload: Prisma.$FutsalImagePayload<ExtArgs>
        fields: Prisma.FutsalImageFieldRefs
        operations: {
          findUnique: {
            args: Prisma.FutsalImageFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FutsalImagePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.FutsalImageFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FutsalImagePayload>
          }
          findFirst: {
            args: Prisma.FutsalImageFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FutsalImagePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.FutsalImageFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FutsalImagePayload>
          }
          findMany: {
            args: Prisma.FutsalImageFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FutsalImagePayload>[]
          }
          create: {
            args: Prisma.FutsalImageCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FutsalImagePayload>
          }
          createMany: {
            args: Prisma.FutsalImageCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.FutsalImageCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FutsalImagePayload>[]
          }
          delete: {
            args: Prisma.FutsalImageDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FutsalImagePayload>
          }
          update: {
            args: Prisma.FutsalImageUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FutsalImagePayload>
          }
          deleteMany: {
            args: Prisma.FutsalImageDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.FutsalImageUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.FutsalImageUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FutsalImagePayload>
          }
          aggregate: {
            args: Prisma.FutsalImageAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateFutsalImage>
          }
          groupBy: {
            args: Prisma.FutsalImageGroupByArgs<ExtArgs>
            result: $Utils.Optional<FutsalImageGroupByOutputType>[]
          }
          count: {
            args: Prisma.FutsalImageCountArgs<ExtArgs>
            result: $Utils.Optional<FutsalImageCountAggregateOutputType> | number
          }
        }
      }
      PriceLists: {
        payload: Prisma.$PriceListsPayload<ExtArgs>
        fields: Prisma.PriceListsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PriceListsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PriceListsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PriceListsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PriceListsPayload>
          }
          findFirst: {
            args: Prisma.PriceListsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PriceListsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PriceListsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PriceListsPayload>
          }
          findMany: {
            args: Prisma.PriceListsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PriceListsPayload>[]
          }
          create: {
            args: Prisma.PriceListsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PriceListsPayload>
          }
          createMany: {
            args: Prisma.PriceListsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PriceListsCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PriceListsPayload>[]
          }
          delete: {
            args: Prisma.PriceListsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PriceListsPayload>
          }
          update: {
            args: Prisma.PriceListsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PriceListsPayload>
          }
          deleteMany: {
            args: Prisma.PriceListsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PriceListsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.PriceListsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PriceListsPayload>
          }
          aggregate: {
            args: Prisma.PriceListsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePriceLists>
          }
          groupBy: {
            args: Prisma.PriceListsGroupByArgs<ExtArgs>
            result: $Utils.Optional<PriceListsGroupByOutputType>[]
          }
          count: {
            args: Prisma.PriceListsCountArgs<ExtArgs>
            result: $Utils.Optional<PriceListsCountAggregateOutputType> | number
          }
        }
      }
      Bookings: {
        payload: Prisma.$BookingsPayload<ExtArgs>
        fields: Prisma.BookingsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.BookingsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BookingsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.BookingsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BookingsPayload>
          }
          findFirst: {
            args: Prisma.BookingsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BookingsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.BookingsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BookingsPayload>
          }
          findMany: {
            args: Prisma.BookingsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BookingsPayload>[]
          }
          create: {
            args: Prisma.BookingsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BookingsPayload>
          }
          createMany: {
            args: Prisma.BookingsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.BookingsCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BookingsPayload>[]
          }
          delete: {
            args: Prisma.BookingsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BookingsPayload>
          }
          update: {
            args: Prisma.BookingsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BookingsPayload>
          }
          deleteMany: {
            args: Prisma.BookingsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.BookingsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.BookingsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BookingsPayload>
          }
          aggregate: {
            args: Prisma.BookingsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateBookings>
          }
          groupBy: {
            args: Prisma.BookingsGroupByArgs<ExtArgs>
            result: $Utils.Optional<BookingsGroupByOutputType>[]
          }
          count: {
            args: Prisma.BookingsCountArgs<ExtArgs>
            result: $Utils.Optional<BookingsCountAggregateOutputType> | number
          }
        }
      }
      TimeSlots: {
        payload: Prisma.$TimeSlotsPayload<ExtArgs>
        fields: Prisma.TimeSlotsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TimeSlotsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TimeSlotsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TimeSlotsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TimeSlotsPayload>
          }
          findFirst: {
            args: Prisma.TimeSlotsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TimeSlotsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TimeSlotsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TimeSlotsPayload>
          }
          findMany: {
            args: Prisma.TimeSlotsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TimeSlotsPayload>[]
          }
          create: {
            args: Prisma.TimeSlotsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TimeSlotsPayload>
          }
          createMany: {
            args: Prisma.TimeSlotsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.TimeSlotsCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TimeSlotsPayload>[]
          }
          delete: {
            args: Prisma.TimeSlotsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TimeSlotsPayload>
          }
          update: {
            args: Prisma.TimeSlotsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TimeSlotsPayload>
          }
          deleteMany: {
            args: Prisma.TimeSlotsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TimeSlotsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.TimeSlotsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TimeSlotsPayload>
          }
          aggregate: {
            args: Prisma.TimeSlotsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTimeSlots>
          }
          groupBy: {
            args: Prisma.TimeSlotsGroupByArgs<ExtArgs>
            result: $Utils.Optional<TimeSlotsGroupByOutputType>[]
          }
          count: {
            args: Prisma.TimeSlotsCountArgs<ExtArgs>
            result: $Utils.Optional<TimeSlotsCountAggregateOutputType> | number
          }
        }
      }
      MatchRequest: {
        payload: Prisma.$MatchRequestPayload<ExtArgs>
        fields: Prisma.MatchRequestFieldRefs
        operations: {
          findUnique: {
            args: Prisma.MatchRequestFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MatchRequestPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.MatchRequestFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MatchRequestPayload>
          }
          findFirst: {
            args: Prisma.MatchRequestFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MatchRequestPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.MatchRequestFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MatchRequestPayload>
          }
          findMany: {
            args: Prisma.MatchRequestFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MatchRequestPayload>[]
          }
          create: {
            args: Prisma.MatchRequestCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MatchRequestPayload>
          }
          createMany: {
            args: Prisma.MatchRequestCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.MatchRequestCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MatchRequestPayload>[]
          }
          delete: {
            args: Prisma.MatchRequestDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MatchRequestPayload>
          }
          update: {
            args: Prisma.MatchRequestUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MatchRequestPayload>
          }
          deleteMany: {
            args: Prisma.MatchRequestDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.MatchRequestUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.MatchRequestUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MatchRequestPayload>
          }
          aggregate: {
            args: Prisma.MatchRequestAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateMatchRequest>
          }
          groupBy: {
            args: Prisma.MatchRequestGroupByArgs<ExtArgs>
            result: $Utils.Optional<MatchRequestGroupByOutputType>[]
          }
          count: {
            args: Prisma.MatchRequestCountArgs<ExtArgs>
            result: $Utils.Optional<MatchRequestCountAggregateOutputType> | number
          }
        }
      }
      Matches: {
        payload: Prisma.$MatchesPayload<ExtArgs>
        fields: Prisma.MatchesFieldRefs
        operations: {
          findUnique: {
            args: Prisma.MatchesFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MatchesPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.MatchesFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MatchesPayload>
          }
          findFirst: {
            args: Prisma.MatchesFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MatchesPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.MatchesFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MatchesPayload>
          }
          findMany: {
            args: Prisma.MatchesFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MatchesPayload>[]
          }
          create: {
            args: Prisma.MatchesCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MatchesPayload>
          }
          createMany: {
            args: Prisma.MatchesCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.MatchesCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MatchesPayload>[]
          }
          delete: {
            args: Prisma.MatchesDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MatchesPayload>
          }
          update: {
            args: Prisma.MatchesUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MatchesPayload>
          }
          deleteMany: {
            args: Prisma.MatchesDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.MatchesUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.MatchesUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MatchesPayload>
          }
          aggregate: {
            args: Prisma.MatchesAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateMatches>
          }
          groupBy: {
            args: Prisma.MatchesGroupByArgs<ExtArgs>
            result: $Utils.Optional<MatchesGroupByOutputType>[]
          }
          count: {
            args: Prisma.MatchesCountArgs<ExtArgs>
            result: $Utils.Optional<MatchesCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<"define", Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
  export interface PrismaClientOptions {
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasourceUrl?: string
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat
    /**
     * @example
     * ```
     * // Defaults to stdout
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events
     * log: [
     *   { emit: 'stdout', level: 'query' },
     *   { emit: 'stdout', level: 'info' },
     *   { emit: 'stdout', level: 'warn' }
     *   { emit: 'stdout', level: 'error' }
     * ]
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: (LogLevel | LogDefinition)[]
    /**
     * The default values for transactionOptions
     * maxWait ?= 2000
     * timeout ?= 5000
     */
    transactionOptions?: {
      maxWait?: number
      timeout?: number
      isolationLevel?: Prisma.TransactionIsolationLevel
    }
  }


  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type GetLogType<T extends LogLevel | LogDefinition> = T extends LogDefinition ? T['emit'] extends 'event' ? T['level'] : never : never
  export type GetEvents<T extends any> = T extends Array<LogLevel | LogDefinition> ?
    GetLogType<T[0]> | GetLogType<T[1]> | GetLogType<T[2]> | GetLogType<T[3]>
    : never

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'createManyAndReturn'
    | 'update'
    | 'updateMany'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  /**
   * These options are being passed into the middleware as "params"
   */
  export type MiddlewareParams = {
    model?: ModelName
    action: PrismaAction
    args: any
    dataPath: string[]
    runInTransaction: boolean
  }

  /**
   * The `T` type makes sure, that the `return proceed` is not forgotten in the middleware implementation
   */
  export type Middleware<T = any> = (
    params: MiddlewareParams,
    next: (params: MiddlewareParams) => $Utils.JsPromise<T>,
  ) => $Utils.JsPromise<T>

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type RolesCountOutputType
   */

  export type RolesCountOutputType = {
    Users: number
  }

  export type RolesCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Users?: boolean | RolesCountOutputTypeCountUsersArgs
  }

  // Custom InputTypes
  /**
   * RolesCountOutputType without action
   */
  export type RolesCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RolesCountOutputType
     */
    select?: RolesCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * RolesCountOutputType without action
   */
  export type RolesCountOutputTypeCountUsersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UsersWhereInput
  }


  /**
   * Count Type UsersCountOutputType
   */

  export type UsersCountOutputType = {
    Bookings: number
    organizedMatches: number
    opponentMatches: number
  }

  export type UsersCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Bookings?: boolean | UsersCountOutputTypeCountBookingsArgs
    organizedMatches?: boolean | UsersCountOutputTypeCountOrganizedMatchesArgs
    opponentMatches?: boolean | UsersCountOutputTypeCountOpponentMatchesArgs
  }

  // Custom InputTypes
  /**
   * UsersCountOutputType without action
   */
  export type UsersCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UsersCountOutputType
     */
    select?: UsersCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * UsersCountOutputType without action
   */
  export type UsersCountOutputTypeCountBookingsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BookingsWhereInput
  }

  /**
   * UsersCountOutputType without action
   */
  export type UsersCountOutputTypeCountOrganizedMatchesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MatchesWhereInput
  }

  /**
   * UsersCountOutputType without action
   */
  export type UsersCountOutputTypeCountOpponentMatchesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MatchesWhereInput
  }


  /**
   * Count Type FutsalsCountOutputType
   */

  export type FutsalsCountOutputType = {
    images: number
    PriceLists: number
    Bookings: number
    timeSlots: number
  }

  export type FutsalsCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    images?: boolean | FutsalsCountOutputTypeCountImagesArgs
    PriceLists?: boolean | FutsalsCountOutputTypeCountPriceListsArgs
    Bookings?: boolean | FutsalsCountOutputTypeCountBookingsArgs
    timeSlots?: boolean | FutsalsCountOutputTypeCountTimeSlotsArgs
  }

  // Custom InputTypes
  /**
   * FutsalsCountOutputType without action
   */
  export type FutsalsCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FutsalsCountOutputType
     */
    select?: FutsalsCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * FutsalsCountOutputType without action
   */
  export type FutsalsCountOutputTypeCountImagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FutsalImageWhereInput
  }

  /**
   * FutsalsCountOutputType without action
   */
  export type FutsalsCountOutputTypeCountPriceListsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PriceListsWhereInput
  }

  /**
   * FutsalsCountOutputType without action
   */
  export type FutsalsCountOutputTypeCountBookingsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BookingsWhereInput
  }

  /**
   * FutsalsCountOutputType without action
   */
  export type FutsalsCountOutputTypeCountTimeSlotsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TimeSlotsWhereInput
  }


  /**
   * Models
   */

  /**
   * Model Roles
   */

  export type AggregateRoles = {
    _count: RolesCountAggregateOutputType | null
    _avg: RolesAvgAggregateOutputType | null
    _sum: RolesSumAggregateOutputType | null
    _min: RolesMinAggregateOutputType | null
    _max: RolesMaxAggregateOutputType | null
  }

  export type RolesAvgAggregateOutputType = {
    id: number | null
  }

  export type RolesSumAggregateOutputType = {
    id: number | null
  }

  export type RolesMinAggregateOutputType = {
    id: number | null
    title: string | null
  }

  export type RolesMaxAggregateOutputType = {
    id: number | null
    title: string | null
  }

  export type RolesCountAggregateOutputType = {
    id: number
    title: number
    _all: number
  }


  export type RolesAvgAggregateInputType = {
    id?: true
  }

  export type RolesSumAggregateInputType = {
    id?: true
  }

  export type RolesMinAggregateInputType = {
    id?: true
    title?: true
  }

  export type RolesMaxAggregateInputType = {
    id?: true
    title?: true
  }

  export type RolesCountAggregateInputType = {
    id?: true
    title?: true
    _all?: true
  }

  export type RolesAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Roles to aggregate.
     */
    where?: RolesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Roles to fetch.
     */
    orderBy?: RolesOrderByWithRelationInput | RolesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: RolesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Roles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Roles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Roles
    **/
    _count?: true | RolesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: RolesAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: RolesSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: RolesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: RolesMaxAggregateInputType
  }

  export type GetRolesAggregateType<T extends RolesAggregateArgs> = {
        [P in keyof T & keyof AggregateRoles]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRoles[P]>
      : GetScalarType<T[P], AggregateRoles[P]>
  }




  export type RolesGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RolesWhereInput
    orderBy?: RolesOrderByWithAggregationInput | RolesOrderByWithAggregationInput[]
    by: RolesScalarFieldEnum[] | RolesScalarFieldEnum
    having?: RolesScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: RolesCountAggregateInputType | true
    _avg?: RolesAvgAggregateInputType
    _sum?: RolesSumAggregateInputType
    _min?: RolesMinAggregateInputType
    _max?: RolesMaxAggregateInputType
  }

  export type RolesGroupByOutputType = {
    id: number
    title: string
    _count: RolesCountAggregateOutputType | null
    _avg: RolesAvgAggregateOutputType | null
    _sum: RolesSumAggregateOutputType | null
    _min: RolesMinAggregateOutputType | null
    _max: RolesMaxAggregateOutputType | null
  }

  type GetRolesGroupByPayload<T extends RolesGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<RolesGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof RolesGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], RolesGroupByOutputType[P]>
            : GetScalarType<T[P], RolesGroupByOutputType[P]>
        }
      >
    >


  export type RolesSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    Users?: boolean | Roles$UsersArgs<ExtArgs>
    _count?: boolean | RolesCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["roles"]>

  export type RolesSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
  }, ExtArgs["result"]["roles"]>

  export type RolesSelectScalar = {
    id?: boolean
    title?: boolean
  }

  export type RolesInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Users?: boolean | Roles$UsersArgs<ExtArgs>
    _count?: boolean | RolesCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type RolesIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $RolesPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Roles"
    objects: {
      Users: Prisma.$UsersPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      title: string
    }, ExtArgs["result"]["roles"]>
    composites: {}
  }

  type RolesGetPayload<S extends boolean | null | undefined | RolesDefaultArgs> = $Result.GetResult<Prisma.$RolesPayload, S>

  type RolesCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<RolesFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: RolesCountAggregateInputType | true
    }

  export interface RolesDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Roles'], meta: { name: 'Roles' } }
    /**
     * Find zero or one Roles that matches the filter.
     * @param {RolesFindUniqueArgs} args - Arguments to find a Roles
     * @example
     * // Get one Roles
     * const roles = await prisma.roles.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends RolesFindUniqueArgs>(args: SelectSubset<T, RolesFindUniqueArgs<ExtArgs>>): Prisma__RolesClient<$Result.GetResult<Prisma.$RolesPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Roles that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {RolesFindUniqueOrThrowArgs} args - Arguments to find a Roles
     * @example
     * // Get one Roles
     * const roles = await prisma.roles.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends RolesFindUniqueOrThrowArgs>(args: SelectSubset<T, RolesFindUniqueOrThrowArgs<ExtArgs>>): Prisma__RolesClient<$Result.GetResult<Prisma.$RolesPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Roles that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RolesFindFirstArgs} args - Arguments to find a Roles
     * @example
     * // Get one Roles
     * const roles = await prisma.roles.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends RolesFindFirstArgs>(args?: SelectSubset<T, RolesFindFirstArgs<ExtArgs>>): Prisma__RolesClient<$Result.GetResult<Prisma.$RolesPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Roles that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RolesFindFirstOrThrowArgs} args - Arguments to find a Roles
     * @example
     * // Get one Roles
     * const roles = await prisma.roles.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends RolesFindFirstOrThrowArgs>(args?: SelectSubset<T, RolesFindFirstOrThrowArgs<ExtArgs>>): Prisma__RolesClient<$Result.GetResult<Prisma.$RolesPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Roles that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RolesFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Roles
     * const roles = await prisma.roles.findMany()
     * 
     * // Get first 10 Roles
     * const roles = await prisma.roles.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const rolesWithIdOnly = await prisma.roles.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends RolesFindManyArgs>(args?: SelectSubset<T, RolesFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RolesPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Roles.
     * @param {RolesCreateArgs} args - Arguments to create a Roles.
     * @example
     * // Create one Roles
     * const Roles = await prisma.roles.create({
     *   data: {
     *     // ... data to create a Roles
     *   }
     * })
     * 
     */
    create<T extends RolesCreateArgs>(args: SelectSubset<T, RolesCreateArgs<ExtArgs>>): Prisma__RolesClient<$Result.GetResult<Prisma.$RolesPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Roles.
     * @param {RolesCreateManyArgs} args - Arguments to create many Roles.
     * @example
     * // Create many Roles
     * const roles = await prisma.roles.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends RolesCreateManyArgs>(args?: SelectSubset<T, RolesCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Roles and returns the data saved in the database.
     * @param {RolesCreateManyAndReturnArgs} args - Arguments to create many Roles.
     * @example
     * // Create many Roles
     * const roles = await prisma.roles.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Roles and only return the `id`
     * const rolesWithIdOnly = await prisma.roles.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends RolesCreateManyAndReturnArgs>(args?: SelectSubset<T, RolesCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RolesPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Roles.
     * @param {RolesDeleteArgs} args - Arguments to delete one Roles.
     * @example
     * // Delete one Roles
     * const Roles = await prisma.roles.delete({
     *   where: {
     *     // ... filter to delete one Roles
     *   }
     * })
     * 
     */
    delete<T extends RolesDeleteArgs>(args: SelectSubset<T, RolesDeleteArgs<ExtArgs>>): Prisma__RolesClient<$Result.GetResult<Prisma.$RolesPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Roles.
     * @param {RolesUpdateArgs} args - Arguments to update one Roles.
     * @example
     * // Update one Roles
     * const roles = await prisma.roles.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends RolesUpdateArgs>(args: SelectSubset<T, RolesUpdateArgs<ExtArgs>>): Prisma__RolesClient<$Result.GetResult<Prisma.$RolesPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Roles.
     * @param {RolesDeleteManyArgs} args - Arguments to filter Roles to delete.
     * @example
     * // Delete a few Roles
     * const { count } = await prisma.roles.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends RolesDeleteManyArgs>(args?: SelectSubset<T, RolesDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Roles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RolesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Roles
     * const roles = await prisma.roles.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends RolesUpdateManyArgs>(args: SelectSubset<T, RolesUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Roles.
     * @param {RolesUpsertArgs} args - Arguments to update or create a Roles.
     * @example
     * // Update or create a Roles
     * const roles = await prisma.roles.upsert({
     *   create: {
     *     // ... data to create a Roles
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Roles we want to update
     *   }
     * })
     */
    upsert<T extends RolesUpsertArgs>(args: SelectSubset<T, RolesUpsertArgs<ExtArgs>>): Prisma__RolesClient<$Result.GetResult<Prisma.$RolesPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Roles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RolesCountArgs} args - Arguments to filter Roles to count.
     * @example
     * // Count the number of Roles
     * const count = await prisma.roles.count({
     *   where: {
     *     // ... the filter for the Roles we want to count
     *   }
     * })
    **/
    count<T extends RolesCountArgs>(
      args?: Subset<T, RolesCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], RolesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Roles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RolesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends RolesAggregateArgs>(args: Subset<T, RolesAggregateArgs>): Prisma.PrismaPromise<GetRolesAggregateType<T>>

    /**
     * Group by Roles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RolesGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends RolesGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: RolesGroupByArgs['orderBy'] }
        : { orderBy?: RolesGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, RolesGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRolesGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Roles model
   */
  readonly fields: RolesFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Roles.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__RolesClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    Users<T extends Roles$UsersArgs<ExtArgs> = {}>(args?: Subset<T, Roles$UsersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UsersPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Roles model
   */ 
  interface RolesFieldRefs {
    readonly id: FieldRef<"Roles", 'Int'>
    readonly title: FieldRef<"Roles", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Roles findUnique
   */
  export type RolesFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Roles
     */
    select?: RolesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RolesInclude<ExtArgs> | null
    /**
     * Filter, which Roles to fetch.
     */
    where: RolesWhereUniqueInput
  }

  /**
   * Roles findUniqueOrThrow
   */
  export type RolesFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Roles
     */
    select?: RolesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RolesInclude<ExtArgs> | null
    /**
     * Filter, which Roles to fetch.
     */
    where: RolesWhereUniqueInput
  }

  /**
   * Roles findFirst
   */
  export type RolesFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Roles
     */
    select?: RolesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RolesInclude<ExtArgs> | null
    /**
     * Filter, which Roles to fetch.
     */
    where?: RolesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Roles to fetch.
     */
    orderBy?: RolesOrderByWithRelationInput | RolesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Roles.
     */
    cursor?: RolesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Roles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Roles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Roles.
     */
    distinct?: RolesScalarFieldEnum | RolesScalarFieldEnum[]
  }

  /**
   * Roles findFirstOrThrow
   */
  export type RolesFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Roles
     */
    select?: RolesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RolesInclude<ExtArgs> | null
    /**
     * Filter, which Roles to fetch.
     */
    where?: RolesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Roles to fetch.
     */
    orderBy?: RolesOrderByWithRelationInput | RolesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Roles.
     */
    cursor?: RolesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Roles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Roles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Roles.
     */
    distinct?: RolesScalarFieldEnum | RolesScalarFieldEnum[]
  }

  /**
   * Roles findMany
   */
  export type RolesFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Roles
     */
    select?: RolesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RolesInclude<ExtArgs> | null
    /**
     * Filter, which Roles to fetch.
     */
    where?: RolesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Roles to fetch.
     */
    orderBy?: RolesOrderByWithRelationInput | RolesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Roles.
     */
    cursor?: RolesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Roles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Roles.
     */
    skip?: number
    distinct?: RolesScalarFieldEnum | RolesScalarFieldEnum[]
  }

  /**
   * Roles create
   */
  export type RolesCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Roles
     */
    select?: RolesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RolesInclude<ExtArgs> | null
    /**
     * The data needed to create a Roles.
     */
    data: XOR<RolesCreateInput, RolesUncheckedCreateInput>
  }

  /**
   * Roles createMany
   */
  export type RolesCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Roles.
     */
    data: RolesCreateManyInput | RolesCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Roles createManyAndReturn
   */
  export type RolesCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Roles
     */
    select?: RolesSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Roles.
     */
    data: RolesCreateManyInput | RolesCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Roles update
   */
  export type RolesUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Roles
     */
    select?: RolesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RolesInclude<ExtArgs> | null
    /**
     * The data needed to update a Roles.
     */
    data: XOR<RolesUpdateInput, RolesUncheckedUpdateInput>
    /**
     * Choose, which Roles to update.
     */
    where: RolesWhereUniqueInput
  }

  /**
   * Roles updateMany
   */
  export type RolesUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Roles.
     */
    data: XOR<RolesUpdateManyMutationInput, RolesUncheckedUpdateManyInput>
    /**
     * Filter which Roles to update
     */
    where?: RolesWhereInput
  }

  /**
   * Roles upsert
   */
  export type RolesUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Roles
     */
    select?: RolesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RolesInclude<ExtArgs> | null
    /**
     * The filter to search for the Roles to update in case it exists.
     */
    where: RolesWhereUniqueInput
    /**
     * In case the Roles found by the `where` argument doesn't exist, create a new Roles with this data.
     */
    create: XOR<RolesCreateInput, RolesUncheckedCreateInput>
    /**
     * In case the Roles was found with the provided `where` argument, update it with this data.
     */
    update: XOR<RolesUpdateInput, RolesUncheckedUpdateInput>
  }

  /**
   * Roles delete
   */
  export type RolesDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Roles
     */
    select?: RolesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RolesInclude<ExtArgs> | null
    /**
     * Filter which Roles to delete.
     */
    where: RolesWhereUniqueInput
  }

  /**
   * Roles deleteMany
   */
  export type RolesDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Roles to delete
     */
    where?: RolesWhereInput
  }

  /**
   * Roles.Users
   */
  export type Roles$UsersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Users
     */
    select?: UsersSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsersInclude<ExtArgs> | null
    where?: UsersWhereInput
    orderBy?: UsersOrderByWithRelationInput | UsersOrderByWithRelationInput[]
    cursor?: UsersWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UsersScalarFieldEnum | UsersScalarFieldEnum[]
  }

  /**
   * Roles without action
   */
  export type RolesDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Roles
     */
    select?: RolesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RolesInclude<ExtArgs> | null
  }


  /**
   * Model Users
   */

  export type AggregateUsers = {
    _count: UsersCountAggregateOutputType | null
    _avg: UsersAvgAggregateOutputType | null
    _sum: UsersSumAggregateOutputType | null
    _min: UsersMinAggregateOutputType | null
    _max: UsersMaxAggregateOutputType | null
  }

  export type UsersAvgAggregateOutputType = {
    id: number | null
    roleId: number | null
  }

  export type UsersSumAggregateOutputType = {
    id: number | null
    roleId: number | null
  }

  export type UsersMinAggregateOutputType = {
    id: number | null
    googleId: string | null
    facebookId: string | null
    name: string | null
    email: string | null
    phone: string | null
    image: string | null
    password: string | null
    address: string | null
    roleId: number | null
  }

  export type UsersMaxAggregateOutputType = {
    id: number | null
    googleId: string | null
    facebookId: string | null
    name: string | null
    email: string | null
    phone: string | null
    image: string | null
    password: string | null
    address: string | null
    roleId: number | null
  }

  export type UsersCountAggregateOutputType = {
    id: number
    googleId: number
    facebookId: number
    name: number
    email: number
    phone: number
    image: number
    password: number
    address: number
    roleId: number
    _all: number
  }


  export type UsersAvgAggregateInputType = {
    id?: true
    roleId?: true
  }

  export type UsersSumAggregateInputType = {
    id?: true
    roleId?: true
  }

  export type UsersMinAggregateInputType = {
    id?: true
    googleId?: true
    facebookId?: true
    name?: true
    email?: true
    phone?: true
    image?: true
    password?: true
    address?: true
    roleId?: true
  }

  export type UsersMaxAggregateInputType = {
    id?: true
    googleId?: true
    facebookId?: true
    name?: true
    email?: true
    phone?: true
    image?: true
    password?: true
    address?: true
    roleId?: true
  }

  export type UsersCountAggregateInputType = {
    id?: true
    googleId?: true
    facebookId?: true
    name?: true
    email?: true
    phone?: true
    image?: true
    password?: true
    address?: true
    roleId?: true
    _all?: true
  }

  export type UsersAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Users to aggregate.
     */
    where?: UsersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UsersOrderByWithRelationInput | UsersOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UsersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Users
    **/
    _count?: true | UsersCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: UsersAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: UsersSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UsersMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UsersMaxAggregateInputType
  }

  export type GetUsersAggregateType<T extends UsersAggregateArgs> = {
        [P in keyof T & keyof AggregateUsers]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUsers[P]>
      : GetScalarType<T[P], AggregateUsers[P]>
  }




  export type UsersGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UsersWhereInput
    orderBy?: UsersOrderByWithAggregationInput | UsersOrderByWithAggregationInput[]
    by: UsersScalarFieldEnum[] | UsersScalarFieldEnum
    having?: UsersScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UsersCountAggregateInputType | true
    _avg?: UsersAvgAggregateInputType
    _sum?: UsersSumAggregateInputType
    _min?: UsersMinAggregateInputType
    _max?: UsersMaxAggregateInputType
  }

  export type UsersGroupByOutputType = {
    id: number
    googleId: string | null
    facebookId: string | null
    name: string
    email: string
    phone: string
    image: string | null
    password: string
    address: string
    roleId: number
    _count: UsersCountAggregateOutputType | null
    _avg: UsersAvgAggregateOutputType | null
    _sum: UsersSumAggregateOutputType | null
    _min: UsersMinAggregateOutputType | null
    _max: UsersMaxAggregateOutputType | null
  }

  type GetUsersGroupByPayload<T extends UsersGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UsersGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UsersGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UsersGroupByOutputType[P]>
            : GetScalarType<T[P], UsersGroupByOutputType[P]>
        }
      >
    >


  export type UsersSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    googleId?: boolean
    facebookId?: boolean
    name?: boolean
    email?: boolean
    phone?: boolean
    image?: boolean
    password?: boolean
    address?: boolean
    roleId?: boolean
    roles?: boolean | RolesDefaultArgs<ExtArgs>
    Futsals?: boolean | Users$FutsalsArgs<ExtArgs>
    Bookings?: boolean | Users$BookingsArgs<ExtArgs>
    MatchRequest?: boolean | Users$MatchRequestArgs<ExtArgs>
    organizedMatches?: boolean | Users$organizedMatchesArgs<ExtArgs>
    opponentMatches?: boolean | Users$opponentMatchesArgs<ExtArgs>
    _count?: boolean | UsersCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["users"]>

  export type UsersSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    googleId?: boolean
    facebookId?: boolean
    name?: boolean
    email?: boolean
    phone?: boolean
    image?: boolean
    password?: boolean
    address?: boolean
    roleId?: boolean
    roles?: boolean | RolesDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["users"]>

  export type UsersSelectScalar = {
    id?: boolean
    googleId?: boolean
    facebookId?: boolean
    name?: boolean
    email?: boolean
    phone?: boolean
    image?: boolean
    password?: boolean
    address?: boolean
    roleId?: boolean
  }

  export type UsersInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    roles?: boolean | RolesDefaultArgs<ExtArgs>
    Futsals?: boolean | Users$FutsalsArgs<ExtArgs>
    Bookings?: boolean | Users$BookingsArgs<ExtArgs>
    MatchRequest?: boolean | Users$MatchRequestArgs<ExtArgs>
    organizedMatches?: boolean | Users$organizedMatchesArgs<ExtArgs>
    opponentMatches?: boolean | Users$opponentMatchesArgs<ExtArgs>
    _count?: boolean | UsersCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type UsersIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    roles?: boolean | RolesDefaultArgs<ExtArgs>
  }

  export type $UsersPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Users"
    objects: {
      roles: Prisma.$RolesPayload<ExtArgs>
      Futsals: Prisma.$FutsalsPayload<ExtArgs> | null
      Bookings: Prisma.$BookingsPayload<ExtArgs>[]
      MatchRequest: Prisma.$MatchRequestPayload<ExtArgs> | null
      organizedMatches: Prisma.$MatchesPayload<ExtArgs>[]
      opponentMatches: Prisma.$MatchesPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      googleId: string | null
      facebookId: string | null
      name: string
      email: string
      phone: string
      image: string | null
      password: string
      address: string
      roleId: number
    }, ExtArgs["result"]["users"]>
    composites: {}
  }

  type UsersGetPayload<S extends boolean | null | undefined | UsersDefaultArgs> = $Result.GetResult<Prisma.$UsersPayload, S>

  type UsersCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<UsersFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: UsersCountAggregateInputType | true
    }

  export interface UsersDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Users'], meta: { name: 'Users' } }
    /**
     * Find zero or one Users that matches the filter.
     * @param {UsersFindUniqueArgs} args - Arguments to find a Users
     * @example
     * // Get one Users
     * const users = await prisma.users.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UsersFindUniqueArgs>(args: SelectSubset<T, UsersFindUniqueArgs<ExtArgs>>): Prisma__UsersClient<$Result.GetResult<Prisma.$UsersPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Users that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {UsersFindUniqueOrThrowArgs} args - Arguments to find a Users
     * @example
     * // Get one Users
     * const users = await prisma.users.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UsersFindUniqueOrThrowArgs>(args: SelectSubset<T, UsersFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UsersClient<$Result.GetResult<Prisma.$UsersPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UsersFindFirstArgs} args - Arguments to find a Users
     * @example
     * // Get one Users
     * const users = await prisma.users.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UsersFindFirstArgs>(args?: SelectSubset<T, UsersFindFirstArgs<ExtArgs>>): Prisma__UsersClient<$Result.GetResult<Prisma.$UsersPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Users that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UsersFindFirstOrThrowArgs} args - Arguments to find a Users
     * @example
     * // Get one Users
     * const users = await prisma.users.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UsersFindFirstOrThrowArgs>(args?: SelectSubset<T, UsersFindFirstOrThrowArgs<ExtArgs>>): Prisma__UsersClient<$Result.GetResult<Prisma.$UsersPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UsersFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Users
     * const users = await prisma.users.findMany()
     * 
     * // Get first 10 Users
     * const users = await prisma.users.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const usersWithIdOnly = await prisma.users.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UsersFindManyArgs>(args?: SelectSubset<T, UsersFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UsersPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Users.
     * @param {UsersCreateArgs} args - Arguments to create a Users.
     * @example
     * // Create one Users
     * const Users = await prisma.users.create({
     *   data: {
     *     // ... data to create a Users
     *   }
     * })
     * 
     */
    create<T extends UsersCreateArgs>(args: SelectSubset<T, UsersCreateArgs<ExtArgs>>): Prisma__UsersClient<$Result.GetResult<Prisma.$UsersPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Users.
     * @param {UsersCreateManyArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const users = await prisma.users.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UsersCreateManyArgs>(args?: SelectSubset<T, UsersCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Users and returns the data saved in the database.
     * @param {UsersCreateManyAndReturnArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const users = await prisma.users.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Users and only return the `id`
     * const usersWithIdOnly = await prisma.users.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UsersCreateManyAndReturnArgs>(args?: SelectSubset<T, UsersCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UsersPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Users.
     * @param {UsersDeleteArgs} args - Arguments to delete one Users.
     * @example
     * // Delete one Users
     * const Users = await prisma.users.delete({
     *   where: {
     *     // ... filter to delete one Users
     *   }
     * })
     * 
     */
    delete<T extends UsersDeleteArgs>(args: SelectSubset<T, UsersDeleteArgs<ExtArgs>>): Prisma__UsersClient<$Result.GetResult<Prisma.$UsersPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Users.
     * @param {UsersUpdateArgs} args - Arguments to update one Users.
     * @example
     * // Update one Users
     * const users = await prisma.users.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UsersUpdateArgs>(args: SelectSubset<T, UsersUpdateArgs<ExtArgs>>): Prisma__UsersClient<$Result.GetResult<Prisma.$UsersPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Users.
     * @param {UsersDeleteManyArgs} args - Arguments to filter Users to delete.
     * @example
     * // Delete a few Users
     * const { count } = await prisma.users.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UsersDeleteManyArgs>(args?: SelectSubset<T, UsersDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UsersUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Users
     * const users = await prisma.users.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UsersUpdateManyArgs>(args: SelectSubset<T, UsersUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Users.
     * @param {UsersUpsertArgs} args - Arguments to update or create a Users.
     * @example
     * // Update or create a Users
     * const users = await prisma.users.upsert({
     *   create: {
     *     // ... data to create a Users
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Users we want to update
     *   }
     * })
     */
    upsert<T extends UsersUpsertArgs>(args: SelectSubset<T, UsersUpsertArgs<ExtArgs>>): Prisma__UsersClient<$Result.GetResult<Prisma.$UsersPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UsersCountArgs} args - Arguments to filter Users to count.
     * @example
     * // Count the number of Users
     * const count = await prisma.users.count({
     *   where: {
     *     // ... the filter for the Users we want to count
     *   }
     * })
    **/
    count<T extends UsersCountArgs>(
      args?: Subset<T, UsersCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UsersCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UsersAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UsersAggregateArgs>(args: Subset<T, UsersAggregateArgs>): Prisma.PrismaPromise<GetUsersAggregateType<T>>

    /**
     * Group by Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UsersGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UsersGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UsersGroupByArgs['orderBy'] }
        : { orderBy?: UsersGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UsersGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUsersGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Users model
   */
  readonly fields: UsersFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Users.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UsersClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    roles<T extends RolesDefaultArgs<ExtArgs> = {}>(args?: Subset<T, RolesDefaultArgs<ExtArgs>>): Prisma__RolesClient<$Result.GetResult<Prisma.$RolesPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    Futsals<T extends Users$FutsalsArgs<ExtArgs> = {}>(args?: Subset<T, Users$FutsalsArgs<ExtArgs>>): Prisma__FutsalsClient<$Result.GetResult<Prisma.$FutsalsPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    Bookings<T extends Users$BookingsArgs<ExtArgs> = {}>(args?: Subset<T, Users$BookingsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BookingsPayload<ExtArgs>, T, "findMany"> | Null>
    MatchRequest<T extends Users$MatchRequestArgs<ExtArgs> = {}>(args?: Subset<T, Users$MatchRequestArgs<ExtArgs>>): Prisma__MatchRequestClient<$Result.GetResult<Prisma.$MatchRequestPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    organizedMatches<T extends Users$organizedMatchesArgs<ExtArgs> = {}>(args?: Subset<T, Users$organizedMatchesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MatchesPayload<ExtArgs>, T, "findMany"> | Null>
    opponentMatches<T extends Users$opponentMatchesArgs<ExtArgs> = {}>(args?: Subset<T, Users$opponentMatchesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MatchesPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Users model
   */ 
  interface UsersFieldRefs {
    readonly id: FieldRef<"Users", 'Int'>
    readonly googleId: FieldRef<"Users", 'String'>
    readonly facebookId: FieldRef<"Users", 'String'>
    readonly name: FieldRef<"Users", 'String'>
    readonly email: FieldRef<"Users", 'String'>
    readonly phone: FieldRef<"Users", 'String'>
    readonly image: FieldRef<"Users", 'String'>
    readonly password: FieldRef<"Users", 'String'>
    readonly address: FieldRef<"Users", 'String'>
    readonly roleId: FieldRef<"Users", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * Users findUnique
   */
  export type UsersFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Users
     */
    select?: UsersSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsersInclude<ExtArgs> | null
    /**
     * Filter, which Users to fetch.
     */
    where: UsersWhereUniqueInput
  }

  /**
   * Users findUniqueOrThrow
   */
  export type UsersFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Users
     */
    select?: UsersSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsersInclude<ExtArgs> | null
    /**
     * Filter, which Users to fetch.
     */
    where: UsersWhereUniqueInput
  }

  /**
   * Users findFirst
   */
  export type UsersFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Users
     */
    select?: UsersSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsersInclude<ExtArgs> | null
    /**
     * Filter, which Users to fetch.
     */
    where?: UsersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UsersOrderByWithRelationInput | UsersOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UsersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UsersScalarFieldEnum | UsersScalarFieldEnum[]
  }

  /**
   * Users findFirstOrThrow
   */
  export type UsersFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Users
     */
    select?: UsersSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsersInclude<ExtArgs> | null
    /**
     * Filter, which Users to fetch.
     */
    where?: UsersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UsersOrderByWithRelationInput | UsersOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UsersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UsersScalarFieldEnum | UsersScalarFieldEnum[]
  }

  /**
   * Users findMany
   */
  export type UsersFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Users
     */
    select?: UsersSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsersInclude<ExtArgs> | null
    /**
     * Filter, which Users to fetch.
     */
    where?: UsersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UsersOrderByWithRelationInput | UsersOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Users.
     */
    cursor?: UsersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    distinct?: UsersScalarFieldEnum | UsersScalarFieldEnum[]
  }

  /**
   * Users create
   */
  export type UsersCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Users
     */
    select?: UsersSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsersInclude<ExtArgs> | null
    /**
     * The data needed to create a Users.
     */
    data: XOR<UsersCreateInput, UsersUncheckedCreateInput>
  }

  /**
   * Users createMany
   */
  export type UsersCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Users.
     */
    data: UsersCreateManyInput | UsersCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Users createManyAndReturn
   */
  export type UsersCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Users
     */
    select?: UsersSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Users.
     */
    data: UsersCreateManyInput | UsersCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsersIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Users update
   */
  export type UsersUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Users
     */
    select?: UsersSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsersInclude<ExtArgs> | null
    /**
     * The data needed to update a Users.
     */
    data: XOR<UsersUpdateInput, UsersUncheckedUpdateInput>
    /**
     * Choose, which Users to update.
     */
    where: UsersWhereUniqueInput
  }

  /**
   * Users updateMany
   */
  export type UsersUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Users.
     */
    data: XOR<UsersUpdateManyMutationInput, UsersUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UsersWhereInput
  }

  /**
   * Users upsert
   */
  export type UsersUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Users
     */
    select?: UsersSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsersInclude<ExtArgs> | null
    /**
     * The filter to search for the Users to update in case it exists.
     */
    where: UsersWhereUniqueInput
    /**
     * In case the Users found by the `where` argument doesn't exist, create a new Users with this data.
     */
    create: XOR<UsersCreateInput, UsersUncheckedCreateInput>
    /**
     * In case the Users was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UsersUpdateInput, UsersUncheckedUpdateInput>
  }

  /**
   * Users delete
   */
  export type UsersDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Users
     */
    select?: UsersSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsersInclude<ExtArgs> | null
    /**
     * Filter which Users to delete.
     */
    where: UsersWhereUniqueInput
  }

  /**
   * Users deleteMany
   */
  export type UsersDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Users to delete
     */
    where?: UsersWhereInput
  }

  /**
   * Users.Futsals
   */
  export type Users$FutsalsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Futsals
     */
    select?: FutsalsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FutsalsInclude<ExtArgs> | null
    where?: FutsalsWhereInput
  }

  /**
   * Users.Bookings
   */
  export type Users$BookingsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Bookings
     */
    select?: BookingsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookingsInclude<ExtArgs> | null
    where?: BookingsWhereInput
    orderBy?: BookingsOrderByWithRelationInput | BookingsOrderByWithRelationInput[]
    cursor?: BookingsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: BookingsScalarFieldEnum | BookingsScalarFieldEnum[]
  }

  /**
   * Users.MatchRequest
   */
  export type Users$MatchRequestArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MatchRequest
     */
    select?: MatchRequestSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MatchRequestInclude<ExtArgs> | null
    where?: MatchRequestWhereInput
  }

  /**
   * Users.organizedMatches
   */
  export type Users$organizedMatchesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Matches
     */
    select?: MatchesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MatchesInclude<ExtArgs> | null
    where?: MatchesWhereInput
    orderBy?: MatchesOrderByWithRelationInput | MatchesOrderByWithRelationInput[]
    cursor?: MatchesWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MatchesScalarFieldEnum | MatchesScalarFieldEnum[]
  }

  /**
   * Users.opponentMatches
   */
  export type Users$opponentMatchesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Matches
     */
    select?: MatchesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MatchesInclude<ExtArgs> | null
    where?: MatchesWhereInput
    orderBy?: MatchesOrderByWithRelationInput | MatchesOrderByWithRelationInput[]
    cursor?: MatchesWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MatchesScalarFieldEnum | MatchesScalarFieldEnum[]
  }

  /**
   * Users without action
   */
  export type UsersDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Users
     */
    select?: UsersSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsersInclude<ExtArgs> | null
  }


  /**
   * Model Futsals
   */

  export type AggregateFutsals = {
    _count: FutsalsCountAggregateOutputType | null
    _avg: FutsalsAvgAggregateOutputType | null
    _sum: FutsalsSumAggregateOutputType | null
    _min: FutsalsMinAggregateOutputType | null
    _max: FutsalsMaxAggregateOutputType | null
  }

  export type FutsalsAvgAggregateOutputType = {
    id: number | null
    stdPrice: number | null
    rating: Decimal | null
    userId: number | null
  }

  export type FutsalsSumAggregateOutputType = {
    id: number | null
    stdPrice: number | null
    rating: Decimal | null
    userId: number | null
  }

  export type FutsalsMinAggregateOutputType = {
    id: number | null
    name: string | null
    phone: string | null
    address: string | null
    type: $Enums.FutsalType | null
    startTime: Date | null
    endTime: Date | null
    stdPrice: number | null
    rating: Decimal | null
    pan: string | null
    userId: number | null
  }

  export type FutsalsMaxAggregateOutputType = {
    id: number | null
    name: string | null
    phone: string | null
    address: string | null
    type: $Enums.FutsalType | null
    startTime: Date | null
    endTime: Date | null
    stdPrice: number | null
    rating: Decimal | null
    pan: string | null
    userId: number | null
  }

  export type FutsalsCountAggregateOutputType = {
    id: number
    name: number
    phone: number
    address: number
    type: number
    startTime: number
    endTime: number
    amenities: number
    stdPrice: number
    rating: number
    pan: number
    userId: number
    _all: number
  }


  export type FutsalsAvgAggregateInputType = {
    id?: true
    stdPrice?: true
    rating?: true
    userId?: true
  }

  export type FutsalsSumAggregateInputType = {
    id?: true
    stdPrice?: true
    rating?: true
    userId?: true
  }

  export type FutsalsMinAggregateInputType = {
    id?: true
    name?: true
    phone?: true
    address?: true
    type?: true
    startTime?: true
    endTime?: true
    stdPrice?: true
    rating?: true
    pan?: true
    userId?: true
  }

  export type FutsalsMaxAggregateInputType = {
    id?: true
    name?: true
    phone?: true
    address?: true
    type?: true
    startTime?: true
    endTime?: true
    stdPrice?: true
    rating?: true
    pan?: true
    userId?: true
  }

  export type FutsalsCountAggregateInputType = {
    id?: true
    name?: true
    phone?: true
    address?: true
    type?: true
    startTime?: true
    endTime?: true
    amenities?: true
    stdPrice?: true
    rating?: true
    pan?: true
    userId?: true
    _all?: true
  }

  export type FutsalsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Futsals to aggregate.
     */
    where?: FutsalsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Futsals to fetch.
     */
    orderBy?: FutsalsOrderByWithRelationInput | FutsalsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: FutsalsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Futsals from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Futsals.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Futsals
    **/
    _count?: true | FutsalsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: FutsalsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: FutsalsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: FutsalsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: FutsalsMaxAggregateInputType
  }

  export type GetFutsalsAggregateType<T extends FutsalsAggregateArgs> = {
        [P in keyof T & keyof AggregateFutsals]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateFutsals[P]>
      : GetScalarType<T[P], AggregateFutsals[P]>
  }




  export type FutsalsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FutsalsWhereInput
    orderBy?: FutsalsOrderByWithAggregationInput | FutsalsOrderByWithAggregationInput[]
    by: FutsalsScalarFieldEnum[] | FutsalsScalarFieldEnum
    having?: FutsalsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: FutsalsCountAggregateInputType | true
    _avg?: FutsalsAvgAggregateInputType
    _sum?: FutsalsSumAggregateInputType
    _min?: FutsalsMinAggregateInputType
    _max?: FutsalsMaxAggregateInputType
  }

  export type FutsalsGroupByOutputType = {
    id: number
    name: string
    phone: string
    address: string
    type: $Enums.FutsalType
    startTime: Date
    endTime: Date
    amenities: string[]
    stdPrice: number
    rating: Decimal
    pan: string
    userId: number
    _count: FutsalsCountAggregateOutputType | null
    _avg: FutsalsAvgAggregateOutputType | null
    _sum: FutsalsSumAggregateOutputType | null
    _min: FutsalsMinAggregateOutputType | null
    _max: FutsalsMaxAggregateOutputType | null
  }

  type GetFutsalsGroupByPayload<T extends FutsalsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<FutsalsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof FutsalsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], FutsalsGroupByOutputType[P]>
            : GetScalarType<T[P], FutsalsGroupByOutputType[P]>
        }
      >
    >


  export type FutsalsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    phone?: boolean
    address?: boolean
    type?: boolean
    startTime?: boolean
    endTime?: boolean
    amenities?: boolean
    stdPrice?: boolean
    rating?: boolean
    pan?: boolean
    userId?: boolean
    images?: boolean | Futsals$imagesArgs<ExtArgs>
    users?: boolean | UsersDefaultArgs<ExtArgs>
    PriceLists?: boolean | Futsals$PriceListsArgs<ExtArgs>
    Bookings?: boolean | Futsals$BookingsArgs<ExtArgs>
    timeSlots?: boolean | Futsals$timeSlotsArgs<ExtArgs>
    _count?: boolean | FutsalsCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["futsals"]>

  export type FutsalsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    phone?: boolean
    address?: boolean
    type?: boolean
    startTime?: boolean
    endTime?: boolean
    amenities?: boolean
    stdPrice?: boolean
    rating?: boolean
    pan?: boolean
    userId?: boolean
    users?: boolean | UsersDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["futsals"]>

  export type FutsalsSelectScalar = {
    id?: boolean
    name?: boolean
    phone?: boolean
    address?: boolean
    type?: boolean
    startTime?: boolean
    endTime?: boolean
    amenities?: boolean
    stdPrice?: boolean
    rating?: boolean
    pan?: boolean
    userId?: boolean
  }

  export type FutsalsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    images?: boolean | Futsals$imagesArgs<ExtArgs>
    users?: boolean | UsersDefaultArgs<ExtArgs>
    PriceLists?: boolean | Futsals$PriceListsArgs<ExtArgs>
    Bookings?: boolean | Futsals$BookingsArgs<ExtArgs>
    timeSlots?: boolean | Futsals$timeSlotsArgs<ExtArgs>
    _count?: boolean | FutsalsCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type FutsalsIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    users?: boolean | UsersDefaultArgs<ExtArgs>
  }

  export type $FutsalsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Futsals"
    objects: {
      images: Prisma.$FutsalImagePayload<ExtArgs>[]
      users: Prisma.$UsersPayload<ExtArgs>
      PriceLists: Prisma.$PriceListsPayload<ExtArgs>[]
      Bookings: Prisma.$BookingsPayload<ExtArgs>[]
      timeSlots: Prisma.$TimeSlotsPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      name: string
      phone: string
      address: string
      type: $Enums.FutsalType
      startTime: Date
      endTime: Date
      amenities: string[]
      stdPrice: number
      rating: Prisma.Decimal
      pan: string
      userId: number
    }, ExtArgs["result"]["futsals"]>
    composites: {}
  }

  type FutsalsGetPayload<S extends boolean | null | undefined | FutsalsDefaultArgs> = $Result.GetResult<Prisma.$FutsalsPayload, S>

  type FutsalsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<FutsalsFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: FutsalsCountAggregateInputType | true
    }

  export interface FutsalsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Futsals'], meta: { name: 'Futsals' } }
    /**
     * Find zero or one Futsals that matches the filter.
     * @param {FutsalsFindUniqueArgs} args - Arguments to find a Futsals
     * @example
     * // Get one Futsals
     * const futsals = await prisma.futsals.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends FutsalsFindUniqueArgs>(args: SelectSubset<T, FutsalsFindUniqueArgs<ExtArgs>>): Prisma__FutsalsClient<$Result.GetResult<Prisma.$FutsalsPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Futsals that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {FutsalsFindUniqueOrThrowArgs} args - Arguments to find a Futsals
     * @example
     * // Get one Futsals
     * const futsals = await prisma.futsals.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends FutsalsFindUniqueOrThrowArgs>(args: SelectSubset<T, FutsalsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__FutsalsClient<$Result.GetResult<Prisma.$FutsalsPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Futsals that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FutsalsFindFirstArgs} args - Arguments to find a Futsals
     * @example
     * // Get one Futsals
     * const futsals = await prisma.futsals.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends FutsalsFindFirstArgs>(args?: SelectSubset<T, FutsalsFindFirstArgs<ExtArgs>>): Prisma__FutsalsClient<$Result.GetResult<Prisma.$FutsalsPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Futsals that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FutsalsFindFirstOrThrowArgs} args - Arguments to find a Futsals
     * @example
     * // Get one Futsals
     * const futsals = await prisma.futsals.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends FutsalsFindFirstOrThrowArgs>(args?: SelectSubset<T, FutsalsFindFirstOrThrowArgs<ExtArgs>>): Prisma__FutsalsClient<$Result.GetResult<Prisma.$FutsalsPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Futsals that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FutsalsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Futsals
     * const futsals = await prisma.futsals.findMany()
     * 
     * // Get first 10 Futsals
     * const futsals = await prisma.futsals.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const futsalsWithIdOnly = await prisma.futsals.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends FutsalsFindManyArgs>(args?: SelectSubset<T, FutsalsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FutsalsPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Futsals.
     * @param {FutsalsCreateArgs} args - Arguments to create a Futsals.
     * @example
     * // Create one Futsals
     * const Futsals = await prisma.futsals.create({
     *   data: {
     *     // ... data to create a Futsals
     *   }
     * })
     * 
     */
    create<T extends FutsalsCreateArgs>(args: SelectSubset<T, FutsalsCreateArgs<ExtArgs>>): Prisma__FutsalsClient<$Result.GetResult<Prisma.$FutsalsPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Futsals.
     * @param {FutsalsCreateManyArgs} args - Arguments to create many Futsals.
     * @example
     * // Create many Futsals
     * const futsals = await prisma.futsals.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends FutsalsCreateManyArgs>(args?: SelectSubset<T, FutsalsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Futsals and returns the data saved in the database.
     * @param {FutsalsCreateManyAndReturnArgs} args - Arguments to create many Futsals.
     * @example
     * // Create many Futsals
     * const futsals = await prisma.futsals.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Futsals and only return the `id`
     * const futsalsWithIdOnly = await prisma.futsals.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends FutsalsCreateManyAndReturnArgs>(args?: SelectSubset<T, FutsalsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FutsalsPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Futsals.
     * @param {FutsalsDeleteArgs} args - Arguments to delete one Futsals.
     * @example
     * // Delete one Futsals
     * const Futsals = await prisma.futsals.delete({
     *   where: {
     *     // ... filter to delete one Futsals
     *   }
     * })
     * 
     */
    delete<T extends FutsalsDeleteArgs>(args: SelectSubset<T, FutsalsDeleteArgs<ExtArgs>>): Prisma__FutsalsClient<$Result.GetResult<Prisma.$FutsalsPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Futsals.
     * @param {FutsalsUpdateArgs} args - Arguments to update one Futsals.
     * @example
     * // Update one Futsals
     * const futsals = await prisma.futsals.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends FutsalsUpdateArgs>(args: SelectSubset<T, FutsalsUpdateArgs<ExtArgs>>): Prisma__FutsalsClient<$Result.GetResult<Prisma.$FutsalsPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Futsals.
     * @param {FutsalsDeleteManyArgs} args - Arguments to filter Futsals to delete.
     * @example
     * // Delete a few Futsals
     * const { count } = await prisma.futsals.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends FutsalsDeleteManyArgs>(args?: SelectSubset<T, FutsalsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Futsals.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FutsalsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Futsals
     * const futsals = await prisma.futsals.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends FutsalsUpdateManyArgs>(args: SelectSubset<T, FutsalsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Futsals.
     * @param {FutsalsUpsertArgs} args - Arguments to update or create a Futsals.
     * @example
     * // Update or create a Futsals
     * const futsals = await prisma.futsals.upsert({
     *   create: {
     *     // ... data to create a Futsals
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Futsals we want to update
     *   }
     * })
     */
    upsert<T extends FutsalsUpsertArgs>(args: SelectSubset<T, FutsalsUpsertArgs<ExtArgs>>): Prisma__FutsalsClient<$Result.GetResult<Prisma.$FutsalsPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Futsals.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FutsalsCountArgs} args - Arguments to filter Futsals to count.
     * @example
     * // Count the number of Futsals
     * const count = await prisma.futsals.count({
     *   where: {
     *     // ... the filter for the Futsals we want to count
     *   }
     * })
    **/
    count<T extends FutsalsCountArgs>(
      args?: Subset<T, FutsalsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], FutsalsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Futsals.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FutsalsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends FutsalsAggregateArgs>(args: Subset<T, FutsalsAggregateArgs>): Prisma.PrismaPromise<GetFutsalsAggregateType<T>>

    /**
     * Group by Futsals.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FutsalsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends FutsalsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: FutsalsGroupByArgs['orderBy'] }
        : { orderBy?: FutsalsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, FutsalsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetFutsalsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Futsals model
   */
  readonly fields: FutsalsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Futsals.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__FutsalsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    images<T extends Futsals$imagesArgs<ExtArgs> = {}>(args?: Subset<T, Futsals$imagesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FutsalImagePayload<ExtArgs>, T, "findMany"> | Null>
    users<T extends UsersDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UsersDefaultArgs<ExtArgs>>): Prisma__UsersClient<$Result.GetResult<Prisma.$UsersPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    PriceLists<T extends Futsals$PriceListsArgs<ExtArgs> = {}>(args?: Subset<T, Futsals$PriceListsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PriceListsPayload<ExtArgs>, T, "findMany"> | Null>
    Bookings<T extends Futsals$BookingsArgs<ExtArgs> = {}>(args?: Subset<T, Futsals$BookingsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BookingsPayload<ExtArgs>, T, "findMany"> | Null>
    timeSlots<T extends Futsals$timeSlotsArgs<ExtArgs> = {}>(args?: Subset<T, Futsals$timeSlotsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TimeSlotsPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Futsals model
   */ 
  interface FutsalsFieldRefs {
    readonly id: FieldRef<"Futsals", 'Int'>
    readonly name: FieldRef<"Futsals", 'String'>
    readonly phone: FieldRef<"Futsals", 'String'>
    readonly address: FieldRef<"Futsals", 'String'>
    readonly type: FieldRef<"Futsals", 'FutsalType'>
    readonly startTime: FieldRef<"Futsals", 'DateTime'>
    readonly endTime: FieldRef<"Futsals", 'DateTime'>
    readonly amenities: FieldRef<"Futsals", 'String[]'>
    readonly stdPrice: FieldRef<"Futsals", 'Int'>
    readonly rating: FieldRef<"Futsals", 'Decimal'>
    readonly pan: FieldRef<"Futsals", 'String'>
    readonly userId: FieldRef<"Futsals", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * Futsals findUnique
   */
  export type FutsalsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Futsals
     */
    select?: FutsalsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FutsalsInclude<ExtArgs> | null
    /**
     * Filter, which Futsals to fetch.
     */
    where: FutsalsWhereUniqueInput
  }

  /**
   * Futsals findUniqueOrThrow
   */
  export type FutsalsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Futsals
     */
    select?: FutsalsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FutsalsInclude<ExtArgs> | null
    /**
     * Filter, which Futsals to fetch.
     */
    where: FutsalsWhereUniqueInput
  }

  /**
   * Futsals findFirst
   */
  export type FutsalsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Futsals
     */
    select?: FutsalsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FutsalsInclude<ExtArgs> | null
    /**
     * Filter, which Futsals to fetch.
     */
    where?: FutsalsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Futsals to fetch.
     */
    orderBy?: FutsalsOrderByWithRelationInput | FutsalsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Futsals.
     */
    cursor?: FutsalsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Futsals from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Futsals.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Futsals.
     */
    distinct?: FutsalsScalarFieldEnum | FutsalsScalarFieldEnum[]
  }

  /**
   * Futsals findFirstOrThrow
   */
  export type FutsalsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Futsals
     */
    select?: FutsalsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FutsalsInclude<ExtArgs> | null
    /**
     * Filter, which Futsals to fetch.
     */
    where?: FutsalsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Futsals to fetch.
     */
    orderBy?: FutsalsOrderByWithRelationInput | FutsalsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Futsals.
     */
    cursor?: FutsalsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Futsals from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Futsals.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Futsals.
     */
    distinct?: FutsalsScalarFieldEnum | FutsalsScalarFieldEnum[]
  }

  /**
   * Futsals findMany
   */
  export type FutsalsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Futsals
     */
    select?: FutsalsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FutsalsInclude<ExtArgs> | null
    /**
     * Filter, which Futsals to fetch.
     */
    where?: FutsalsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Futsals to fetch.
     */
    orderBy?: FutsalsOrderByWithRelationInput | FutsalsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Futsals.
     */
    cursor?: FutsalsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Futsals from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Futsals.
     */
    skip?: number
    distinct?: FutsalsScalarFieldEnum | FutsalsScalarFieldEnum[]
  }

  /**
   * Futsals create
   */
  export type FutsalsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Futsals
     */
    select?: FutsalsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FutsalsInclude<ExtArgs> | null
    /**
     * The data needed to create a Futsals.
     */
    data: XOR<FutsalsCreateInput, FutsalsUncheckedCreateInput>
  }

  /**
   * Futsals createMany
   */
  export type FutsalsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Futsals.
     */
    data: FutsalsCreateManyInput | FutsalsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Futsals createManyAndReturn
   */
  export type FutsalsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Futsals
     */
    select?: FutsalsSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Futsals.
     */
    data: FutsalsCreateManyInput | FutsalsCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FutsalsIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Futsals update
   */
  export type FutsalsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Futsals
     */
    select?: FutsalsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FutsalsInclude<ExtArgs> | null
    /**
     * The data needed to update a Futsals.
     */
    data: XOR<FutsalsUpdateInput, FutsalsUncheckedUpdateInput>
    /**
     * Choose, which Futsals to update.
     */
    where: FutsalsWhereUniqueInput
  }

  /**
   * Futsals updateMany
   */
  export type FutsalsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Futsals.
     */
    data: XOR<FutsalsUpdateManyMutationInput, FutsalsUncheckedUpdateManyInput>
    /**
     * Filter which Futsals to update
     */
    where?: FutsalsWhereInput
  }

  /**
   * Futsals upsert
   */
  export type FutsalsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Futsals
     */
    select?: FutsalsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FutsalsInclude<ExtArgs> | null
    /**
     * The filter to search for the Futsals to update in case it exists.
     */
    where: FutsalsWhereUniqueInput
    /**
     * In case the Futsals found by the `where` argument doesn't exist, create a new Futsals with this data.
     */
    create: XOR<FutsalsCreateInput, FutsalsUncheckedCreateInput>
    /**
     * In case the Futsals was found with the provided `where` argument, update it with this data.
     */
    update: XOR<FutsalsUpdateInput, FutsalsUncheckedUpdateInput>
  }

  /**
   * Futsals delete
   */
  export type FutsalsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Futsals
     */
    select?: FutsalsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FutsalsInclude<ExtArgs> | null
    /**
     * Filter which Futsals to delete.
     */
    where: FutsalsWhereUniqueInput
  }

  /**
   * Futsals deleteMany
   */
  export type FutsalsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Futsals to delete
     */
    where?: FutsalsWhereInput
  }

  /**
   * Futsals.images
   */
  export type Futsals$imagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FutsalImage
     */
    select?: FutsalImageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FutsalImageInclude<ExtArgs> | null
    where?: FutsalImageWhereInput
    orderBy?: FutsalImageOrderByWithRelationInput | FutsalImageOrderByWithRelationInput[]
    cursor?: FutsalImageWhereUniqueInput
    take?: number
    skip?: number
    distinct?: FutsalImageScalarFieldEnum | FutsalImageScalarFieldEnum[]
  }

  /**
   * Futsals.PriceLists
   */
  export type Futsals$PriceListsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PriceLists
     */
    select?: PriceListsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PriceListsInclude<ExtArgs> | null
    where?: PriceListsWhereInput
    orderBy?: PriceListsOrderByWithRelationInput | PriceListsOrderByWithRelationInput[]
    cursor?: PriceListsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PriceListsScalarFieldEnum | PriceListsScalarFieldEnum[]
  }

  /**
   * Futsals.Bookings
   */
  export type Futsals$BookingsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Bookings
     */
    select?: BookingsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookingsInclude<ExtArgs> | null
    where?: BookingsWhereInput
    orderBy?: BookingsOrderByWithRelationInput | BookingsOrderByWithRelationInput[]
    cursor?: BookingsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: BookingsScalarFieldEnum | BookingsScalarFieldEnum[]
  }

  /**
   * Futsals.timeSlots
   */
  export type Futsals$timeSlotsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TimeSlots
     */
    select?: TimeSlotsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TimeSlotsInclude<ExtArgs> | null
    where?: TimeSlotsWhereInput
    orderBy?: TimeSlotsOrderByWithRelationInput | TimeSlotsOrderByWithRelationInput[]
    cursor?: TimeSlotsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TimeSlotsScalarFieldEnum | TimeSlotsScalarFieldEnum[]
  }

  /**
   * Futsals without action
   */
  export type FutsalsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Futsals
     */
    select?: FutsalsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FutsalsInclude<ExtArgs> | null
  }


  /**
   * Model FutsalImage
   */

  export type AggregateFutsalImage = {
    _count: FutsalImageCountAggregateOutputType | null
    _avg: FutsalImageAvgAggregateOutputType | null
    _sum: FutsalImageSumAggregateOutputType | null
    _min: FutsalImageMinAggregateOutputType | null
    _max: FutsalImageMaxAggregateOutputType | null
  }

  export type FutsalImageAvgAggregateOutputType = {
    id: number | null
    futsalId: number | null
  }

  export type FutsalImageSumAggregateOutputType = {
    id: number | null
    futsalId: number | null
  }

  export type FutsalImageMinAggregateOutputType = {
    id: number | null
    url: string | null
    futsalId: number | null
  }

  export type FutsalImageMaxAggregateOutputType = {
    id: number | null
    url: string | null
    futsalId: number | null
  }

  export type FutsalImageCountAggregateOutputType = {
    id: number
    url: number
    futsalId: number
    _all: number
  }


  export type FutsalImageAvgAggregateInputType = {
    id?: true
    futsalId?: true
  }

  export type FutsalImageSumAggregateInputType = {
    id?: true
    futsalId?: true
  }

  export type FutsalImageMinAggregateInputType = {
    id?: true
    url?: true
    futsalId?: true
  }

  export type FutsalImageMaxAggregateInputType = {
    id?: true
    url?: true
    futsalId?: true
  }

  export type FutsalImageCountAggregateInputType = {
    id?: true
    url?: true
    futsalId?: true
    _all?: true
  }

  export type FutsalImageAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which FutsalImage to aggregate.
     */
    where?: FutsalImageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FutsalImages to fetch.
     */
    orderBy?: FutsalImageOrderByWithRelationInput | FutsalImageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: FutsalImageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FutsalImages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FutsalImages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned FutsalImages
    **/
    _count?: true | FutsalImageCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: FutsalImageAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: FutsalImageSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: FutsalImageMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: FutsalImageMaxAggregateInputType
  }

  export type GetFutsalImageAggregateType<T extends FutsalImageAggregateArgs> = {
        [P in keyof T & keyof AggregateFutsalImage]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateFutsalImage[P]>
      : GetScalarType<T[P], AggregateFutsalImage[P]>
  }




  export type FutsalImageGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FutsalImageWhereInput
    orderBy?: FutsalImageOrderByWithAggregationInput | FutsalImageOrderByWithAggregationInput[]
    by: FutsalImageScalarFieldEnum[] | FutsalImageScalarFieldEnum
    having?: FutsalImageScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: FutsalImageCountAggregateInputType | true
    _avg?: FutsalImageAvgAggregateInputType
    _sum?: FutsalImageSumAggregateInputType
    _min?: FutsalImageMinAggregateInputType
    _max?: FutsalImageMaxAggregateInputType
  }

  export type FutsalImageGroupByOutputType = {
    id: number
    url: string
    futsalId: number
    _count: FutsalImageCountAggregateOutputType | null
    _avg: FutsalImageAvgAggregateOutputType | null
    _sum: FutsalImageSumAggregateOutputType | null
    _min: FutsalImageMinAggregateOutputType | null
    _max: FutsalImageMaxAggregateOutputType | null
  }

  type GetFutsalImageGroupByPayload<T extends FutsalImageGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<FutsalImageGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof FutsalImageGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], FutsalImageGroupByOutputType[P]>
            : GetScalarType<T[P], FutsalImageGroupByOutputType[P]>
        }
      >
    >


  export type FutsalImageSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    url?: boolean
    futsalId?: boolean
    futsal?: boolean | FutsalsDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["futsalImage"]>

  export type FutsalImageSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    url?: boolean
    futsalId?: boolean
    futsal?: boolean | FutsalsDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["futsalImage"]>

  export type FutsalImageSelectScalar = {
    id?: boolean
    url?: boolean
    futsalId?: boolean
  }

  export type FutsalImageInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    futsal?: boolean | FutsalsDefaultArgs<ExtArgs>
  }
  export type FutsalImageIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    futsal?: boolean | FutsalsDefaultArgs<ExtArgs>
  }

  export type $FutsalImagePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "FutsalImage"
    objects: {
      futsal: Prisma.$FutsalsPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      url: string
      futsalId: number
    }, ExtArgs["result"]["futsalImage"]>
    composites: {}
  }

  type FutsalImageGetPayload<S extends boolean | null | undefined | FutsalImageDefaultArgs> = $Result.GetResult<Prisma.$FutsalImagePayload, S>

  type FutsalImageCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<FutsalImageFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: FutsalImageCountAggregateInputType | true
    }

  export interface FutsalImageDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['FutsalImage'], meta: { name: 'FutsalImage' } }
    /**
     * Find zero or one FutsalImage that matches the filter.
     * @param {FutsalImageFindUniqueArgs} args - Arguments to find a FutsalImage
     * @example
     * // Get one FutsalImage
     * const futsalImage = await prisma.futsalImage.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends FutsalImageFindUniqueArgs>(args: SelectSubset<T, FutsalImageFindUniqueArgs<ExtArgs>>): Prisma__FutsalImageClient<$Result.GetResult<Prisma.$FutsalImagePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one FutsalImage that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {FutsalImageFindUniqueOrThrowArgs} args - Arguments to find a FutsalImage
     * @example
     * // Get one FutsalImage
     * const futsalImage = await prisma.futsalImage.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends FutsalImageFindUniqueOrThrowArgs>(args: SelectSubset<T, FutsalImageFindUniqueOrThrowArgs<ExtArgs>>): Prisma__FutsalImageClient<$Result.GetResult<Prisma.$FutsalImagePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first FutsalImage that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FutsalImageFindFirstArgs} args - Arguments to find a FutsalImage
     * @example
     * // Get one FutsalImage
     * const futsalImage = await prisma.futsalImage.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends FutsalImageFindFirstArgs>(args?: SelectSubset<T, FutsalImageFindFirstArgs<ExtArgs>>): Prisma__FutsalImageClient<$Result.GetResult<Prisma.$FutsalImagePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first FutsalImage that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FutsalImageFindFirstOrThrowArgs} args - Arguments to find a FutsalImage
     * @example
     * // Get one FutsalImage
     * const futsalImage = await prisma.futsalImage.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends FutsalImageFindFirstOrThrowArgs>(args?: SelectSubset<T, FutsalImageFindFirstOrThrowArgs<ExtArgs>>): Prisma__FutsalImageClient<$Result.GetResult<Prisma.$FutsalImagePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more FutsalImages that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FutsalImageFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all FutsalImages
     * const futsalImages = await prisma.futsalImage.findMany()
     * 
     * // Get first 10 FutsalImages
     * const futsalImages = await prisma.futsalImage.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const futsalImageWithIdOnly = await prisma.futsalImage.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends FutsalImageFindManyArgs>(args?: SelectSubset<T, FutsalImageFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FutsalImagePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a FutsalImage.
     * @param {FutsalImageCreateArgs} args - Arguments to create a FutsalImage.
     * @example
     * // Create one FutsalImage
     * const FutsalImage = await prisma.futsalImage.create({
     *   data: {
     *     // ... data to create a FutsalImage
     *   }
     * })
     * 
     */
    create<T extends FutsalImageCreateArgs>(args: SelectSubset<T, FutsalImageCreateArgs<ExtArgs>>): Prisma__FutsalImageClient<$Result.GetResult<Prisma.$FutsalImagePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many FutsalImages.
     * @param {FutsalImageCreateManyArgs} args - Arguments to create many FutsalImages.
     * @example
     * // Create many FutsalImages
     * const futsalImage = await prisma.futsalImage.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends FutsalImageCreateManyArgs>(args?: SelectSubset<T, FutsalImageCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many FutsalImages and returns the data saved in the database.
     * @param {FutsalImageCreateManyAndReturnArgs} args - Arguments to create many FutsalImages.
     * @example
     * // Create many FutsalImages
     * const futsalImage = await prisma.futsalImage.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many FutsalImages and only return the `id`
     * const futsalImageWithIdOnly = await prisma.futsalImage.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends FutsalImageCreateManyAndReturnArgs>(args?: SelectSubset<T, FutsalImageCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FutsalImagePayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a FutsalImage.
     * @param {FutsalImageDeleteArgs} args - Arguments to delete one FutsalImage.
     * @example
     * // Delete one FutsalImage
     * const FutsalImage = await prisma.futsalImage.delete({
     *   where: {
     *     // ... filter to delete one FutsalImage
     *   }
     * })
     * 
     */
    delete<T extends FutsalImageDeleteArgs>(args: SelectSubset<T, FutsalImageDeleteArgs<ExtArgs>>): Prisma__FutsalImageClient<$Result.GetResult<Prisma.$FutsalImagePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one FutsalImage.
     * @param {FutsalImageUpdateArgs} args - Arguments to update one FutsalImage.
     * @example
     * // Update one FutsalImage
     * const futsalImage = await prisma.futsalImage.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends FutsalImageUpdateArgs>(args: SelectSubset<T, FutsalImageUpdateArgs<ExtArgs>>): Prisma__FutsalImageClient<$Result.GetResult<Prisma.$FutsalImagePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more FutsalImages.
     * @param {FutsalImageDeleteManyArgs} args - Arguments to filter FutsalImages to delete.
     * @example
     * // Delete a few FutsalImages
     * const { count } = await prisma.futsalImage.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends FutsalImageDeleteManyArgs>(args?: SelectSubset<T, FutsalImageDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more FutsalImages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FutsalImageUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many FutsalImages
     * const futsalImage = await prisma.futsalImage.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends FutsalImageUpdateManyArgs>(args: SelectSubset<T, FutsalImageUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one FutsalImage.
     * @param {FutsalImageUpsertArgs} args - Arguments to update or create a FutsalImage.
     * @example
     * // Update or create a FutsalImage
     * const futsalImage = await prisma.futsalImage.upsert({
     *   create: {
     *     // ... data to create a FutsalImage
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the FutsalImage we want to update
     *   }
     * })
     */
    upsert<T extends FutsalImageUpsertArgs>(args: SelectSubset<T, FutsalImageUpsertArgs<ExtArgs>>): Prisma__FutsalImageClient<$Result.GetResult<Prisma.$FutsalImagePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of FutsalImages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FutsalImageCountArgs} args - Arguments to filter FutsalImages to count.
     * @example
     * // Count the number of FutsalImages
     * const count = await prisma.futsalImage.count({
     *   where: {
     *     // ... the filter for the FutsalImages we want to count
     *   }
     * })
    **/
    count<T extends FutsalImageCountArgs>(
      args?: Subset<T, FutsalImageCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], FutsalImageCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a FutsalImage.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FutsalImageAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends FutsalImageAggregateArgs>(args: Subset<T, FutsalImageAggregateArgs>): Prisma.PrismaPromise<GetFutsalImageAggregateType<T>>

    /**
     * Group by FutsalImage.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FutsalImageGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends FutsalImageGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: FutsalImageGroupByArgs['orderBy'] }
        : { orderBy?: FutsalImageGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, FutsalImageGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetFutsalImageGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the FutsalImage model
   */
  readonly fields: FutsalImageFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for FutsalImage.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__FutsalImageClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    futsal<T extends FutsalsDefaultArgs<ExtArgs> = {}>(args?: Subset<T, FutsalsDefaultArgs<ExtArgs>>): Prisma__FutsalsClient<$Result.GetResult<Prisma.$FutsalsPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the FutsalImage model
   */ 
  interface FutsalImageFieldRefs {
    readonly id: FieldRef<"FutsalImage", 'Int'>
    readonly url: FieldRef<"FutsalImage", 'String'>
    readonly futsalId: FieldRef<"FutsalImage", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * FutsalImage findUnique
   */
  export type FutsalImageFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FutsalImage
     */
    select?: FutsalImageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FutsalImageInclude<ExtArgs> | null
    /**
     * Filter, which FutsalImage to fetch.
     */
    where: FutsalImageWhereUniqueInput
  }

  /**
   * FutsalImage findUniqueOrThrow
   */
  export type FutsalImageFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FutsalImage
     */
    select?: FutsalImageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FutsalImageInclude<ExtArgs> | null
    /**
     * Filter, which FutsalImage to fetch.
     */
    where: FutsalImageWhereUniqueInput
  }

  /**
   * FutsalImage findFirst
   */
  export type FutsalImageFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FutsalImage
     */
    select?: FutsalImageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FutsalImageInclude<ExtArgs> | null
    /**
     * Filter, which FutsalImage to fetch.
     */
    where?: FutsalImageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FutsalImages to fetch.
     */
    orderBy?: FutsalImageOrderByWithRelationInput | FutsalImageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for FutsalImages.
     */
    cursor?: FutsalImageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FutsalImages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FutsalImages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of FutsalImages.
     */
    distinct?: FutsalImageScalarFieldEnum | FutsalImageScalarFieldEnum[]
  }

  /**
   * FutsalImage findFirstOrThrow
   */
  export type FutsalImageFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FutsalImage
     */
    select?: FutsalImageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FutsalImageInclude<ExtArgs> | null
    /**
     * Filter, which FutsalImage to fetch.
     */
    where?: FutsalImageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FutsalImages to fetch.
     */
    orderBy?: FutsalImageOrderByWithRelationInput | FutsalImageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for FutsalImages.
     */
    cursor?: FutsalImageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FutsalImages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FutsalImages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of FutsalImages.
     */
    distinct?: FutsalImageScalarFieldEnum | FutsalImageScalarFieldEnum[]
  }

  /**
   * FutsalImage findMany
   */
  export type FutsalImageFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FutsalImage
     */
    select?: FutsalImageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FutsalImageInclude<ExtArgs> | null
    /**
     * Filter, which FutsalImages to fetch.
     */
    where?: FutsalImageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FutsalImages to fetch.
     */
    orderBy?: FutsalImageOrderByWithRelationInput | FutsalImageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing FutsalImages.
     */
    cursor?: FutsalImageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FutsalImages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FutsalImages.
     */
    skip?: number
    distinct?: FutsalImageScalarFieldEnum | FutsalImageScalarFieldEnum[]
  }

  /**
   * FutsalImage create
   */
  export type FutsalImageCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FutsalImage
     */
    select?: FutsalImageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FutsalImageInclude<ExtArgs> | null
    /**
     * The data needed to create a FutsalImage.
     */
    data: XOR<FutsalImageCreateInput, FutsalImageUncheckedCreateInput>
  }

  /**
   * FutsalImage createMany
   */
  export type FutsalImageCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many FutsalImages.
     */
    data: FutsalImageCreateManyInput | FutsalImageCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * FutsalImage createManyAndReturn
   */
  export type FutsalImageCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FutsalImage
     */
    select?: FutsalImageSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many FutsalImages.
     */
    data: FutsalImageCreateManyInput | FutsalImageCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FutsalImageIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * FutsalImage update
   */
  export type FutsalImageUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FutsalImage
     */
    select?: FutsalImageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FutsalImageInclude<ExtArgs> | null
    /**
     * The data needed to update a FutsalImage.
     */
    data: XOR<FutsalImageUpdateInput, FutsalImageUncheckedUpdateInput>
    /**
     * Choose, which FutsalImage to update.
     */
    where: FutsalImageWhereUniqueInput
  }

  /**
   * FutsalImage updateMany
   */
  export type FutsalImageUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update FutsalImages.
     */
    data: XOR<FutsalImageUpdateManyMutationInput, FutsalImageUncheckedUpdateManyInput>
    /**
     * Filter which FutsalImages to update
     */
    where?: FutsalImageWhereInput
  }

  /**
   * FutsalImage upsert
   */
  export type FutsalImageUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FutsalImage
     */
    select?: FutsalImageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FutsalImageInclude<ExtArgs> | null
    /**
     * The filter to search for the FutsalImage to update in case it exists.
     */
    where: FutsalImageWhereUniqueInput
    /**
     * In case the FutsalImage found by the `where` argument doesn't exist, create a new FutsalImage with this data.
     */
    create: XOR<FutsalImageCreateInput, FutsalImageUncheckedCreateInput>
    /**
     * In case the FutsalImage was found with the provided `where` argument, update it with this data.
     */
    update: XOR<FutsalImageUpdateInput, FutsalImageUncheckedUpdateInput>
  }

  /**
   * FutsalImage delete
   */
  export type FutsalImageDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FutsalImage
     */
    select?: FutsalImageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FutsalImageInclude<ExtArgs> | null
    /**
     * Filter which FutsalImage to delete.
     */
    where: FutsalImageWhereUniqueInput
  }

  /**
   * FutsalImage deleteMany
   */
  export type FutsalImageDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which FutsalImages to delete
     */
    where?: FutsalImageWhereInput
  }

  /**
   * FutsalImage without action
   */
  export type FutsalImageDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FutsalImage
     */
    select?: FutsalImageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FutsalImageInclude<ExtArgs> | null
  }


  /**
   * Model PriceLists
   */

  export type AggregatePriceLists = {
    _count: PriceListsCountAggregateOutputType | null
    _avg: PriceListsAvgAggregateOutputType | null
    _sum: PriceListsSumAggregateOutputType | null
    _min: PriceListsMinAggregateOutputType | null
    _max: PriceListsMaxAggregateOutputType | null
  }

  export type PriceListsAvgAggregateOutputType = {
    id: number | null
    price: number | null
    futsalId: number | null
  }

  export type PriceListsSumAggregateOutputType = {
    id: number | null
    price: number | null
    futsalId: number | null
  }

  export type PriceListsMinAggregateOutputType = {
    id: number | null
    startTime: Date | null
    endTime: Date | null
    dayOfWeek: string | null
    price: number | null
    futsalId: number | null
  }

  export type PriceListsMaxAggregateOutputType = {
    id: number | null
    startTime: Date | null
    endTime: Date | null
    dayOfWeek: string | null
    price: number | null
    futsalId: number | null
  }

  export type PriceListsCountAggregateOutputType = {
    id: number
    startTime: number
    endTime: number
    dayOfWeek: number
    price: number
    futsalId: number
    _all: number
  }


  export type PriceListsAvgAggregateInputType = {
    id?: true
    price?: true
    futsalId?: true
  }

  export type PriceListsSumAggregateInputType = {
    id?: true
    price?: true
    futsalId?: true
  }

  export type PriceListsMinAggregateInputType = {
    id?: true
    startTime?: true
    endTime?: true
    dayOfWeek?: true
    price?: true
    futsalId?: true
  }

  export type PriceListsMaxAggregateInputType = {
    id?: true
    startTime?: true
    endTime?: true
    dayOfWeek?: true
    price?: true
    futsalId?: true
  }

  export type PriceListsCountAggregateInputType = {
    id?: true
    startTime?: true
    endTime?: true
    dayOfWeek?: true
    price?: true
    futsalId?: true
    _all?: true
  }

  export type PriceListsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PriceLists to aggregate.
     */
    where?: PriceListsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PriceLists to fetch.
     */
    orderBy?: PriceListsOrderByWithRelationInput | PriceListsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PriceListsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PriceLists from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PriceLists.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned PriceLists
    **/
    _count?: true | PriceListsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PriceListsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PriceListsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PriceListsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PriceListsMaxAggregateInputType
  }

  export type GetPriceListsAggregateType<T extends PriceListsAggregateArgs> = {
        [P in keyof T & keyof AggregatePriceLists]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePriceLists[P]>
      : GetScalarType<T[P], AggregatePriceLists[P]>
  }




  export type PriceListsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PriceListsWhereInput
    orderBy?: PriceListsOrderByWithAggregationInput | PriceListsOrderByWithAggregationInput[]
    by: PriceListsScalarFieldEnum[] | PriceListsScalarFieldEnum
    having?: PriceListsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PriceListsCountAggregateInputType | true
    _avg?: PriceListsAvgAggregateInputType
    _sum?: PriceListsSumAggregateInputType
    _min?: PriceListsMinAggregateInputType
    _max?: PriceListsMaxAggregateInputType
  }

  export type PriceListsGroupByOutputType = {
    id: number
    startTime: Date
    endTime: Date
    dayOfWeek: string
    price: number
    futsalId: number
    _count: PriceListsCountAggregateOutputType | null
    _avg: PriceListsAvgAggregateOutputType | null
    _sum: PriceListsSumAggregateOutputType | null
    _min: PriceListsMinAggregateOutputType | null
    _max: PriceListsMaxAggregateOutputType | null
  }

  type GetPriceListsGroupByPayload<T extends PriceListsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PriceListsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PriceListsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PriceListsGroupByOutputType[P]>
            : GetScalarType<T[P], PriceListsGroupByOutputType[P]>
        }
      >
    >


  export type PriceListsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    startTime?: boolean
    endTime?: boolean
    dayOfWeek?: boolean
    price?: boolean
    futsalId?: boolean
    futsals?: boolean | FutsalsDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["priceLists"]>

  export type PriceListsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    startTime?: boolean
    endTime?: boolean
    dayOfWeek?: boolean
    price?: boolean
    futsalId?: boolean
    futsals?: boolean | FutsalsDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["priceLists"]>

  export type PriceListsSelectScalar = {
    id?: boolean
    startTime?: boolean
    endTime?: boolean
    dayOfWeek?: boolean
    price?: boolean
    futsalId?: boolean
  }

  export type PriceListsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    futsals?: boolean | FutsalsDefaultArgs<ExtArgs>
  }
  export type PriceListsIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    futsals?: boolean | FutsalsDefaultArgs<ExtArgs>
  }

  export type $PriceListsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "PriceLists"
    objects: {
      futsals: Prisma.$FutsalsPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      startTime: Date
      endTime: Date
      dayOfWeek: string
      price: number
      futsalId: number
    }, ExtArgs["result"]["priceLists"]>
    composites: {}
  }

  type PriceListsGetPayload<S extends boolean | null | undefined | PriceListsDefaultArgs> = $Result.GetResult<Prisma.$PriceListsPayload, S>

  type PriceListsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<PriceListsFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: PriceListsCountAggregateInputType | true
    }

  export interface PriceListsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['PriceLists'], meta: { name: 'PriceLists' } }
    /**
     * Find zero or one PriceLists that matches the filter.
     * @param {PriceListsFindUniqueArgs} args - Arguments to find a PriceLists
     * @example
     * // Get one PriceLists
     * const priceLists = await prisma.priceLists.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PriceListsFindUniqueArgs>(args: SelectSubset<T, PriceListsFindUniqueArgs<ExtArgs>>): Prisma__PriceListsClient<$Result.GetResult<Prisma.$PriceListsPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one PriceLists that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {PriceListsFindUniqueOrThrowArgs} args - Arguments to find a PriceLists
     * @example
     * // Get one PriceLists
     * const priceLists = await prisma.priceLists.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PriceListsFindUniqueOrThrowArgs>(args: SelectSubset<T, PriceListsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PriceListsClient<$Result.GetResult<Prisma.$PriceListsPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first PriceLists that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PriceListsFindFirstArgs} args - Arguments to find a PriceLists
     * @example
     * // Get one PriceLists
     * const priceLists = await prisma.priceLists.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PriceListsFindFirstArgs>(args?: SelectSubset<T, PriceListsFindFirstArgs<ExtArgs>>): Prisma__PriceListsClient<$Result.GetResult<Prisma.$PriceListsPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first PriceLists that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PriceListsFindFirstOrThrowArgs} args - Arguments to find a PriceLists
     * @example
     * // Get one PriceLists
     * const priceLists = await prisma.priceLists.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PriceListsFindFirstOrThrowArgs>(args?: SelectSubset<T, PriceListsFindFirstOrThrowArgs<ExtArgs>>): Prisma__PriceListsClient<$Result.GetResult<Prisma.$PriceListsPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more PriceLists that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PriceListsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all PriceLists
     * const priceLists = await prisma.priceLists.findMany()
     * 
     * // Get first 10 PriceLists
     * const priceLists = await prisma.priceLists.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const priceListsWithIdOnly = await prisma.priceLists.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PriceListsFindManyArgs>(args?: SelectSubset<T, PriceListsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PriceListsPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a PriceLists.
     * @param {PriceListsCreateArgs} args - Arguments to create a PriceLists.
     * @example
     * // Create one PriceLists
     * const PriceLists = await prisma.priceLists.create({
     *   data: {
     *     // ... data to create a PriceLists
     *   }
     * })
     * 
     */
    create<T extends PriceListsCreateArgs>(args: SelectSubset<T, PriceListsCreateArgs<ExtArgs>>): Prisma__PriceListsClient<$Result.GetResult<Prisma.$PriceListsPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many PriceLists.
     * @param {PriceListsCreateManyArgs} args - Arguments to create many PriceLists.
     * @example
     * // Create many PriceLists
     * const priceLists = await prisma.priceLists.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PriceListsCreateManyArgs>(args?: SelectSubset<T, PriceListsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many PriceLists and returns the data saved in the database.
     * @param {PriceListsCreateManyAndReturnArgs} args - Arguments to create many PriceLists.
     * @example
     * // Create many PriceLists
     * const priceLists = await prisma.priceLists.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many PriceLists and only return the `id`
     * const priceListsWithIdOnly = await prisma.priceLists.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PriceListsCreateManyAndReturnArgs>(args?: SelectSubset<T, PriceListsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PriceListsPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a PriceLists.
     * @param {PriceListsDeleteArgs} args - Arguments to delete one PriceLists.
     * @example
     * // Delete one PriceLists
     * const PriceLists = await prisma.priceLists.delete({
     *   where: {
     *     // ... filter to delete one PriceLists
     *   }
     * })
     * 
     */
    delete<T extends PriceListsDeleteArgs>(args: SelectSubset<T, PriceListsDeleteArgs<ExtArgs>>): Prisma__PriceListsClient<$Result.GetResult<Prisma.$PriceListsPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one PriceLists.
     * @param {PriceListsUpdateArgs} args - Arguments to update one PriceLists.
     * @example
     * // Update one PriceLists
     * const priceLists = await prisma.priceLists.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PriceListsUpdateArgs>(args: SelectSubset<T, PriceListsUpdateArgs<ExtArgs>>): Prisma__PriceListsClient<$Result.GetResult<Prisma.$PriceListsPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more PriceLists.
     * @param {PriceListsDeleteManyArgs} args - Arguments to filter PriceLists to delete.
     * @example
     * // Delete a few PriceLists
     * const { count } = await prisma.priceLists.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PriceListsDeleteManyArgs>(args?: SelectSubset<T, PriceListsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PriceLists.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PriceListsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many PriceLists
     * const priceLists = await prisma.priceLists.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PriceListsUpdateManyArgs>(args: SelectSubset<T, PriceListsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one PriceLists.
     * @param {PriceListsUpsertArgs} args - Arguments to update or create a PriceLists.
     * @example
     * // Update or create a PriceLists
     * const priceLists = await prisma.priceLists.upsert({
     *   create: {
     *     // ... data to create a PriceLists
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the PriceLists we want to update
     *   }
     * })
     */
    upsert<T extends PriceListsUpsertArgs>(args: SelectSubset<T, PriceListsUpsertArgs<ExtArgs>>): Prisma__PriceListsClient<$Result.GetResult<Prisma.$PriceListsPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of PriceLists.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PriceListsCountArgs} args - Arguments to filter PriceLists to count.
     * @example
     * // Count the number of PriceLists
     * const count = await prisma.priceLists.count({
     *   where: {
     *     // ... the filter for the PriceLists we want to count
     *   }
     * })
    **/
    count<T extends PriceListsCountArgs>(
      args?: Subset<T, PriceListsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PriceListsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a PriceLists.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PriceListsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PriceListsAggregateArgs>(args: Subset<T, PriceListsAggregateArgs>): Prisma.PrismaPromise<GetPriceListsAggregateType<T>>

    /**
     * Group by PriceLists.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PriceListsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PriceListsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PriceListsGroupByArgs['orderBy'] }
        : { orderBy?: PriceListsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PriceListsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPriceListsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the PriceLists model
   */
  readonly fields: PriceListsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for PriceLists.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PriceListsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    futsals<T extends FutsalsDefaultArgs<ExtArgs> = {}>(args?: Subset<T, FutsalsDefaultArgs<ExtArgs>>): Prisma__FutsalsClient<$Result.GetResult<Prisma.$FutsalsPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the PriceLists model
   */ 
  interface PriceListsFieldRefs {
    readonly id: FieldRef<"PriceLists", 'Int'>
    readonly startTime: FieldRef<"PriceLists", 'DateTime'>
    readonly endTime: FieldRef<"PriceLists", 'DateTime'>
    readonly dayOfWeek: FieldRef<"PriceLists", 'String'>
    readonly price: FieldRef<"PriceLists", 'Int'>
    readonly futsalId: FieldRef<"PriceLists", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * PriceLists findUnique
   */
  export type PriceListsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PriceLists
     */
    select?: PriceListsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PriceListsInclude<ExtArgs> | null
    /**
     * Filter, which PriceLists to fetch.
     */
    where: PriceListsWhereUniqueInput
  }

  /**
   * PriceLists findUniqueOrThrow
   */
  export type PriceListsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PriceLists
     */
    select?: PriceListsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PriceListsInclude<ExtArgs> | null
    /**
     * Filter, which PriceLists to fetch.
     */
    where: PriceListsWhereUniqueInput
  }

  /**
   * PriceLists findFirst
   */
  export type PriceListsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PriceLists
     */
    select?: PriceListsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PriceListsInclude<ExtArgs> | null
    /**
     * Filter, which PriceLists to fetch.
     */
    where?: PriceListsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PriceLists to fetch.
     */
    orderBy?: PriceListsOrderByWithRelationInput | PriceListsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PriceLists.
     */
    cursor?: PriceListsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PriceLists from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PriceLists.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PriceLists.
     */
    distinct?: PriceListsScalarFieldEnum | PriceListsScalarFieldEnum[]
  }

  /**
   * PriceLists findFirstOrThrow
   */
  export type PriceListsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PriceLists
     */
    select?: PriceListsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PriceListsInclude<ExtArgs> | null
    /**
     * Filter, which PriceLists to fetch.
     */
    where?: PriceListsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PriceLists to fetch.
     */
    orderBy?: PriceListsOrderByWithRelationInput | PriceListsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PriceLists.
     */
    cursor?: PriceListsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PriceLists from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PriceLists.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PriceLists.
     */
    distinct?: PriceListsScalarFieldEnum | PriceListsScalarFieldEnum[]
  }

  /**
   * PriceLists findMany
   */
  export type PriceListsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PriceLists
     */
    select?: PriceListsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PriceListsInclude<ExtArgs> | null
    /**
     * Filter, which PriceLists to fetch.
     */
    where?: PriceListsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PriceLists to fetch.
     */
    orderBy?: PriceListsOrderByWithRelationInput | PriceListsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing PriceLists.
     */
    cursor?: PriceListsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PriceLists from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PriceLists.
     */
    skip?: number
    distinct?: PriceListsScalarFieldEnum | PriceListsScalarFieldEnum[]
  }

  /**
   * PriceLists create
   */
  export type PriceListsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PriceLists
     */
    select?: PriceListsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PriceListsInclude<ExtArgs> | null
    /**
     * The data needed to create a PriceLists.
     */
    data: XOR<PriceListsCreateInput, PriceListsUncheckedCreateInput>
  }

  /**
   * PriceLists createMany
   */
  export type PriceListsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many PriceLists.
     */
    data: PriceListsCreateManyInput | PriceListsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * PriceLists createManyAndReturn
   */
  export type PriceListsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PriceLists
     */
    select?: PriceListsSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many PriceLists.
     */
    data: PriceListsCreateManyInput | PriceListsCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PriceListsIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * PriceLists update
   */
  export type PriceListsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PriceLists
     */
    select?: PriceListsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PriceListsInclude<ExtArgs> | null
    /**
     * The data needed to update a PriceLists.
     */
    data: XOR<PriceListsUpdateInput, PriceListsUncheckedUpdateInput>
    /**
     * Choose, which PriceLists to update.
     */
    where: PriceListsWhereUniqueInput
  }

  /**
   * PriceLists updateMany
   */
  export type PriceListsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update PriceLists.
     */
    data: XOR<PriceListsUpdateManyMutationInput, PriceListsUncheckedUpdateManyInput>
    /**
     * Filter which PriceLists to update
     */
    where?: PriceListsWhereInput
  }

  /**
   * PriceLists upsert
   */
  export type PriceListsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PriceLists
     */
    select?: PriceListsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PriceListsInclude<ExtArgs> | null
    /**
     * The filter to search for the PriceLists to update in case it exists.
     */
    where: PriceListsWhereUniqueInput
    /**
     * In case the PriceLists found by the `where` argument doesn't exist, create a new PriceLists with this data.
     */
    create: XOR<PriceListsCreateInput, PriceListsUncheckedCreateInput>
    /**
     * In case the PriceLists was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PriceListsUpdateInput, PriceListsUncheckedUpdateInput>
  }

  /**
   * PriceLists delete
   */
  export type PriceListsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PriceLists
     */
    select?: PriceListsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PriceListsInclude<ExtArgs> | null
    /**
     * Filter which PriceLists to delete.
     */
    where: PriceListsWhereUniqueInput
  }

  /**
   * PriceLists deleteMany
   */
  export type PriceListsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PriceLists to delete
     */
    where?: PriceListsWhereInput
  }

  /**
   * PriceLists without action
   */
  export type PriceListsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PriceLists
     */
    select?: PriceListsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PriceListsInclude<ExtArgs> | null
  }


  /**
   * Model Bookings
   */

  export type AggregateBookings = {
    _count: BookingsCountAggregateOutputType | null
    _avg: BookingsAvgAggregateOutputType | null
    _sum: BookingsSumAggregateOutputType | null
    _min: BookingsMinAggregateOutputType | null
    _max: BookingsMaxAggregateOutputType | null
  }

  export type BookingsAvgAggregateOutputType = {
    id: number | null
    userId: number | null
    futsalId: number | null
    price: number | null
  }

  export type BookingsSumAggregateOutputType = {
    id: number | null
    userId: number | null
    futsalId: number | null
    price: number | null
  }

  export type BookingsMinAggregateOutputType = {
    id: number | null
    userId: number | null
    futsalId: number | null
    bookDate: Date | null
    startTime: Date | null
    endTime: Date | null
    type: $Enums.FutsalType | null
    price: number | null
    confirmation: $Enums.BookingStatus | null
    paymentStatus: $Enums.Payment | null
  }

  export type BookingsMaxAggregateOutputType = {
    id: number | null
    userId: number | null
    futsalId: number | null
    bookDate: Date | null
    startTime: Date | null
    endTime: Date | null
    type: $Enums.FutsalType | null
    price: number | null
    confirmation: $Enums.BookingStatus | null
    paymentStatus: $Enums.Payment | null
  }

  export type BookingsCountAggregateOutputType = {
    id: number
    userId: number
    futsalId: number
    bookDate: number
    startTime: number
    endTime: number
    type: number
    price: number
    confirmation: number
    paymentStatus: number
    _all: number
  }


  export type BookingsAvgAggregateInputType = {
    id?: true
    userId?: true
    futsalId?: true
    price?: true
  }

  export type BookingsSumAggregateInputType = {
    id?: true
    userId?: true
    futsalId?: true
    price?: true
  }

  export type BookingsMinAggregateInputType = {
    id?: true
    userId?: true
    futsalId?: true
    bookDate?: true
    startTime?: true
    endTime?: true
    type?: true
    price?: true
    confirmation?: true
    paymentStatus?: true
  }

  export type BookingsMaxAggregateInputType = {
    id?: true
    userId?: true
    futsalId?: true
    bookDate?: true
    startTime?: true
    endTime?: true
    type?: true
    price?: true
    confirmation?: true
    paymentStatus?: true
  }

  export type BookingsCountAggregateInputType = {
    id?: true
    userId?: true
    futsalId?: true
    bookDate?: true
    startTime?: true
    endTime?: true
    type?: true
    price?: true
    confirmation?: true
    paymentStatus?: true
    _all?: true
  }

  export type BookingsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Bookings to aggregate.
     */
    where?: BookingsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Bookings to fetch.
     */
    orderBy?: BookingsOrderByWithRelationInput | BookingsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: BookingsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Bookings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Bookings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Bookings
    **/
    _count?: true | BookingsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: BookingsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: BookingsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: BookingsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: BookingsMaxAggregateInputType
  }

  export type GetBookingsAggregateType<T extends BookingsAggregateArgs> = {
        [P in keyof T & keyof AggregateBookings]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateBookings[P]>
      : GetScalarType<T[P], AggregateBookings[P]>
  }




  export type BookingsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BookingsWhereInput
    orderBy?: BookingsOrderByWithAggregationInput | BookingsOrderByWithAggregationInput[]
    by: BookingsScalarFieldEnum[] | BookingsScalarFieldEnum
    having?: BookingsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: BookingsCountAggregateInputType | true
    _avg?: BookingsAvgAggregateInputType
    _sum?: BookingsSumAggregateInputType
    _min?: BookingsMinAggregateInputType
    _max?: BookingsMaxAggregateInputType
  }

  export type BookingsGroupByOutputType = {
    id: number
    userId: number
    futsalId: number
    bookDate: Date
    startTime: Date
    endTime: Date
    type: $Enums.FutsalType
    price: number
    confirmation: $Enums.BookingStatus
    paymentStatus: $Enums.Payment
    _count: BookingsCountAggregateOutputType | null
    _avg: BookingsAvgAggregateOutputType | null
    _sum: BookingsSumAggregateOutputType | null
    _min: BookingsMinAggregateOutputType | null
    _max: BookingsMaxAggregateOutputType | null
  }

  type GetBookingsGroupByPayload<T extends BookingsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<BookingsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof BookingsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], BookingsGroupByOutputType[P]>
            : GetScalarType<T[P], BookingsGroupByOutputType[P]>
        }
      >
    >


  export type BookingsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    futsalId?: boolean
    bookDate?: boolean
    startTime?: boolean
    endTime?: boolean
    type?: boolean
    price?: boolean
    confirmation?: boolean
    paymentStatus?: boolean
    users?: boolean | UsersDefaultArgs<ExtArgs>
    futsals?: boolean | FutsalsDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["bookings"]>

  export type BookingsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    futsalId?: boolean
    bookDate?: boolean
    startTime?: boolean
    endTime?: boolean
    type?: boolean
    price?: boolean
    confirmation?: boolean
    paymentStatus?: boolean
    users?: boolean | UsersDefaultArgs<ExtArgs>
    futsals?: boolean | FutsalsDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["bookings"]>

  export type BookingsSelectScalar = {
    id?: boolean
    userId?: boolean
    futsalId?: boolean
    bookDate?: boolean
    startTime?: boolean
    endTime?: boolean
    type?: boolean
    price?: boolean
    confirmation?: boolean
    paymentStatus?: boolean
  }

  export type BookingsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    users?: boolean | UsersDefaultArgs<ExtArgs>
    futsals?: boolean | FutsalsDefaultArgs<ExtArgs>
  }
  export type BookingsIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    users?: boolean | UsersDefaultArgs<ExtArgs>
    futsals?: boolean | FutsalsDefaultArgs<ExtArgs>
  }

  export type $BookingsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Bookings"
    objects: {
      users: Prisma.$UsersPayload<ExtArgs>
      futsals: Prisma.$FutsalsPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      userId: number
      futsalId: number
      bookDate: Date
      startTime: Date
      endTime: Date
      type: $Enums.FutsalType
      price: number
      confirmation: $Enums.BookingStatus
      paymentStatus: $Enums.Payment
    }, ExtArgs["result"]["bookings"]>
    composites: {}
  }

  type BookingsGetPayload<S extends boolean | null | undefined | BookingsDefaultArgs> = $Result.GetResult<Prisma.$BookingsPayload, S>

  type BookingsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<BookingsFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: BookingsCountAggregateInputType | true
    }

  export interface BookingsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Bookings'], meta: { name: 'Bookings' } }
    /**
     * Find zero or one Bookings that matches the filter.
     * @param {BookingsFindUniqueArgs} args - Arguments to find a Bookings
     * @example
     * // Get one Bookings
     * const bookings = await prisma.bookings.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends BookingsFindUniqueArgs>(args: SelectSubset<T, BookingsFindUniqueArgs<ExtArgs>>): Prisma__BookingsClient<$Result.GetResult<Prisma.$BookingsPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Bookings that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {BookingsFindUniqueOrThrowArgs} args - Arguments to find a Bookings
     * @example
     * // Get one Bookings
     * const bookings = await prisma.bookings.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends BookingsFindUniqueOrThrowArgs>(args: SelectSubset<T, BookingsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__BookingsClient<$Result.GetResult<Prisma.$BookingsPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Bookings that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BookingsFindFirstArgs} args - Arguments to find a Bookings
     * @example
     * // Get one Bookings
     * const bookings = await prisma.bookings.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends BookingsFindFirstArgs>(args?: SelectSubset<T, BookingsFindFirstArgs<ExtArgs>>): Prisma__BookingsClient<$Result.GetResult<Prisma.$BookingsPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Bookings that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BookingsFindFirstOrThrowArgs} args - Arguments to find a Bookings
     * @example
     * // Get one Bookings
     * const bookings = await prisma.bookings.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends BookingsFindFirstOrThrowArgs>(args?: SelectSubset<T, BookingsFindFirstOrThrowArgs<ExtArgs>>): Prisma__BookingsClient<$Result.GetResult<Prisma.$BookingsPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Bookings that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BookingsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Bookings
     * const bookings = await prisma.bookings.findMany()
     * 
     * // Get first 10 Bookings
     * const bookings = await prisma.bookings.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const bookingsWithIdOnly = await prisma.bookings.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends BookingsFindManyArgs>(args?: SelectSubset<T, BookingsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BookingsPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Bookings.
     * @param {BookingsCreateArgs} args - Arguments to create a Bookings.
     * @example
     * // Create one Bookings
     * const Bookings = await prisma.bookings.create({
     *   data: {
     *     // ... data to create a Bookings
     *   }
     * })
     * 
     */
    create<T extends BookingsCreateArgs>(args: SelectSubset<T, BookingsCreateArgs<ExtArgs>>): Prisma__BookingsClient<$Result.GetResult<Prisma.$BookingsPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Bookings.
     * @param {BookingsCreateManyArgs} args - Arguments to create many Bookings.
     * @example
     * // Create many Bookings
     * const bookings = await prisma.bookings.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends BookingsCreateManyArgs>(args?: SelectSubset<T, BookingsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Bookings and returns the data saved in the database.
     * @param {BookingsCreateManyAndReturnArgs} args - Arguments to create many Bookings.
     * @example
     * // Create many Bookings
     * const bookings = await prisma.bookings.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Bookings and only return the `id`
     * const bookingsWithIdOnly = await prisma.bookings.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends BookingsCreateManyAndReturnArgs>(args?: SelectSubset<T, BookingsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BookingsPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Bookings.
     * @param {BookingsDeleteArgs} args - Arguments to delete one Bookings.
     * @example
     * // Delete one Bookings
     * const Bookings = await prisma.bookings.delete({
     *   where: {
     *     // ... filter to delete one Bookings
     *   }
     * })
     * 
     */
    delete<T extends BookingsDeleteArgs>(args: SelectSubset<T, BookingsDeleteArgs<ExtArgs>>): Prisma__BookingsClient<$Result.GetResult<Prisma.$BookingsPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Bookings.
     * @param {BookingsUpdateArgs} args - Arguments to update one Bookings.
     * @example
     * // Update one Bookings
     * const bookings = await prisma.bookings.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends BookingsUpdateArgs>(args: SelectSubset<T, BookingsUpdateArgs<ExtArgs>>): Prisma__BookingsClient<$Result.GetResult<Prisma.$BookingsPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Bookings.
     * @param {BookingsDeleteManyArgs} args - Arguments to filter Bookings to delete.
     * @example
     * // Delete a few Bookings
     * const { count } = await prisma.bookings.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends BookingsDeleteManyArgs>(args?: SelectSubset<T, BookingsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Bookings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BookingsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Bookings
     * const bookings = await prisma.bookings.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends BookingsUpdateManyArgs>(args: SelectSubset<T, BookingsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Bookings.
     * @param {BookingsUpsertArgs} args - Arguments to update or create a Bookings.
     * @example
     * // Update or create a Bookings
     * const bookings = await prisma.bookings.upsert({
     *   create: {
     *     // ... data to create a Bookings
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Bookings we want to update
     *   }
     * })
     */
    upsert<T extends BookingsUpsertArgs>(args: SelectSubset<T, BookingsUpsertArgs<ExtArgs>>): Prisma__BookingsClient<$Result.GetResult<Prisma.$BookingsPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Bookings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BookingsCountArgs} args - Arguments to filter Bookings to count.
     * @example
     * // Count the number of Bookings
     * const count = await prisma.bookings.count({
     *   where: {
     *     // ... the filter for the Bookings we want to count
     *   }
     * })
    **/
    count<T extends BookingsCountArgs>(
      args?: Subset<T, BookingsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], BookingsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Bookings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BookingsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends BookingsAggregateArgs>(args: Subset<T, BookingsAggregateArgs>): Prisma.PrismaPromise<GetBookingsAggregateType<T>>

    /**
     * Group by Bookings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BookingsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends BookingsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: BookingsGroupByArgs['orderBy'] }
        : { orderBy?: BookingsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, BookingsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetBookingsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Bookings model
   */
  readonly fields: BookingsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Bookings.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__BookingsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    users<T extends UsersDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UsersDefaultArgs<ExtArgs>>): Prisma__UsersClient<$Result.GetResult<Prisma.$UsersPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    futsals<T extends FutsalsDefaultArgs<ExtArgs> = {}>(args?: Subset<T, FutsalsDefaultArgs<ExtArgs>>): Prisma__FutsalsClient<$Result.GetResult<Prisma.$FutsalsPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Bookings model
   */ 
  interface BookingsFieldRefs {
    readonly id: FieldRef<"Bookings", 'Int'>
    readonly userId: FieldRef<"Bookings", 'Int'>
    readonly futsalId: FieldRef<"Bookings", 'Int'>
    readonly bookDate: FieldRef<"Bookings", 'DateTime'>
    readonly startTime: FieldRef<"Bookings", 'DateTime'>
    readonly endTime: FieldRef<"Bookings", 'DateTime'>
    readonly type: FieldRef<"Bookings", 'FutsalType'>
    readonly price: FieldRef<"Bookings", 'Int'>
    readonly confirmation: FieldRef<"Bookings", 'BookingStatus'>
    readonly paymentStatus: FieldRef<"Bookings", 'Payment'>
  }
    

  // Custom InputTypes
  /**
   * Bookings findUnique
   */
  export type BookingsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Bookings
     */
    select?: BookingsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookingsInclude<ExtArgs> | null
    /**
     * Filter, which Bookings to fetch.
     */
    where: BookingsWhereUniqueInput
  }

  /**
   * Bookings findUniqueOrThrow
   */
  export type BookingsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Bookings
     */
    select?: BookingsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookingsInclude<ExtArgs> | null
    /**
     * Filter, which Bookings to fetch.
     */
    where: BookingsWhereUniqueInput
  }

  /**
   * Bookings findFirst
   */
  export type BookingsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Bookings
     */
    select?: BookingsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookingsInclude<ExtArgs> | null
    /**
     * Filter, which Bookings to fetch.
     */
    where?: BookingsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Bookings to fetch.
     */
    orderBy?: BookingsOrderByWithRelationInput | BookingsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Bookings.
     */
    cursor?: BookingsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Bookings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Bookings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Bookings.
     */
    distinct?: BookingsScalarFieldEnum | BookingsScalarFieldEnum[]
  }

  /**
   * Bookings findFirstOrThrow
   */
  export type BookingsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Bookings
     */
    select?: BookingsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookingsInclude<ExtArgs> | null
    /**
     * Filter, which Bookings to fetch.
     */
    where?: BookingsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Bookings to fetch.
     */
    orderBy?: BookingsOrderByWithRelationInput | BookingsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Bookings.
     */
    cursor?: BookingsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Bookings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Bookings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Bookings.
     */
    distinct?: BookingsScalarFieldEnum | BookingsScalarFieldEnum[]
  }

  /**
   * Bookings findMany
   */
  export type BookingsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Bookings
     */
    select?: BookingsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookingsInclude<ExtArgs> | null
    /**
     * Filter, which Bookings to fetch.
     */
    where?: BookingsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Bookings to fetch.
     */
    orderBy?: BookingsOrderByWithRelationInput | BookingsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Bookings.
     */
    cursor?: BookingsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Bookings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Bookings.
     */
    skip?: number
    distinct?: BookingsScalarFieldEnum | BookingsScalarFieldEnum[]
  }

  /**
   * Bookings create
   */
  export type BookingsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Bookings
     */
    select?: BookingsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookingsInclude<ExtArgs> | null
    /**
     * The data needed to create a Bookings.
     */
    data: XOR<BookingsCreateInput, BookingsUncheckedCreateInput>
  }

  /**
   * Bookings createMany
   */
  export type BookingsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Bookings.
     */
    data: BookingsCreateManyInput | BookingsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Bookings createManyAndReturn
   */
  export type BookingsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Bookings
     */
    select?: BookingsSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Bookings.
     */
    data: BookingsCreateManyInput | BookingsCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookingsIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Bookings update
   */
  export type BookingsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Bookings
     */
    select?: BookingsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookingsInclude<ExtArgs> | null
    /**
     * The data needed to update a Bookings.
     */
    data: XOR<BookingsUpdateInput, BookingsUncheckedUpdateInput>
    /**
     * Choose, which Bookings to update.
     */
    where: BookingsWhereUniqueInput
  }

  /**
   * Bookings updateMany
   */
  export type BookingsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Bookings.
     */
    data: XOR<BookingsUpdateManyMutationInput, BookingsUncheckedUpdateManyInput>
    /**
     * Filter which Bookings to update
     */
    where?: BookingsWhereInput
  }

  /**
   * Bookings upsert
   */
  export type BookingsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Bookings
     */
    select?: BookingsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookingsInclude<ExtArgs> | null
    /**
     * The filter to search for the Bookings to update in case it exists.
     */
    where: BookingsWhereUniqueInput
    /**
     * In case the Bookings found by the `where` argument doesn't exist, create a new Bookings with this data.
     */
    create: XOR<BookingsCreateInput, BookingsUncheckedCreateInput>
    /**
     * In case the Bookings was found with the provided `where` argument, update it with this data.
     */
    update: XOR<BookingsUpdateInput, BookingsUncheckedUpdateInput>
  }

  /**
   * Bookings delete
   */
  export type BookingsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Bookings
     */
    select?: BookingsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookingsInclude<ExtArgs> | null
    /**
     * Filter which Bookings to delete.
     */
    where: BookingsWhereUniqueInput
  }

  /**
   * Bookings deleteMany
   */
  export type BookingsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Bookings to delete
     */
    where?: BookingsWhereInput
  }

  /**
   * Bookings without action
   */
  export type BookingsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Bookings
     */
    select?: BookingsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookingsInclude<ExtArgs> | null
  }


  /**
   * Model TimeSlots
   */

  export type AggregateTimeSlots = {
    _count: TimeSlotsCountAggregateOutputType | null
    _avg: TimeSlotsAvgAggregateOutputType | null
    _sum: TimeSlotsSumAggregateOutputType | null
    _min: TimeSlotsMinAggregateOutputType | null
    _max: TimeSlotsMaxAggregateOutputType | null
  }

  export type TimeSlotsAvgAggregateOutputType = {
    id: number | null
    price: number | null
    futsalId: number | null
  }

  export type TimeSlotsSumAggregateOutputType = {
    id: number | null
    price: number | null
    futsalId: number | null
  }

  export type TimeSlotsMinAggregateOutputType = {
    id: number | null
    startTime: Date | null
    endTime: Date | null
    date: Date | null
    price: number | null
    futsalType: $Enums.FutsalType | null
    futsalId: number | null
  }

  export type TimeSlotsMaxAggregateOutputType = {
    id: number | null
    startTime: Date | null
    endTime: Date | null
    date: Date | null
    price: number | null
    futsalType: $Enums.FutsalType | null
    futsalId: number | null
  }

  export type TimeSlotsCountAggregateOutputType = {
    id: number
    startTime: number
    endTime: number
    date: number
    price: number
    futsalType: number
    futsalId: number
    _all: number
  }


  export type TimeSlotsAvgAggregateInputType = {
    id?: true
    price?: true
    futsalId?: true
  }

  export type TimeSlotsSumAggregateInputType = {
    id?: true
    price?: true
    futsalId?: true
  }

  export type TimeSlotsMinAggregateInputType = {
    id?: true
    startTime?: true
    endTime?: true
    date?: true
    price?: true
    futsalType?: true
    futsalId?: true
  }

  export type TimeSlotsMaxAggregateInputType = {
    id?: true
    startTime?: true
    endTime?: true
    date?: true
    price?: true
    futsalType?: true
    futsalId?: true
  }

  export type TimeSlotsCountAggregateInputType = {
    id?: true
    startTime?: true
    endTime?: true
    date?: true
    price?: true
    futsalType?: true
    futsalId?: true
    _all?: true
  }

  export type TimeSlotsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TimeSlots to aggregate.
     */
    where?: TimeSlotsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TimeSlots to fetch.
     */
    orderBy?: TimeSlotsOrderByWithRelationInput | TimeSlotsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TimeSlotsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TimeSlots from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TimeSlots.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned TimeSlots
    **/
    _count?: true | TimeSlotsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: TimeSlotsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: TimeSlotsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TimeSlotsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TimeSlotsMaxAggregateInputType
  }

  export type GetTimeSlotsAggregateType<T extends TimeSlotsAggregateArgs> = {
        [P in keyof T & keyof AggregateTimeSlots]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTimeSlots[P]>
      : GetScalarType<T[P], AggregateTimeSlots[P]>
  }




  export type TimeSlotsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TimeSlotsWhereInput
    orderBy?: TimeSlotsOrderByWithAggregationInput | TimeSlotsOrderByWithAggregationInput[]
    by: TimeSlotsScalarFieldEnum[] | TimeSlotsScalarFieldEnum
    having?: TimeSlotsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TimeSlotsCountAggregateInputType | true
    _avg?: TimeSlotsAvgAggregateInputType
    _sum?: TimeSlotsSumAggregateInputType
    _min?: TimeSlotsMinAggregateInputType
    _max?: TimeSlotsMaxAggregateInputType
  }

  export type TimeSlotsGroupByOutputType = {
    id: number
    startTime: Date
    endTime: Date
    date: Date
    price: number
    futsalType: $Enums.FutsalType
    futsalId: number
    _count: TimeSlotsCountAggregateOutputType | null
    _avg: TimeSlotsAvgAggregateOutputType | null
    _sum: TimeSlotsSumAggregateOutputType | null
    _min: TimeSlotsMinAggregateOutputType | null
    _max: TimeSlotsMaxAggregateOutputType | null
  }

  type GetTimeSlotsGroupByPayload<T extends TimeSlotsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TimeSlotsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TimeSlotsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TimeSlotsGroupByOutputType[P]>
            : GetScalarType<T[P], TimeSlotsGroupByOutputType[P]>
        }
      >
    >


  export type TimeSlotsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    startTime?: boolean
    endTime?: boolean
    date?: boolean
    price?: boolean
    futsalType?: boolean
    futsalId?: boolean
    futsals?: boolean | FutsalsDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["timeSlots"]>

  export type TimeSlotsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    startTime?: boolean
    endTime?: boolean
    date?: boolean
    price?: boolean
    futsalType?: boolean
    futsalId?: boolean
    futsals?: boolean | FutsalsDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["timeSlots"]>

  export type TimeSlotsSelectScalar = {
    id?: boolean
    startTime?: boolean
    endTime?: boolean
    date?: boolean
    price?: boolean
    futsalType?: boolean
    futsalId?: boolean
  }

  export type TimeSlotsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    futsals?: boolean | FutsalsDefaultArgs<ExtArgs>
  }
  export type TimeSlotsIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    futsals?: boolean | FutsalsDefaultArgs<ExtArgs>
  }

  export type $TimeSlotsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "TimeSlots"
    objects: {
      futsals: Prisma.$FutsalsPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      startTime: Date
      endTime: Date
      date: Date
      price: number
      futsalType: $Enums.FutsalType
      futsalId: number
    }, ExtArgs["result"]["timeSlots"]>
    composites: {}
  }

  type TimeSlotsGetPayload<S extends boolean | null | undefined | TimeSlotsDefaultArgs> = $Result.GetResult<Prisma.$TimeSlotsPayload, S>

  type TimeSlotsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<TimeSlotsFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: TimeSlotsCountAggregateInputType | true
    }

  export interface TimeSlotsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['TimeSlots'], meta: { name: 'TimeSlots' } }
    /**
     * Find zero or one TimeSlots that matches the filter.
     * @param {TimeSlotsFindUniqueArgs} args - Arguments to find a TimeSlots
     * @example
     * // Get one TimeSlots
     * const timeSlots = await prisma.timeSlots.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TimeSlotsFindUniqueArgs>(args: SelectSubset<T, TimeSlotsFindUniqueArgs<ExtArgs>>): Prisma__TimeSlotsClient<$Result.GetResult<Prisma.$TimeSlotsPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one TimeSlots that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {TimeSlotsFindUniqueOrThrowArgs} args - Arguments to find a TimeSlots
     * @example
     * // Get one TimeSlots
     * const timeSlots = await prisma.timeSlots.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TimeSlotsFindUniqueOrThrowArgs>(args: SelectSubset<T, TimeSlotsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TimeSlotsClient<$Result.GetResult<Prisma.$TimeSlotsPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first TimeSlots that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TimeSlotsFindFirstArgs} args - Arguments to find a TimeSlots
     * @example
     * // Get one TimeSlots
     * const timeSlots = await prisma.timeSlots.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TimeSlotsFindFirstArgs>(args?: SelectSubset<T, TimeSlotsFindFirstArgs<ExtArgs>>): Prisma__TimeSlotsClient<$Result.GetResult<Prisma.$TimeSlotsPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first TimeSlots that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TimeSlotsFindFirstOrThrowArgs} args - Arguments to find a TimeSlots
     * @example
     * // Get one TimeSlots
     * const timeSlots = await prisma.timeSlots.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TimeSlotsFindFirstOrThrowArgs>(args?: SelectSubset<T, TimeSlotsFindFirstOrThrowArgs<ExtArgs>>): Prisma__TimeSlotsClient<$Result.GetResult<Prisma.$TimeSlotsPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more TimeSlots that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TimeSlotsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all TimeSlots
     * const timeSlots = await prisma.timeSlots.findMany()
     * 
     * // Get first 10 TimeSlots
     * const timeSlots = await prisma.timeSlots.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const timeSlotsWithIdOnly = await prisma.timeSlots.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends TimeSlotsFindManyArgs>(args?: SelectSubset<T, TimeSlotsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TimeSlotsPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a TimeSlots.
     * @param {TimeSlotsCreateArgs} args - Arguments to create a TimeSlots.
     * @example
     * // Create one TimeSlots
     * const TimeSlots = await prisma.timeSlots.create({
     *   data: {
     *     // ... data to create a TimeSlots
     *   }
     * })
     * 
     */
    create<T extends TimeSlotsCreateArgs>(args: SelectSubset<T, TimeSlotsCreateArgs<ExtArgs>>): Prisma__TimeSlotsClient<$Result.GetResult<Prisma.$TimeSlotsPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many TimeSlots.
     * @param {TimeSlotsCreateManyArgs} args - Arguments to create many TimeSlots.
     * @example
     * // Create many TimeSlots
     * const timeSlots = await prisma.timeSlots.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TimeSlotsCreateManyArgs>(args?: SelectSubset<T, TimeSlotsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many TimeSlots and returns the data saved in the database.
     * @param {TimeSlotsCreateManyAndReturnArgs} args - Arguments to create many TimeSlots.
     * @example
     * // Create many TimeSlots
     * const timeSlots = await prisma.timeSlots.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many TimeSlots and only return the `id`
     * const timeSlotsWithIdOnly = await prisma.timeSlots.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends TimeSlotsCreateManyAndReturnArgs>(args?: SelectSubset<T, TimeSlotsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TimeSlotsPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a TimeSlots.
     * @param {TimeSlotsDeleteArgs} args - Arguments to delete one TimeSlots.
     * @example
     * // Delete one TimeSlots
     * const TimeSlots = await prisma.timeSlots.delete({
     *   where: {
     *     // ... filter to delete one TimeSlots
     *   }
     * })
     * 
     */
    delete<T extends TimeSlotsDeleteArgs>(args: SelectSubset<T, TimeSlotsDeleteArgs<ExtArgs>>): Prisma__TimeSlotsClient<$Result.GetResult<Prisma.$TimeSlotsPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one TimeSlots.
     * @param {TimeSlotsUpdateArgs} args - Arguments to update one TimeSlots.
     * @example
     * // Update one TimeSlots
     * const timeSlots = await prisma.timeSlots.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TimeSlotsUpdateArgs>(args: SelectSubset<T, TimeSlotsUpdateArgs<ExtArgs>>): Prisma__TimeSlotsClient<$Result.GetResult<Prisma.$TimeSlotsPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more TimeSlots.
     * @param {TimeSlotsDeleteManyArgs} args - Arguments to filter TimeSlots to delete.
     * @example
     * // Delete a few TimeSlots
     * const { count } = await prisma.timeSlots.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TimeSlotsDeleteManyArgs>(args?: SelectSubset<T, TimeSlotsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TimeSlots.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TimeSlotsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many TimeSlots
     * const timeSlots = await prisma.timeSlots.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TimeSlotsUpdateManyArgs>(args: SelectSubset<T, TimeSlotsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one TimeSlots.
     * @param {TimeSlotsUpsertArgs} args - Arguments to update or create a TimeSlots.
     * @example
     * // Update or create a TimeSlots
     * const timeSlots = await prisma.timeSlots.upsert({
     *   create: {
     *     // ... data to create a TimeSlots
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the TimeSlots we want to update
     *   }
     * })
     */
    upsert<T extends TimeSlotsUpsertArgs>(args: SelectSubset<T, TimeSlotsUpsertArgs<ExtArgs>>): Prisma__TimeSlotsClient<$Result.GetResult<Prisma.$TimeSlotsPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of TimeSlots.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TimeSlotsCountArgs} args - Arguments to filter TimeSlots to count.
     * @example
     * // Count the number of TimeSlots
     * const count = await prisma.timeSlots.count({
     *   where: {
     *     // ... the filter for the TimeSlots we want to count
     *   }
     * })
    **/
    count<T extends TimeSlotsCountArgs>(
      args?: Subset<T, TimeSlotsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TimeSlotsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a TimeSlots.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TimeSlotsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TimeSlotsAggregateArgs>(args: Subset<T, TimeSlotsAggregateArgs>): Prisma.PrismaPromise<GetTimeSlotsAggregateType<T>>

    /**
     * Group by TimeSlots.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TimeSlotsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TimeSlotsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TimeSlotsGroupByArgs['orderBy'] }
        : { orderBy?: TimeSlotsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TimeSlotsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTimeSlotsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the TimeSlots model
   */
  readonly fields: TimeSlotsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for TimeSlots.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TimeSlotsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    futsals<T extends FutsalsDefaultArgs<ExtArgs> = {}>(args?: Subset<T, FutsalsDefaultArgs<ExtArgs>>): Prisma__FutsalsClient<$Result.GetResult<Prisma.$FutsalsPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the TimeSlots model
   */ 
  interface TimeSlotsFieldRefs {
    readonly id: FieldRef<"TimeSlots", 'Int'>
    readonly startTime: FieldRef<"TimeSlots", 'DateTime'>
    readonly endTime: FieldRef<"TimeSlots", 'DateTime'>
    readonly date: FieldRef<"TimeSlots", 'DateTime'>
    readonly price: FieldRef<"TimeSlots", 'Int'>
    readonly futsalType: FieldRef<"TimeSlots", 'FutsalType'>
    readonly futsalId: FieldRef<"TimeSlots", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * TimeSlots findUnique
   */
  export type TimeSlotsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TimeSlots
     */
    select?: TimeSlotsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TimeSlotsInclude<ExtArgs> | null
    /**
     * Filter, which TimeSlots to fetch.
     */
    where: TimeSlotsWhereUniqueInput
  }

  /**
   * TimeSlots findUniqueOrThrow
   */
  export type TimeSlotsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TimeSlots
     */
    select?: TimeSlotsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TimeSlotsInclude<ExtArgs> | null
    /**
     * Filter, which TimeSlots to fetch.
     */
    where: TimeSlotsWhereUniqueInput
  }

  /**
   * TimeSlots findFirst
   */
  export type TimeSlotsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TimeSlots
     */
    select?: TimeSlotsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TimeSlotsInclude<ExtArgs> | null
    /**
     * Filter, which TimeSlots to fetch.
     */
    where?: TimeSlotsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TimeSlots to fetch.
     */
    orderBy?: TimeSlotsOrderByWithRelationInput | TimeSlotsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TimeSlots.
     */
    cursor?: TimeSlotsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TimeSlots from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TimeSlots.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TimeSlots.
     */
    distinct?: TimeSlotsScalarFieldEnum | TimeSlotsScalarFieldEnum[]
  }

  /**
   * TimeSlots findFirstOrThrow
   */
  export type TimeSlotsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TimeSlots
     */
    select?: TimeSlotsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TimeSlotsInclude<ExtArgs> | null
    /**
     * Filter, which TimeSlots to fetch.
     */
    where?: TimeSlotsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TimeSlots to fetch.
     */
    orderBy?: TimeSlotsOrderByWithRelationInput | TimeSlotsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TimeSlots.
     */
    cursor?: TimeSlotsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TimeSlots from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TimeSlots.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TimeSlots.
     */
    distinct?: TimeSlotsScalarFieldEnum | TimeSlotsScalarFieldEnum[]
  }

  /**
   * TimeSlots findMany
   */
  export type TimeSlotsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TimeSlots
     */
    select?: TimeSlotsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TimeSlotsInclude<ExtArgs> | null
    /**
     * Filter, which TimeSlots to fetch.
     */
    where?: TimeSlotsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TimeSlots to fetch.
     */
    orderBy?: TimeSlotsOrderByWithRelationInput | TimeSlotsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing TimeSlots.
     */
    cursor?: TimeSlotsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TimeSlots from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TimeSlots.
     */
    skip?: number
    distinct?: TimeSlotsScalarFieldEnum | TimeSlotsScalarFieldEnum[]
  }

  /**
   * TimeSlots create
   */
  export type TimeSlotsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TimeSlots
     */
    select?: TimeSlotsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TimeSlotsInclude<ExtArgs> | null
    /**
     * The data needed to create a TimeSlots.
     */
    data: XOR<TimeSlotsCreateInput, TimeSlotsUncheckedCreateInput>
  }

  /**
   * TimeSlots createMany
   */
  export type TimeSlotsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many TimeSlots.
     */
    data: TimeSlotsCreateManyInput | TimeSlotsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * TimeSlots createManyAndReturn
   */
  export type TimeSlotsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TimeSlots
     */
    select?: TimeSlotsSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many TimeSlots.
     */
    data: TimeSlotsCreateManyInput | TimeSlotsCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TimeSlotsIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * TimeSlots update
   */
  export type TimeSlotsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TimeSlots
     */
    select?: TimeSlotsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TimeSlotsInclude<ExtArgs> | null
    /**
     * The data needed to update a TimeSlots.
     */
    data: XOR<TimeSlotsUpdateInput, TimeSlotsUncheckedUpdateInput>
    /**
     * Choose, which TimeSlots to update.
     */
    where: TimeSlotsWhereUniqueInput
  }

  /**
   * TimeSlots updateMany
   */
  export type TimeSlotsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update TimeSlots.
     */
    data: XOR<TimeSlotsUpdateManyMutationInput, TimeSlotsUncheckedUpdateManyInput>
    /**
     * Filter which TimeSlots to update
     */
    where?: TimeSlotsWhereInput
  }

  /**
   * TimeSlots upsert
   */
  export type TimeSlotsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TimeSlots
     */
    select?: TimeSlotsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TimeSlotsInclude<ExtArgs> | null
    /**
     * The filter to search for the TimeSlots to update in case it exists.
     */
    where: TimeSlotsWhereUniqueInput
    /**
     * In case the TimeSlots found by the `where` argument doesn't exist, create a new TimeSlots with this data.
     */
    create: XOR<TimeSlotsCreateInput, TimeSlotsUncheckedCreateInput>
    /**
     * In case the TimeSlots was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TimeSlotsUpdateInput, TimeSlotsUncheckedUpdateInput>
  }

  /**
   * TimeSlots delete
   */
  export type TimeSlotsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TimeSlots
     */
    select?: TimeSlotsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TimeSlotsInclude<ExtArgs> | null
    /**
     * Filter which TimeSlots to delete.
     */
    where: TimeSlotsWhereUniqueInput
  }

  /**
   * TimeSlots deleteMany
   */
  export type TimeSlotsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TimeSlots to delete
     */
    where?: TimeSlotsWhereInput
  }

  /**
   * TimeSlots without action
   */
  export type TimeSlotsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TimeSlots
     */
    select?: TimeSlotsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TimeSlotsInclude<ExtArgs> | null
  }


  /**
   * Model MatchRequest
   */

  export type AggregateMatchRequest = {
    _count: MatchRequestCountAggregateOutputType | null
    _avg: MatchRequestAvgAggregateOutputType | null
    _sum: MatchRequestSumAggregateOutputType | null
    _min: MatchRequestMinAggregateOutputType | null
    _max: MatchRequestMaxAggregateOutputType | null
  }

  export type MatchRequestAvgAggregateOutputType = {
    id: number | null
    userId: number | null
  }

  export type MatchRequestSumAggregateOutputType = {
    id: number | null
    userId: number | null
  }

  export type MatchRequestMinAggregateOutputType = {
    id: number | null
    userId: number | null
    futsalName: string | null
    futsalType: $Enums.FutsalType | null
    matchDate: Date | null
    startTime: Date | null
    endTime: Date | null
    matchType: string | null
    status: $Enums.RequestStatus | null
  }

  export type MatchRequestMaxAggregateOutputType = {
    id: number | null
    userId: number | null
    futsalName: string | null
    futsalType: $Enums.FutsalType | null
    matchDate: Date | null
    startTime: Date | null
    endTime: Date | null
    matchType: string | null
    status: $Enums.RequestStatus | null
  }

  export type MatchRequestCountAggregateOutputType = {
    id: number
    userId: number
    futsalName: number
    futsalType: number
    matchDate: number
    startTime: number
    endTime: number
    matchType: number
    status: number
    _all: number
  }


  export type MatchRequestAvgAggregateInputType = {
    id?: true
    userId?: true
  }

  export type MatchRequestSumAggregateInputType = {
    id?: true
    userId?: true
  }

  export type MatchRequestMinAggregateInputType = {
    id?: true
    userId?: true
    futsalName?: true
    futsalType?: true
    matchDate?: true
    startTime?: true
    endTime?: true
    matchType?: true
    status?: true
  }

  export type MatchRequestMaxAggregateInputType = {
    id?: true
    userId?: true
    futsalName?: true
    futsalType?: true
    matchDate?: true
    startTime?: true
    endTime?: true
    matchType?: true
    status?: true
  }

  export type MatchRequestCountAggregateInputType = {
    id?: true
    userId?: true
    futsalName?: true
    futsalType?: true
    matchDate?: true
    startTime?: true
    endTime?: true
    matchType?: true
    status?: true
    _all?: true
  }

  export type MatchRequestAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which MatchRequest to aggregate.
     */
    where?: MatchRequestWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MatchRequests to fetch.
     */
    orderBy?: MatchRequestOrderByWithRelationInput | MatchRequestOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: MatchRequestWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MatchRequests from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MatchRequests.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned MatchRequests
    **/
    _count?: true | MatchRequestCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: MatchRequestAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: MatchRequestSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MatchRequestMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MatchRequestMaxAggregateInputType
  }

  export type GetMatchRequestAggregateType<T extends MatchRequestAggregateArgs> = {
        [P in keyof T & keyof AggregateMatchRequest]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMatchRequest[P]>
      : GetScalarType<T[P], AggregateMatchRequest[P]>
  }




  export type MatchRequestGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MatchRequestWhereInput
    orderBy?: MatchRequestOrderByWithAggregationInput | MatchRequestOrderByWithAggregationInput[]
    by: MatchRequestScalarFieldEnum[] | MatchRequestScalarFieldEnum
    having?: MatchRequestScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MatchRequestCountAggregateInputType | true
    _avg?: MatchRequestAvgAggregateInputType
    _sum?: MatchRequestSumAggregateInputType
    _min?: MatchRequestMinAggregateInputType
    _max?: MatchRequestMaxAggregateInputType
  }

  export type MatchRequestGroupByOutputType = {
    id: number
    userId: number
    futsalName: string
    futsalType: $Enums.FutsalType
    matchDate: Date
    startTime: Date
    endTime: Date
    matchType: string
    status: $Enums.RequestStatus
    _count: MatchRequestCountAggregateOutputType | null
    _avg: MatchRequestAvgAggregateOutputType | null
    _sum: MatchRequestSumAggregateOutputType | null
    _min: MatchRequestMinAggregateOutputType | null
    _max: MatchRequestMaxAggregateOutputType | null
  }

  type GetMatchRequestGroupByPayload<T extends MatchRequestGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<MatchRequestGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MatchRequestGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MatchRequestGroupByOutputType[P]>
            : GetScalarType<T[P], MatchRequestGroupByOutputType[P]>
        }
      >
    >


  export type MatchRequestSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    futsalName?: boolean
    futsalType?: boolean
    matchDate?: boolean
    startTime?: boolean
    endTime?: boolean
    matchType?: boolean
    status?: boolean
    users?: boolean | UsersDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["matchRequest"]>

  export type MatchRequestSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    futsalName?: boolean
    futsalType?: boolean
    matchDate?: boolean
    startTime?: boolean
    endTime?: boolean
    matchType?: boolean
    status?: boolean
    users?: boolean | UsersDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["matchRequest"]>

  export type MatchRequestSelectScalar = {
    id?: boolean
    userId?: boolean
    futsalName?: boolean
    futsalType?: boolean
    matchDate?: boolean
    startTime?: boolean
    endTime?: boolean
    matchType?: boolean
    status?: boolean
  }

  export type MatchRequestInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    users?: boolean | UsersDefaultArgs<ExtArgs>
  }
  export type MatchRequestIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    users?: boolean | UsersDefaultArgs<ExtArgs>
  }

  export type $MatchRequestPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "MatchRequest"
    objects: {
      users: Prisma.$UsersPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      userId: number
      futsalName: string
      futsalType: $Enums.FutsalType
      matchDate: Date
      startTime: Date
      endTime: Date
      matchType: string
      status: $Enums.RequestStatus
    }, ExtArgs["result"]["matchRequest"]>
    composites: {}
  }

  type MatchRequestGetPayload<S extends boolean | null | undefined | MatchRequestDefaultArgs> = $Result.GetResult<Prisma.$MatchRequestPayload, S>

  type MatchRequestCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<MatchRequestFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: MatchRequestCountAggregateInputType | true
    }

  export interface MatchRequestDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['MatchRequest'], meta: { name: 'MatchRequest' } }
    /**
     * Find zero or one MatchRequest that matches the filter.
     * @param {MatchRequestFindUniqueArgs} args - Arguments to find a MatchRequest
     * @example
     * // Get one MatchRequest
     * const matchRequest = await prisma.matchRequest.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends MatchRequestFindUniqueArgs>(args: SelectSubset<T, MatchRequestFindUniqueArgs<ExtArgs>>): Prisma__MatchRequestClient<$Result.GetResult<Prisma.$MatchRequestPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one MatchRequest that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {MatchRequestFindUniqueOrThrowArgs} args - Arguments to find a MatchRequest
     * @example
     * // Get one MatchRequest
     * const matchRequest = await prisma.matchRequest.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends MatchRequestFindUniqueOrThrowArgs>(args: SelectSubset<T, MatchRequestFindUniqueOrThrowArgs<ExtArgs>>): Prisma__MatchRequestClient<$Result.GetResult<Prisma.$MatchRequestPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first MatchRequest that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MatchRequestFindFirstArgs} args - Arguments to find a MatchRequest
     * @example
     * // Get one MatchRequest
     * const matchRequest = await prisma.matchRequest.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends MatchRequestFindFirstArgs>(args?: SelectSubset<T, MatchRequestFindFirstArgs<ExtArgs>>): Prisma__MatchRequestClient<$Result.GetResult<Prisma.$MatchRequestPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first MatchRequest that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MatchRequestFindFirstOrThrowArgs} args - Arguments to find a MatchRequest
     * @example
     * // Get one MatchRequest
     * const matchRequest = await prisma.matchRequest.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends MatchRequestFindFirstOrThrowArgs>(args?: SelectSubset<T, MatchRequestFindFirstOrThrowArgs<ExtArgs>>): Prisma__MatchRequestClient<$Result.GetResult<Prisma.$MatchRequestPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more MatchRequests that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MatchRequestFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all MatchRequests
     * const matchRequests = await prisma.matchRequest.findMany()
     * 
     * // Get first 10 MatchRequests
     * const matchRequests = await prisma.matchRequest.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const matchRequestWithIdOnly = await prisma.matchRequest.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends MatchRequestFindManyArgs>(args?: SelectSubset<T, MatchRequestFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MatchRequestPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a MatchRequest.
     * @param {MatchRequestCreateArgs} args - Arguments to create a MatchRequest.
     * @example
     * // Create one MatchRequest
     * const MatchRequest = await prisma.matchRequest.create({
     *   data: {
     *     // ... data to create a MatchRequest
     *   }
     * })
     * 
     */
    create<T extends MatchRequestCreateArgs>(args: SelectSubset<T, MatchRequestCreateArgs<ExtArgs>>): Prisma__MatchRequestClient<$Result.GetResult<Prisma.$MatchRequestPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many MatchRequests.
     * @param {MatchRequestCreateManyArgs} args - Arguments to create many MatchRequests.
     * @example
     * // Create many MatchRequests
     * const matchRequest = await prisma.matchRequest.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends MatchRequestCreateManyArgs>(args?: SelectSubset<T, MatchRequestCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many MatchRequests and returns the data saved in the database.
     * @param {MatchRequestCreateManyAndReturnArgs} args - Arguments to create many MatchRequests.
     * @example
     * // Create many MatchRequests
     * const matchRequest = await prisma.matchRequest.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many MatchRequests and only return the `id`
     * const matchRequestWithIdOnly = await prisma.matchRequest.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends MatchRequestCreateManyAndReturnArgs>(args?: SelectSubset<T, MatchRequestCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MatchRequestPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a MatchRequest.
     * @param {MatchRequestDeleteArgs} args - Arguments to delete one MatchRequest.
     * @example
     * // Delete one MatchRequest
     * const MatchRequest = await prisma.matchRequest.delete({
     *   where: {
     *     // ... filter to delete one MatchRequest
     *   }
     * })
     * 
     */
    delete<T extends MatchRequestDeleteArgs>(args: SelectSubset<T, MatchRequestDeleteArgs<ExtArgs>>): Prisma__MatchRequestClient<$Result.GetResult<Prisma.$MatchRequestPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one MatchRequest.
     * @param {MatchRequestUpdateArgs} args - Arguments to update one MatchRequest.
     * @example
     * // Update one MatchRequest
     * const matchRequest = await prisma.matchRequest.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends MatchRequestUpdateArgs>(args: SelectSubset<T, MatchRequestUpdateArgs<ExtArgs>>): Prisma__MatchRequestClient<$Result.GetResult<Prisma.$MatchRequestPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more MatchRequests.
     * @param {MatchRequestDeleteManyArgs} args - Arguments to filter MatchRequests to delete.
     * @example
     * // Delete a few MatchRequests
     * const { count } = await prisma.matchRequest.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends MatchRequestDeleteManyArgs>(args?: SelectSubset<T, MatchRequestDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more MatchRequests.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MatchRequestUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many MatchRequests
     * const matchRequest = await prisma.matchRequest.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends MatchRequestUpdateManyArgs>(args: SelectSubset<T, MatchRequestUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one MatchRequest.
     * @param {MatchRequestUpsertArgs} args - Arguments to update or create a MatchRequest.
     * @example
     * // Update or create a MatchRequest
     * const matchRequest = await prisma.matchRequest.upsert({
     *   create: {
     *     // ... data to create a MatchRequest
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the MatchRequest we want to update
     *   }
     * })
     */
    upsert<T extends MatchRequestUpsertArgs>(args: SelectSubset<T, MatchRequestUpsertArgs<ExtArgs>>): Prisma__MatchRequestClient<$Result.GetResult<Prisma.$MatchRequestPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of MatchRequests.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MatchRequestCountArgs} args - Arguments to filter MatchRequests to count.
     * @example
     * // Count the number of MatchRequests
     * const count = await prisma.matchRequest.count({
     *   where: {
     *     // ... the filter for the MatchRequests we want to count
     *   }
     * })
    **/
    count<T extends MatchRequestCountArgs>(
      args?: Subset<T, MatchRequestCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MatchRequestCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a MatchRequest.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MatchRequestAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MatchRequestAggregateArgs>(args: Subset<T, MatchRequestAggregateArgs>): Prisma.PrismaPromise<GetMatchRequestAggregateType<T>>

    /**
     * Group by MatchRequest.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MatchRequestGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends MatchRequestGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: MatchRequestGroupByArgs['orderBy'] }
        : { orderBy?: MatchRequestGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, MatchRequestGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMatchRequestGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the MatchRequest model
   */
  readonly fields: MatchRequestFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for MatchRequest.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__MatchRequestClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    users<T extends UsersDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UsersDefaultArgs<ExtArgs>>): Prisma__UsersClient<$Result.GetResult<Prisma.$UsersPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the MatchRequest model
   */ 
  interface MatchRequestFieldRefs {
    readonly id: FieldRef<"MatchRequest", 'Int'>
    readonly userId: FieldRef<"MatchRequest", 'Int'>
    readonly futsalName: FieldRef<"MatchRequest", 'String'>
    readonly futsalType: FieldRef<"MatchRequest", 'FutsalType'>
    readonly matchDate: FieldRef<"MatchRequest", 'DateTime'>
    readonly startTime: FieldRef<"MatchRequest", 'DateTime'>
    readonly endTime: FieldRef<"MatchRequest", 'DateTime'>
    readonly matchType: FieldRef<"MatchRequest", 'String'>
    readonly status: FieldRef<"MatchRequest", 'RequestStatus'>
  }
    

  // Custom InputTypes
  /**
   * MatchRequest findUnique
   */
  export type MatchRequestFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MatchRequest
     */
    select?: MatchRequestSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MatchRequestInclude<ExtArgs> | null
    /**
     * Filter, which MatchRequest to fetch.
     */
    where: MatchRequestWhereUniqueInput
  }

  /**
   * MatchRequest findUniqueOrThrow
   */
  export type MatchRequestFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MatchRequest
     */
    select?: MatchRequestSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MatchRequestInclude<ExtArgs> | null
    /**
     * Filter, which MatchRequest to fetch.
     */
    where: MatchRequestWhereUniqueInput
  }

  /**
   * MatchRequest findFirst
   */
  export type MatchRequestFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MatchRequest
     */
    select?: MatchRequestSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MatchRequestInclude<ExtArgs> | null
    /**
     * Filter, which MatchRequest to fetch.
     */
    where?: MatchRequestWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MatchRequests to fetch.
     */
    orderBy?: MatchRequestOrderByWithRelationInput | MatchRequestOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MatchRequests.
     */
    cursor?: MatchRequestWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MatchRequests from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MatchRequests.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MatchRequests.
     */
    distinct?: MatchRequestScalarFieldEnum | MatchRequestScalarFieldEnum[]
  }

  /**
   * MatchRequest findFirstOrThrow
   */
  export type MatchRequestFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MatchRequest
     */
    select?: MatchRequestSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MatchRequestInclude<ExtArgs> | null
    /**
     * Filter, which MatchRequest to fetch.
     */
    where?: MatchRequestWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MatchRequests to fetch.
     */
    orderBy?: MatchRequestOrderByWithRelationInput | MatchRequestOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MatchRequests.
     */
    cursor?: MatchRequestWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MatchRequests from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MatchRequests.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MatchRequests.
     */
    distinct?: MatchRequestScalarFieldEnum | MatchRequestScalarFieldEnum[]
  }

  /**
   * MatchRequest findMany
   */
  export type MatchRequestFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MatchRequest
     */
    select?: MatchRequestSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MatchRequestInclude<ExtArgs> | null
    /**
     * Filter, which MatchRequests to fetch.
     */
    where?: MatchRequestWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MatchRequests to fetch.
     */
    orderBy?: MatchRequestOrderByWithRelationInput | MatchRequestOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing MatchRequests.
     */
    cursor?: MatchRequestWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MatchRequests from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MatchRequests.
     */
    skip?: number
    distinct?: MatchRequestScalarFieldEnum | MatchRequestScalarFieldEnum[]
  }

  /**
   * MatchRequest create
   */
  export type MatchRequestCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MatchRequest
     */
    select?: MatchRequestSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MatchRequestInclude<ExtArgs> | null
    /**
     * The data needed to create a MatchRequest.
     */
    data: XOR<MatchRequestCreateInput, MatchRequestUncheckedCreateInput>
  }

  /**
   * MatchRequest createMany
   */
  export type MatchRequestCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many MatchRequests.
     */
    data: MatchRequestCreateManyInput | MatchRequestCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * MatchRequest createManyAndReturn
   */
  export type MatchRequestCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MatchRequest
     */
    select?: MatchRequestSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many MatchRequests.
     */
    data: MatchRequestCreateManyInput | MatchRequestCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MatchRequestIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * MatchRequest update
   */
  export type MatchRequestUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MatchRequest
     */
    select?: MatchRequestSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MatchRequestInclude<ExtArgs> | null
    /**
     * The data needed to update a MatchRequest.
     */
    data: XOR<MatchRequestUpdateInput, MatchRequestUncheckedUpdateInput>
    /**
     * Choose, which MatchRequest to update.
     */
    where: MatchRequestWhereUniqueInput
  }

  /**
   * MatchRequest updateMany
   */
  export type MatchRequestUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update MatchRequests.
     */
    data: XOR<MatchRequestUpdateManyMutationInput, MatchRequestUncheckedUpdateManyInput>
    /**
     * Filter which MatchRequests to update
     */
    where?: MatchRequestWhereInput
  }

  /**
   * MatchRequest upsert
   */
  export type MatchRequestUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MatchRequest
     */
    select?: MatchRequestSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MatchRequestInclude<ExtArgs> | null
    /**
     * The filter to search for the MatchRequest to update in case it exists.
     */
    where: MatchRequestWhereUniqueInput
    /**
     * In case the MatchRequest found by the `where` argument doesn't exist, create a new MatchRequest with this data.
     */
    create: XOR<MatchRequestCreateInput, MatchRequestUncheckedCreateInput>
    /**
     * In case the MatchRequest was found with the provided `where` argument, update it with this data.
     */
    update: XOR<MatchRequestUpdateInput, MatchRequestUncheckedUpdateInput>
  }

  /**
   * MatchRequest delete
   */
  export type MatchRequestDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MatchRequest
     */
    select?: MatchRequestSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MatchRequestInclude<ExtArgs> | null
    /**
     * Filter which MatchRequest to delete.
     */
    where: MatchRequestWhereUniqueInput
  }

  /**
   * MatchRequest deleteMany
   */
  export type MatchRequestDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which MatchRequests to delete
     */
    where?: MatchRequestWhereInput
  }

  /**
   * MatchRequest without action
   */
  export type MatchRequestDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MatchRequest
     */
    select?: MatchRequestSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MatchRequestInclude<ExtArgs> | null
  }


  /**
   * Model Matches
   */

  export type AggregateMatches = {
    _count: MatchesCountAggregateOutputType | null
    _avg: MatchesAvgAggregateOutputType | null
    _sum: MatchesSumAggregateOutputType | null
    _min: MatchesMinAggregateOutputType | null
    _max: MatchesMaxAggregateOutputType | null
  }

  export type MatchesAvgAggregateOutputType = {
    id: number | null
    organizerId: number | null
    opponentId: number | null
  }

  export type MatchesSumAggregateOutputType = {
    id: number | null
    organizerId: number | null
    opponentId: number | null
  }

  export type MatchesMinAggregateOutputType = {
    id: number | null
    futsalName: string | null
    futsalType: $Enums.FutsalType | null
    matchType: string | null
    matchDate: Date | null
    startTime: Date | null
    endTime: Date | null
    status: $Enums.MatchStatus | null
    organizerId: number | null
    opponentId: number | null
  }

  export type MatchesMaxAggregateOutputType = {
    id: number | null
    futsalName: string | null
    futsalType: $Enums.FutsalType | null
    matchType: string | null
    matchDate: Date | null
    startTime: Date | null
    endTime: Date | null
    status: $Enums.MatchStatus | null
    organizerId: number | null
    opponentId: number | null
  }

  export type MatchesCountAggregateOutputType = {
    id: number
    futsalName: number
    futsalType: number
    matchType: number
    matchDate: number
    startTime: number
    endTime: number
    status: number
    organizerId: number
    opponentId: number
    _all: number
  }


  export type MatchesAvgAggregateInputType = {
    id?: true
    organizerId?: true
    opponentId?: true
  }

  export type MatchesSumAggregateInputType = {
    id?: true
    organizerId?: true
    opponentId?: true
  }

  export type MatchesMinAggregateInputType = {
    id?: true
    futsalName?: true
    futsalType?: true
    matchType?: true
    matchDate?: true
    startTime?: true
    endTime?: true
    status?: true
    organizerId?: true
    opponentId?: true
  }

  export type MatchesMaxAggregateInputType = {
    id?: true
    futsalName?: true
    futsalType?: true
    matchType?: true
    matchDate?: true
    startTime?: true
    endTime?: true
    status?: true
    organizerId?: true
    opponentId?: true
  }

  export type MatchesCountAggregateInputType = {
    id?: true
    futsalName?: true
    futsalType?: true
    matchType?: true
    matchDate?: true
    startTime?: true
    endTime?: true
    status?: true
    organizerId?: true
    opponentId?: true
    _all?: true
  }

  export type MatchesAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Matches to aggregate.
     */
    where?: MatchesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Matches to fetch.
     */
    orderBy?: MatchesOrderByWithRelationInput | MatchesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: MatchesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Matches from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Matches.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Matches
    **/
    _count?: true | MatchesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: MatchesAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: MatchesSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MatchesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MatchesMaxAggregateInputType
  }

  export type GetMatchesAggregateType<T extends MatchesAggregateArgs> = {
        [P in keyof T & keyof AggregateMatches]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMatches[P]>
      : GetScalarType<T[P], AggregateMatches[P]>
  }




  export type MatchesGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MatchesWhereInput
    orderBy?: MatchesOrderByWithAggregationInput | MatchesOrderByWithAggregationInput[]
    by: MatchesScalarFieldEnum[] | MatchesScalarFieldEnum
    having?: MatchesScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MatchesCountAggregateInputType | true
    _avg?: MatchesAvgAggregateInputType
    _sum?: MatchesSumAggregateInputType
    _min?: MatchesMinAggregateInputType
    _max?: MatchesMaxAggregateInputType
  }

  export type MatchesGroupByOutputType = {
    id: number
    futsalName: string
    futsalType: $Enums.FutsalType
    matchType: string
    matchDate: Date
    startTime: Date
    endTime: Date
    status: $Enums.MatchStatus
    organizerId: number
    opponentId: number
    _count: MatchesCountAggregateOutputType | null
    _avg: MatchesAvgAggregateOutputType | null
    _sum: MatchesSumAggregateOutputType | null
    _min: MatchesMinAggregateOutputType | null
    _max: MatchesMaxAggregateOutputType | null
  }

  type GetMatchesGroupByPayload<T extends MatchesGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<MatchesGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MatchesGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MatchesGroupByOutputType[P]>
            : GetScalarType<T[P], MatchesGroupByOutputType[P]>
        }
      >
    >


  export type MatchesSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    futsalName?: boolean
    futsalType?: boolean
    matchType?: boolean
    matchDate?: boolean
    startTime?: boolean
    endTime?: boolean
    status?: boolean
    organizerId?: boolean
    opponentId?: boolean
    organizer?: boolean | UsersDefaultArgs<ExtArgs>
    opponent?: boolean | UsersDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["matches"]>

  export type MatchesSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    futsalName?: boolean
    futsalType?: boolean
    matchType?: boolean
    matchDate?: boolean
    startTime?: boolean
    endTime?: boolean
    status?: boolean
    organizerId?: boolean
    opponentId?: boolean
    organizer?: boolean | UsersDefaultArgs<ExtArgs>
    opponent?: boolean | UsersDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["matches"]>

  export type MatchesSelectScalar = {
    id?: boolean
    futsalName?: boolean
    futsalType?: boolean
    matchType?: boolean
    matchDate?: boolean
    startTime?: boolean
    endTime?: boolean
    status?: boolean
    organizerId?: boolean
    opponentId?: boolean
  }

  export type MatchesInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    organizer?: boolean | UsersDefaultArgs<ExtArgs>
    opponent?: boolean | UsersDefaultArgs<ExtArgs>
  }
  export type MatchesIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    organizer?: boolean | UsersDefaultArgs<ExtArgs>
    opponent?: boolean | UsersDefaultArgs<ExtArgs>
  }

  export type $MatchesPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Matches"
    objects: {
      organizer: Prisma.$UsersPayload<ExtArgs>
      opponent: Prisma.$UsersPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      futsalName: string
      futsalType: $Enums.FutsalType
      matchType: string
      matchDate: Date
      startTime: Date
      endTime: Date
      status: $Enums.MatchStatus
      organizerId: number
      opponentId: number
    }, ExtArgs["result"]["matches"]>
    composites: {}
  }

  type MatchesGetPayload<S extends boolean | null | undefined | MatchesDefaultArgs> = $Result.GetResult<Prisma.$MatchesPayload, S>

  type MatchesCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<MatchesFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: MatchesCountAggregateInputType | true
    }

  export interface MatchesDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Matches'], meta: { name: 'Matches' } }
    /**
     * Find zero or one Matches that matches the filter.
     * @param {MatchesFindUniqueArgs} args - Arguments to find a Matches
     * @example
     * // Get one Matches
     * const matches = await prisma.matches.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends MatchesFindUniqueArgs>(args: SelectSubset<T, MatchesFindUniqueArgs<ExtArgs>>): Prisma__MatchesClient<$Result.GetResult<Prisma.$MatchesPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Matches that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {MatchesFindUniqueOrThrowArgs} args - Arguments to find a Matches
     * @example
     * // Get one Matches
     * const matches = await prisma.matches.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends MatchesFindUniqueOrThrowArgs>(args: SelectSubset<T, MatchesFindUniqueOrThrowArgs<ExtArgs>>): Prisma__MatchesClient<$Result.GetResult<Prisma.$MatchesPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Matches that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MatchesFindFirstArgs} args - Arguments to find a Matches
     * @example
     * // Get one Matches
     * const matches = await prisma.matches.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends MatchesFindFirstArgs>(args?: SelectSubset<T, MatchesFindFirstArgs<ExtArgs>>): Prisma__MatchesClient<$Result.GetResult<Prisma.$MatchesPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Matches that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MatchesFindFirstOrThrowArgs} args - Arguments to find a Matches
     * @example
     * // Get one Matches
     * const matches = await prisma.matches.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends MatchesFindFirstOrThrowArgs>(args?: SelectSubset<T, MatchesFindFirstOrThrowArgs<ExtArgs>>): Prisma__MatchesClient<$Result.GetResult<Prisma.$MatchesPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Matches that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MatchesFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Matches
     * const matches = await prisma.matches.findMany()
     * 
     * // Get first 10 Matches
     * const matches = await prisma.matches.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const matchesWithIdOnly = await prisma.matches.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends MatchesFindManyArgs>(args?: SelectSubset<T, MatchesFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MatchesPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Matches.
     * @param {MatchesCreateArgs} args - Arguments to create a Matches.
     * @example
     * // Create one Matches
     * const Matches = await prisma.matches.create({
     *   data: {
     *     // ... data to create a Matches
     *   }
     * })
     * 
     */
    create<T extends MatchesCreateArgs>(args: SelectSubset<T, MatchesCreateArgs<ExtArgs>>): Prisma__MatchesClient<$Result.GetResult<Prisma.$MatchesPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Matches.
     * @param {MatchesCreateManyArgs} args - Arguments to create many Matches.
     * @example
     * // Create many Matches
     * const matches = await prisma.matches.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends MatchesCreateManyArgs>(args?: SelectSubset<T, MatchesCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Matches and returns the data saved in the database.
     * @param {MatchesCreateManyAndReturnArgs} args - Arguments to create many Matches.
     * @example
     * // Create many Matches
     * const matches = await prisma.matches.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Matches and only return the `id`
     * const matchesWithIdOnly = await prisma.matches.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends MatchesCreateManyAndReturnArgs>(args?: SelectSubset<T, MatchesCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MatchesPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Matches.
     * @param {MatchesDeleteArgs} args - Arguments to delete one Matches.
     * @example
     * // Delete one Matches
     * const Matches = await prisma.matches.delete({
     *   where: {
     *     // ... filter to delete one Matches
     *   }
     * })
     * 
     */
    delete<T extends MatchesDeleteArgs>(args: SelectSubset<T, MatchesDeleteArgs<ExtArgs>>): Prisma__MatchesClient<$Result.GetResult<Prisma.$MatchesPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Matches.
     * @param {MatchesUpdateArgs} args - Arguments to update one Matches.
     * @example
     * // Update one Matches
     * const matches = await prisma.matches.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends MatchesUpdateArgs>(args: SelectSubset<T, MatchesUpdateArgs<ExtArgs>>): Prisma__MatchesClient<$Result.GetResult<Prisma.$MatchesPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Matches.
     * @param {MatchesDeleteManyArgs} args - Arguments to filter Matches to delete.
     * @example
     * // Delete a few Matches
     * const { count } = await prisma.matches.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends MatchesDeleteManyArgs>(args?: SelectSubset<T, MatchesDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Matches.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MatchesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Matches
     * const matches = await prisma.matches.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends MatchesUpdateManyArgs>(args: SelectSubset<T, MatchesUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Matches.
     * @param {MatchesUpsertArgs} args - Arguments to update or create a Matches.
     * @example
     * // Update or create a Matches
     * const matches = await prisma.matches.upsert({
     *   create: {
     *     // ... data to create a Matches
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Matches we want to update
     *   }
     * })
     */
    upsert<T extends MatchesUpsertArgs>(args: SelectSubset<T, MatchesUpsertArgs<ExtArgs>>): Prisma__MatchesClient<$Result.GetResult<Prisma.$MatchesPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Matches.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MatchesCountArgs} args - Arguments to filter Matches to count.
     * @example
     * // Count the number of Matches
     * const count = await prisma.matches.count({
     *   where: {
     *     // ... the filter for the Matches we want to count
     *   }
     * })
    **/
    count<T extends MatchesCountArgs>(
      args?: Subset<T, MatchesCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MatchesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Matches.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MatchesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MatchesAggregateArgs>(args: Subset<T, MatchesAggregateArgs>): Prisma.PrismaPromise<GetMatchesAggregateType<T>>

    /**
     * Group by Matches.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MatchesGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends MatchesGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: MatchesGroupByArgs['orderBy'] }
        : { orderBy?: MatchesGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, MatchesGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMatchesGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Matches model
   */
  readonly fields: MatchesFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Matches.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__MatchesClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    organizer<T extends UsersDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UsersDefaultArgs<ExtArgs>>): Prisma__UsersClient<$Result.GetResult<Prisma.$UsersPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    opponent<T extends UsersDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UsersDefaultArgs<ExtArgs>>): Prisma__UsersClient<$Result.GetResult<Prisma.$UsersPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Matches model
   */ 
  interface MatchesFieldRefs {
    readonly id: FieldRef<"Matches", 'Int'>
    readonly futsalName: FieldRef<"Matches", 'String'>
    readonly futsalType: FieldRef<"Matches", 'FutsalType'>
    readonly matchType: FieldRef<"Matches", 'String'>
    readonly matchDate: FieldRef<"Matches", 'DateTime'>
    readonly startTime: FieldRef<"Matches", 'DateTime'>
    readonly endTime: FieldRef<"Matches", 'DateTime'>
    readonly status: FieldRef<"Matches", 'MatchStatus'>
    readonly organizerId: FieldRef<"Matches", 'Int'>
    readonly opponentId: FieldRef<"Matches", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * Matches findUnique
   */
  export type MatchesFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Matches
     */
    select?: MatchesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MatchesInclude<ExtArgs> | null
    /**
     * Filter, which Matches to fetch.
     */
    where: MatchesWhereUniqueInput
  }

  /**
   * Matches findUniqueOrThrow
   */
  export type MatchesFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Matches
     */
    select?: MatchesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MatchesInclude<ExtArgs> | null
    /**
     * Filter, which Matches to fetch.
     */
    where: MatchesWhereUniqueInput
  }

  /**
   * Matches findFirst
   */
  export type MatchesFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Matches
     */
    select?: MatchesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MatchesInclude<ExtArgs> | null
    /**
     * Filter, which Matches to fetch.
     */
    where?: MatchesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Matches to fetch.
     */
    orderBy?: MatchesOrderByWithRelationInput | MatchesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Matches.
     */
    cursor?: MatchesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Matches from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Matches.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Matches.
     */
    distinct?: MatchesScalarFieldEnum | MatchesScalarFieldEnum[]
  }

  /**
   * Matches findFirstOrThrow
   */
  export type MatchesFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Matches
     */
    select?: MatchesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MatchesInclude<ExtArgs> | null
    /**
     * Filter, which Matches to fetch.
     */
    where?: MatchesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Matches to fetch.
     */
    orderBy?: MatchesOrderByWithRelationInput | MatchesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Matches.
     */
    cursor?: MatchesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Matches from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Matches.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Matches.
     */
    distinct?: MatchesScalarFieldEnum | MatchesScalarFieldEnum[]
  }

  /**
   * Matches findMany
   */
  export type MatchesFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Matches
     */
    select?: MatchesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MatchesInclude<ExtArgs> | null
    /**
     * Filter, which Matches to fetch.
     */
    where?: MatchesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Matches to fetch.
     */
    orderBy?: MatchesOrderByWithRelationInput | MatchesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Matches.
     */
    cursor?: MatchesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Matches from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Matches.
     */
    skip?: number
    distinct?: MatchesScalarFieldEnum | MatchesScalarFieldEnum[]
  }

  /**
   * Matches create
   */
  export type MatchesCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Matches
     */
    select?: MatchesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MatchesInclude<ExtArgs> | null
    /**
     * The data needed to create a Matches.
     */
    data: XOR<MatchesCreateInput, MatchesUncheckedCreateInput>
  }

  /**
   * Matches createMany
   */
  export type MatchesCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Matches.
     */
    data: MatchesCreateManyInput | MatchesCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Matches createManyAndReturn
   */
  export type MatchesCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Matches
     */
    select?: MatchesSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Matches.
     */
    data: MatchesCreateManyInput | MatchesCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MatchesIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Matches update
   */
  export type MatchesUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Matches
     */
    select?: MatchesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MatchesInclude<ExtArgs> | null
    /**
     * The data needed to update a Matches.
     */
    data: XOR<MatchesUpdateInput, MatchesUncheckedUpdateInput>
    /**
     * Choose, which Matches to update.
     */
    where: MatchesWhereUniqueInput
  }

  /**
   * Matches updateMany
   */
  export type MatchesUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Matches.
     */
    data: XOR<MatchesUpdateManyMutationInput, MatchesUncheckedUpdateManyInput>
    /**
     * Filter which Matches to update
     */
    where?: MatchesWhereInput
  }

  /**
   * Matches upsert
   */
  export type MatchesUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Matches
     */
    select?: MatchesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MatchesInclude<ExtArgs> | null
    /**
     * The filter to search for the Matches to update in case it exists.
     */
    where: MatchesWhereUniqueInput
    /**
     * In case the Matches found by the `where` argument doesn't exist, create a new Matches with this data.
     */
    create: XOR<MatchesCreateInput, MatchesUncheckedCreateInput>
    /**
     * In case the Matches was found with the provided `where` argument, update it with this data.
     */
    update: XOR<MatchesUpdateInput, MatchesUncheckedUpdateInput>
  }

  /**
   * Matches delete
   */
  export type MatchesDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Matches
     */
    select?: MatchesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MatchesInclude<ExtArgs> | null
    /**
     * Filter which Matches to delete.
     */
    where: MatchesWhereUniqueInput
  }

  /**
   * Matches deleteMany
   */
  export type MatchesDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Matches to delete
     */
    where?: MatchesWhereInput
  }

  /**
   * Matches without action
   */
  export type MatchesDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Matches
     */
    select?: MatchesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MatchesInclude<ExtArgs> | null
  }


  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted',
    ReadCommitted: 'ReadCommitted',
    RepeatableRead: 'RepeatableRead',
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const RolesScalarFieldEnum: {
    id: 'id',
    title: 'title'
  };

  export type RolesScalarFieldEnum = (typeof RolesScalarFieldEnum)[keyof typeof RolesScalarFieldEnum]


  export const UsersScalarFieldEnum: {
    id: 'id',
    googleId: 'googleId',
    facebookId: 'facebookId',
    name: 'name',
    email: 'email',
    phone: 'phone',
    image: 'image',
    password: 'password',
    address: 'address',
    roleId: 'roleId'
  };

  export type UsersScalarFieldEnum = (typeof UsersScalarFieldEnum)[keyof typeof UsersScalarFieldEnum]


  export const FutsalsScalarFieldEnum: {
    id: 'id',
    name: 'name',
    phone: 'phone',
    address: 'address',
    type: 'type',
    startTime: 'startTime',
    endTime: 'endTime',
    amenities: 'amenities',
    stdPrice: 'stdPrice',
    rating: 'rating',
    pan: 'pan',
    userId: 'userId'
  };

  export type FutsalsScalarFieldEnum = (typeof FutsalsScalarFieldEnum)[keyof typeof FutsalsScalarFieldEnum]


  export const FutsalImageScalarFieldEnum: {
    id: 'id',
    url: 'url',
    futsalId: 'futsalId'
  };

  export type FutsalImageScalarFieldEnum = (typeof FutsalImageScalarFieldEnum)[keyof typeof FutsalImageScalarFieldEnum]


  export const PriceListsScalarFieldEnum: {
    id: 'id',
    startTime: 'startTime',
    endTime: 'endTime',
    dayOfWeek: 'dayOfWeek',
    price: 'price',
    futsalId: 'futsalId'
  };

  export type PriceListsScalarFieldEnum = (typeof PriceListsScalarFieldEnum)[keyof typeof PriceListsScalarFieldEnum]


  export const BookingsScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    futsalId: 'futsalId',
    bookDate: 'bookDate',
    startTime: 'startTime',
    endTime: 'endTime',
    type: 'type',
    price: 'price',
    confirmation: 'confirmation',
    paymentStatus: 'paymentStatus'
  };

  export type BookingsScalarFieldEnum = (typeof BookingsScalarFieldEnum)[keyof typeof BookingsScalarFieldEnum]


  export const TimeSlotsScalarFieldEnum: {
    id: 'id',
    startTime: 'startTime',
    endTime: 'endTime',
    date: 'date',
    price: 'price',
    futsalType: 'futsalType',
    futsalId: 'futsalId'
  };

  export type TimeSlotsScalarFieldEnum = (typeof TimeSlotsScalarFieldEnum)[keyof typeof TimeSlotsScalarFieldEnum]


  export const MatchRequestScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    futsalName: 'futsalName',
    futsalType: 'futsalType',
    matchDate: 'matchDate',
    startTime: 'startTime',
    endTime: 'endTime',
    matchType: 'matchType',
    status: 'status'
  };

  export type MatchRequestScalarFieldEnum = (typeof MatchRequestScalarFieldEnum)[keyof typeof MatchRequestScalarFieldEnum]


  export const MatchesScalarFieldEnum: {
    id: 'id',
    futsalName: 'futsalName',
    futsalType: 'futsalType',
    matchType: 'matchType',
    matchDate: 'matchDate',
    startTime: 'startTime',
    endTime: 'endTime',
    status: 'status',
    organizerId: 'organizerId',
    opponentId: 'opponentId'
  };

  export type MatchesScalarFieldEnum = (typeof MatchesScalarFieldEnum)[keyof typeof MatchesScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const QueryMode: {
    default: 'default',
    insensitive: 'insensitive'
  };

  export type QueryMode = (typeof QueryMode)[keyof typeof QueryMode]


  export const NullsOrder: {
    first: 'first',
    last: 'last'
  };

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]


  /**
   * Field references 
   */


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'Int[]'
   */
  export type ListIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int[]'>
    


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'String[]'
   */
  export type ListStringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String[]'>
    


  /**
   * Reference to a field of type 'FutsalType'
   */
  export type EnumFutsalTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'FutsalType'>
    


  /**
   * Reference to a field of type 'FutsalType[]'
   */
  export type ListEnumFutsalTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'FutsalType[]'>
    


  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


  /**
   * Reference to a field of type 'DateTime[]'
   */
  export type ListDateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime[]'>
    


  /**
   * Reference to a field of type 'Decimal'
   */
  export type DecimalFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Decimal'>
    


  /**
   * Reference to a field of type 'Decimal[]'
   */
  export type ListDecimalFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Decimal[]'>
    


  /**
   * Reference to a field of type 'BookingStatus'
   */
  export type EnumBookingStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'BookingStatus'>
    


  /**
   * Reference to a field of type 'BookingStatus[]'
   */
  export type ListEnumBookingStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'BookingStatus[]'>
    


  /**
   * Reference to a field of type 'Payment'
   */
  export type EnumPaymentFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Payment'>
    


  /**
   * Reference to a field of type 'Payment[]'
   */
  export type ListEnumPaymentFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Payment[]'>
    


  /**
   * Reference to a field of type 'RequestStatus'
   */
  export type EnumRequestStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'RequestStatus'>
    


  /**
   * Reference to a field of type 'RequestStatus[]'
   */
  export type ListEnumRequestStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'RequestStatus[]'>
    


  /**
   * Reference to a field of type 'MatchStatus'
   */
  export type EnumMatchStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'MatchStatus'>
    


  /**
   * Reference to a field of type 'MatchStatus[]'
   */
  export type ListEnumMatchStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'MatchStatus[]'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    


  /**
   * Reference to a field of type 'Float[]'
   */
  export type ListFloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float[]'>
    
  /**
   * Deep Input Types
   */


  export type RolesWhereInput = {
    AND?: RolesWhereInput | RolesWhereInput[]
    OR?: RolesWhereInput[]
    NOT?: RolesWhereInput | RolesWhereInput[]
    id?: IntFilter<"Roles"> | number
    title?: StringFilter<"Roles"> | string
    Users?: UsersListRelationFilter
  }

  export type RolesOrderByWithRelationInput = {
    id?: SortOrder
    title?: SortOrder
    Users?: UsersOrderByRelationAggregateInput
  }

  export type RolesWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: RolesWhereInput | RolesWhereInput[]
    OR?: RolesWhereInput[]
    NOT?: RolesWhereInput | RolesWhereInput[]
    title?: StringFilter<"Roles"> | string
    Users?: UsersListRelationFilter
  }, "id">

  export type RolesOrderByWithAggregationInput = {
    id?: SortOrder
    title?: SortOrder
    _count?: RolesCountOrderByAggregateInput
    _avg?: RolesAvgOrderByAggregateInput
    _max?: RolesMaxOrderByAggregateInput
    _min?: RolesMinOrderByAggregateInput
    _sum?: RolesSumOrderByAggregateInput
  }

  export type RolesScalarWhereWithAggregatesInput = {
    AND?: RolesScalarWhereWithAggregatesInput | RolesScalarWhereWithAggregatesInput[]
    OR?: RolesScalarWhereWithAggregatesInput[]
    NOT?: RolesScalarWhereWithAggregatesInput | RolesScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Roles"> | number
    title?: StringWithAggregatesFilter<"Roles"> | string
  }

  export type UsersWhereInput = {
    AND?: UsersWhereInput | UsersWhereInput[]
    OR?: UsersWhereInput[]
    NOT?: UsersWhereInput | UsersWhereInput[]
    id?: IntFilter<"Users"> | number
    googleId?: StringNullableFilter<"Users"> | string | null
    facebookId?: StringNullableFilter<"Users"> | string | null
    name?: StringFilter<"Users"> | string
    email?: StringFilter<"Users"> | string
    phone?: StringFilter<"Users"> | string
    image?: StringNullableFilter<"Users"> | string | null
    password?: StringFilter<"Users"> | string
    address?: StringFilter<"Users"> | string
    roleId?: IntFilter<"Users"> | number
    roles?: XOR<RolesRelationFilter, RolesWhereInput>
    Futsals?: XOR<FutsalsNullableRelationFilter, FutsalsWhereInput> | null
    Bookings?: BookingsListRelationFilter
    MatchRequest?: XOR<MatchRequestNullableRelationFilter, MatchRequestWhereInput> | null
    organizedMatches?: MatchesListRelationFilter
    opponentMatches?: MatchesListRelationFilter
  }

  export type UsersOrderByWithRelationInput = {
    id?: SortOrder
    googleId?: SortOrderInput | SortOrder
    facebookId?: SortOrderInput | SortOrder
    name?: SortOrder
    email?: SortOrder
    phone?: SortOrder
    image?: SortOrderInput | SortOrder
    password?: SortOrder
    address?: SortOrder
    roleId?: SortOrder
    roles?: RolesOrderByWithRelationInput
    Futsals?: FutsalsOrderByWithRelationInput
    Bookings?: BookingsOrderByRelationAggregateInput
    MatchRequest?: MatchRequestOrderByWithRelationInput
    organizedMatches?: MatchesOrderByRelationAggregateInput
    opponentMatches?: MatchesOrderByRelationAggregateInput
  }

  export type UsersWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    googleId?: string
    facebookId?: string
    email?: string
    phone?: string
    password?: string
    AND?: UsersWhereInput | UsersWhereInput[]
    OR?: UsersWhereInput[]
    NOT?: UsersWhereInput | UsersWhereInput[]
    name?: StringFilter<"Users"> | string
    image?: StringNullableFilter<"Users"> | string | null
    address?: StringFilter<"Users"> | string
    roleId?: IntFilter<"Users"> | number
    roles?: XOR<RolesRelationFilter, RolesWhereInput>
    Futsals?: XOR<FutsalsNullableRelationFilter, FutsalsWhereInput> | null
    Bookings?: BookingsListRelationFilter
    MatchRequest?: XOR<MatchRequestNullableRelationFilter, MatchRequestWhereInput> | null
    organizedMatches?: MatchesListRelationFilter
    opponentMatches?: MatchesListRelationFilter
  }, "id" | "googleId" | "facebookId" | "email" | "phone" | "password">

  export type UsersOrderByWithAggregationInput = {
    id?: SortOrder
    googleId?: SortOrderInput | SortOrder
    facebookId?: SortOrderInput | SortOrder
    name?: SortOrder
    email?: SortOrder
    phone?: SortOrder
    image?: SortOrderInput | SortOrder
    password?: SortOrder
    address?: SortOrder
    roleId?: SortOrder
    _count?: UsersCountOrderByAggregateInput
    _avg?: UsersAvgOrderByAggregateInput
    _max?: UsersMaxOrderByAggregateInput
    _min?: UsersMinOrderByAggregateInput
    _sum?: UsersSumOrderByAggregateInput
  }

  export type UsersScalarWhereWithAggregatesInput = {
    AND?: UsersScalarWhereWithAggregatesInput | UsersScalarWhereWithAggregatesInput[]
    OR?: UsersScalarWhereWithAggregatesInput[]
    NOT?: UsersScalarWhereWithAggregatesInput | UsersScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Users"> | number
    googleId?: StringNullableWithAggregatesFilter<"Users"> | string | null
    facebookId?: StringNullableWithAggregatesFilter<"Users"> | string | null
    name?: StringWithAggregatesFilter<"Users"> | string
    email?: StringWithAggregatesFilter<"Users"> | string
    phone?: StringWithAggregatesFilter<"Users"> | string
    image?: StringNullableWithAggregatesFilter<"Users"> | string | null
    password?: StringWithAggregatesFilter<"Users"> | string
    address?: StringWithAggregatesFilter<"Users"> | string
    roleId?: IntWithAggregatesFilter<"Users"> | number
  }

  export type FutsalsWhereInput = {
    AND?: FutsalsWhereInput | FutsalsWhereInput[]
    OR?: FutsalsWhereInput[]
    NOT?: FutsalsWhereInput | FutsalsWhereInput[]
    id?: IntFilter<"Futsals"> | number
    name?: StringFilter<"Futsals"> | string
    phone?: StringFilter<"Futsals"> | string
    address?: StringFilter<"Futsals"> | string
    type?: EnumFutsalTypeFilter<"Futsals"> | $Enums.FutsalType
    startTime?: DateTimeFilter<"Futsals"> | Date | string
    endTime?: DateTimeFilter<"Futsals"> | Date | string
    amenities?: StringNullableListFilter<"Futsals">
    stdPrice?: IntFilter<"Futsals"> | number
    rating?: DecimalFilter<"Futsals"> | Decimal | DecimalJsLike | number | string
    pan?: StringFilter<"Futsals"> | string
    userId?: IntFilter<"Futsals"> | number
    images?: FutsalImageListRelationFilter
    users?: XOR<UsersRelationFilter, UsersWhereInput>
    PriceLists?: PriceListsListRelationFilter
    Bookings?: BookingsListRelationFilter
    timeSlots?: TimeSlotsListRelationFilter
  }

  export type FutsalsOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    phone?: SortOrder
    address?: SortOrder
    type?: SortOrder
    startTime?: SortOrder
    endTime?: SortOrder
    amenities?: SortOrder
    stdPrice?: SortOrder
    rating?: SortOrder
    pan?: SortOrder
    userId?: SortOrder
    images?: FutsalImageOrderByRelationAggregateInput
    users?: UsersOrderByWithRelationInput
    PriceLists?: PriceListsOrderByRelationAggregateInput
    Bookings?: BookingsOrderByRelationAggregateInput
    timeSlots?: TimeSlotsOrderByRelationAggregateInput
  }

  export type FutsalsWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    phone?: string
    pan?: string
    userId?: number
    AND?: FutsalsWhereInput | FutsalsWhereInput[]
    OR?: FutsalsWhereInput[]
    NOT?: FutsalsWhereInput | FutsalsWhereInput[]
    name?: StringFilter<"Futsals"> | string
    address?: StringFilter<"Futsals"> | string
    type?: EnumFutsalTypeFilter<"Futsals"> | $Enums.FutsalType
    startTime?: DateTimeFilter<"Futsals"> | Date | string
    endTime?: DateTimeFilter<"Futsals"> | Date | string
    amenities?: StringNullableListFilter<"Futsals">
    stdPrice?: IntFilter<"Futsals"> | number
    rating?: DecimalFilter<"Futsals"> | Decimal | DecimalJsLike | number | string
    images?: FutsalImageListRelationFilter
    users?: XOR<UsersRelationFilter, UsersWhereInput>
    PriceLists?: PriceListsListRelationFilter
    Bookings?: BookingsListRelationFilter
    timeSlots?: TimeSlotsListRelationFilter
  }, "id" | "phone" | "pan" | "userId">

  export type FutsalsOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    phone?: SortOrder
    address?: SortOrder
    type?: SortOrder
    startTime?: SortOrder
    endTime?: SortOrder
    amenities?: SortOrder
    stdPrice?: SortOrder
    rating?: SortOrder
    pan?: SortOrder
    userId?: SortOrder
    _count?: FutsalsCountOrderByAggregateInput
    _avg?: FutsalsAvgOrderByAggregateInput
    _max?: FutsalsMaxOrderByAggregateInput
    _min?: FutsalsMinOrderByAggregateInput
    _sum?: FutsalsSumOrderByAggregateInput
  }

  export type FutsalsScalarWhereWithAggregatesInput = {
    AND?: FutsalsScalarWhereWithAggregatesInput | FutsalsScalarWhereWithAggregatesInput[]
    OR?: FutsalsScalarWhereWithAggregatesInput[]
    NOT?: FutsalsScalarWhereWithAggregatesInput | FutsalsScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Futsals"> | number
    name?: StringWithAggregatesFilter<"Futsals"> | string
    phone?: StringWithAggregatesFilter<"Futsals"> | string
    address?: StringWithAggregatesFilter<"Futsals"> | string
    type?: EnumFutsalTypeWithAggregatesFilter<"Futsals"> | $Enums.FutsalType
    startTime?: DateTimeWithAggregatesFilter<"Futsals"> | Date | string
    endTime?: DateTimeWithAggregatesFilter<"Futsals"> | Date | string
    amenities?: StringNullableListFilter<"Futsals">
    stdPrice?: IntWithAggregatesFilter<"Futsals"> | number
    rating?: DecimalWithAggregatesFilter<"Futsals"> | Decimal | DecimalJsLike | number | string
    pan?: StringWithAggregatesFilter<"Futsals"> | string
    userId?: IntWithAggregatesFilter<"Futsals"> | number
  }

  export type FutsalImageWhereInput = {
    AND?: FutsalImageWhereInput | FutsalImageWhereInput[]
    OR?: FutsalImageWhereInput[]
    NOT?: FutsalImageWhereInput | FutsalImageWhereInput[]
    id?: IntFilter<"FutsalImage"> | number
    url?: StringFilter<"FutsalImage"> | string
    futsalId?: IntFilter<"FutsalImage"> | number
    futsal?: XOR<FutsalsRelationFilter, FutsalsWhereInput>
  }

  export type FutsalImageOrderByWithRelationInput = {
    id?: SortOrder
    url?: SortOrder
    futsalId?: SortOrder
    futsal?: FutsalsOrderByWithRelationInput
  }

  export type FutsalImageWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: FutsalImageWhereInput | FutsalImageWhereInput[]
    OR?: FutsalImageWhereInput[]
    NOT?: FutsalImageWhereInput | FutsalImageWhereInput[]
    url?: StringFilter<"FutsalImage"> | string
    futsalId?: IntFilter<"FutsalImage"> | number
    futsal?: XOR<FutsalsRelationFilter, FutsalsWhereInput>
  }, "id">

  export type FutsalImageOrderByWithAggregationInput = {
    id?: SortOrder
    url?: SortOrder
    futsalId?: SortOrder
    _count?: FutsalImageCountOrderByAggregateInput
    _avg?: FutsalImageAvgOrderByAggregateInput
    _max?: FutsalImageMaxOrderByAggregateInput
    _min?: FutsalImageMinOrderByAggregateInput
    _sum?: FutsalImageSumOrderByAggregateInput
  }

  export type FutsalImageScalarWhereWithAggregatesInput = {
    AND?: FutsalImageScalarWhereWithAggregatesInput | FutsalImageScalarWhereWithAggregatesInput[]
    OR?: FutsalImageScalarWhereWithAggregatesInput[]
    NOT?: FutsalImageScalarWhereWithAggregatesInput | FutsalImageScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"FutsalImage"> | number
    url?: StringWithAggregatesFilter<"FutsalImage"> | string
    futsalId?: IntWithAggregatesFilter<"FutsalImage"> | number
  }

  export type PriceListsWhereInput = {
    AND?: PriceListsWhereInput | PriceListsWhereInput[]
    OR?: PriceListsWhereInput[]
    NOT?: PriceListsWhereInput | PriceListsWhereInput[]
    id?: IntFilter<"PriceLists"> | number
    startTime?: DateTimeFilter<"PriceLists"> | Date | string
    endTime?: DateTimeFilter<"PriceLists"> | Date | string
    dayOfWeek?: StringFilter<"PriceLists"> | string
    price?: IntFilter<"PriceLists"> | number
    futsalId?: IntFilter<"PriceLists"> | number
    futsals?: XOR<FutsalsRelationFilter, FutsalsWhereInput>
  }

  export type PriceListsOrderByWithRelationInput = {
    id?: SortOrder
    startTime?: SortOrder
    endTime?: SortOrder
    dayOfWeek?: SortOrder
    price?: SortOrder
    futsalId?: SortOrder
    futsals?: FutsalsOrderByWithRelationInput
  }

  export type PriceListsWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: PriceListsWhereInput | PriceListsWhereInput[]
    OR?: PriceListsWhereInput[]
    NOT?: PriceListsWhereInput | PriceListsWhereInput[]
    startTime?: DateTimeFilter<"PriceLists"> | Date | string
    endTime?: DateTimeFilter<"PriceLists"> | Date | string
    dayOfWeek?: StringFilter<"PriceLists"> | string
    price?: IntFilter<"PriceLists"> | number
    futsalId?: IntFilter<"PriceLists"> | number
    futsals?: XOR<FutsalsRelationFilter, FutsalsWhereInput>
  }, "id">

  export type PriceListsOrderByWithAggregationInput = {
    id?: SortOrder
    startTime?: SortOrder
    endTime?: SortOrder
    dayOfWeek?: SortOrder
    price?: SortOrder
    futsalId?: SortOrder
    _count?: PriceListsCountOrderByAggregateInput
    _avg?: PriceListsAvgOrderByAggregateInput
    _max?: PriceListsMaxOrderByAggregateInput
    _min?: PriceListsMinOrderByAggregateInput
    _sum?: PriceListsSumOrderByAggregateInput
  }

  export type PriceListsScalarWhereWithAggregatesInput = {
    AND?: PriceListsScalarWhereWithAggregatesInput | PriceListsScalarWhereWithAggregatesInput[]
    OR?: PriceListsScalarWhereWithAggregatesInput[]
    NOT?: PriceListsScalarWhereWithAggregatesInput | PriceListsScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"PriceLists"> | number
    startTime?: DateTimeWithAggregatesFilter<"PriceLists"> | Date | string
    endTime?: DateTimeWithAggregatesFilter<"PriceLists"> | Date | string
    dayOfWeek?: StringWithAggregatesFilter<"PriceLists"> | string
    price?: IntWithAggregatesFilter<"PriceLists"> | number
    futsalId?: IntWithAggregatesFilter<"PriceLists"> | number
  }

  export type BookingsWhereInput = {
    AND?: BookingsWhereInput | BookingsWhereInput[]
    OR?: BookingsWhereInput[]
    NOT?: BookingsWhereInput | BookingsWhereInput[]
    id?: IntFilter<"Bookings"> | number
    userId?: IntFilter<"Bookings"> | number
    futsalId?: IntFilter<"Bookings"> | number
    bookDate?: DateTimeFilter<"Bookings"> | Date | string
    startTime?: DateTimeFilter<"Bookings"> | Date | string
    endTime?: DateTimeFilter<"Bookings"> | Date | string
    type?: EnumFutsalTypeFilter<"Bookings"> | $Enums.FutsalType
    price?: IntFilter<"Bookings"> | number
    confirmation?: EnumBookingStatusFilter<"Bookings"> | $Enums.BookingStatus
    paymentStatus?: EnumPaymentFilter<"Bookings"> | $Enums.Payment
    users?: XOR<UsersRelationFilter, UsersWhereInput>
    futsals?: XOR<FutsalsRelationFilter, FutsalsWhereInput>
  }

  export type BookingsOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    futsalId?: SortOrder
    bookDate?: SortOrder
    startTime?: SortOrder
    endTime?: SortOrder
    type?: SortOrder
    price?: SortOrder
    confirmation?: SortOrder
    paymentStatus?: SortOrder
    users?: UsersOrderByWithRelationInput
    futsals?: FutsalsOrderByWithRelationInput
  }

  export type BookingsWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: BookingsWhereInput | BookingsWhereInput[]
    OR?: BookingsWhereInput[]
    NOT?: BookingsWhereInput | BookingsWhereInput[]
    userId?: IntFilter<"Bookings"> | number
    futsalId?: IntFilter<"Bookings"> | number
    bookDate?: DateTimeFilter<"Bookings"> | Date | string
    startTime?: DateTimeFilter<"Bookings"> | Date | string
    endTime?: DateTimeFilter<"Bookings"> | Date | string
    type?: EnumFutsalTypeFilter<"Bookings"> | $Enums.FutsalType
    price?: IntFilter<"Bookings"> | number
    confirmation?: EnumBookingStatusFilter<"Bookings"> | $Enums.BookingStatus
    paymentStatus?: EnumPaymentFilter<"Bookings"> | $Enums.Payment
    users?: XOR<UsersRelationFilter, UsersWhereInput>
    futsals?: XOR<FutsalsRelationFilter, FutsalsWhereInput>
  }, "id">

  export type BookingsOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    futsalId?: SortOrder
    bookDate?: SortOrder
    startTime?: SortOrder
    endTime?: SortOrder
    type?: SortOrder
    price?: SortOrder
    confirmation?: SortOrder
    paymentStatus?: SortOrder
    _count?: BookingsCountOrderByAggregateInput
    _avg?: BookingsAvgOrderByAggregateInput
    _max?: BookingsMaxOrderByAggregateInput
    _min?: BookingsMinOrderByAggregateInput
    _sum?: BookingsSumOrderByAggregateInput
  }

  export type BookingsScalarWhereWithAggregatesInput = {
    AND?: BookingsScalarWhereWithAggregatesInput | BookingsScalarWhereWithAggregatesInput[]
    OR?: BookingsScalarWhereWithAggregatesInput[]
    NOT?: BookingsScalarWhereWithAggregatesInput | BookingsScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Bookings"> | number
    userId?: IntWithAggregatesFilter<"Bookings"> | number
    futsalId?: IntWithAggregatesFilter<"Bookings"> | number
    bookDate?: DateTimeWithAggregatesFilter<"Bookings"> | Date | string
    startTime?: DateTimeWithAggregatesFilter<"Bookings"> | Date | string
    endTime?: DateTimeWithAggregatesFilter<"Bookings"> | Date | string
    type?: EnumFutsalTypeWithAggregatesFilter<"Bookings"> | $Enums.FutsalType
    price?: IntWithAggregatesFilter<"Bookings"> | number
    confirmation?: EnumBookingStatusWithAggregatesFilter<"Bookings"> | $Enums.BookingStatus
    paymentStatus?: EnumPaymentWithAggregatesFilter<"Bookings"> | $Enums.Payment
  }

  export type TimeSlotsWhereInput = {
    AND?: TimeSlotsWhereInput | TimeSlotsWhereInput[]
    OR?: TimeSlotsWhereInput[]
    NOT?: TimeSlotsWhereInput | TimeSlotsWhereInput[]
    id?: IntFilter<"TimeSlots"> | number
    startTime?: DateTimeFilter<"TimeSlots"> | Date | string
    endTime?: DateTimeFilter<"TimeSlots"> | Date | string
    date?: DateTimeFilter<"TimeSlots"> | Date | string
    price?: IntFilter<"TimeSlots"> | number
    futsalType?: EnumFutsalTypeFilter<"TimeSlots"> | $Enums.FutsalType
    futsalId?: IntFilter<"TimeSlots"> | number
    futsals?: XOR<FutsalsRelationFilter, FutsalsWhereInput>
  }

  export type TimeSlotsOrderByWithRelationInput = {
    id?: SortOrder
    startTime?: SortOrder
    endTime?: SortOrder
    date?: SortOrder
    price?: SortOrder
    futsalType?: SortOrder
    futsalId?: SortOrder
    futsals?: FutsalsOrderByWithRelationInput
  }

  export type TimeSlotsWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: TimeSlotsWhereInput | TimeSlotsWhereInput[]
    OR?: TimeSlotsWhereInput[]
    NOT?: TimeSlotsWhereInput | TimeSlotsWhereInput[]
    startTime?: DateTimeFilter<"TimeSlots"> | Date | string
    endTime?: DateTimeFilter<"TimeSlots"> | Date | string
    date?: DateTimeFilter<"TimeSlots"> | Date | string
    price?: IntFilter<"TimeSlots"> | number
    futsalType?: EnumFutsalTypeFilter<"TimeSlots"> | $Enums.FutsalType
    futsalId?: IntFilter<"TimeSlots"> | number
    futsals?: XOR<FutsalsRelationFilter, FutsalsWhereInput>
  }, "id">

  export type TimeSlotsOrderByWithAggregationInput = {
    id?: SortOrder
    startTime?: SortOrder
    endTime?: SortOrder
    date?: SortOrder
    price?: SortOrder
    futsalType?: SortOrder
    futsalId?: SortOrder
    _count?: TimeSlotsCountOrderByAggregateInput
    _avg?: TimeSlotsAvgOrderByAggregateInput
    _max?: TimeSlotsMaxOrderByAggregateInput
    _min?: TimeSlotsMinOrderByAggregateInput
    _sum?: TimeSlotsSumOrderByAggregateInput
  }

  export type TimeSlotsScalarWhereWithAggregatesInput = {
    AND?: TimeSlotsScalarWhereWithAggregatesInput | TimeSlotsScalarWhereWithAggregatesInput[]
    OR?: TimeSlotsScalarWhereWithAggregatesInput[]
    NOT?: TimeSlotsScalarWhereWithAggregatesInput | TimeSlotsScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"TimeSlots"> | number
    startTime?: DateTimeWithAggregatesFilter<"TimeSlots"> | Date | string
    endTime?: DateTimeWithAggregatesFilter<"TimeSlots"> | Date | string
    date?: DateTimeWithAggregatesFilter<"TimeSlots"> | Date | string
    price?: IntWithAggregatesFilter<"TimeSlots"> | number
    futsalType?: EnumFutsalTypeWithAggregatesFilter<"TimeSlots"> | $Enums.FutsalType
    futsalId?: IntWithAggregatesFilter<"TimeSlots"> | number
  }

  export type MatchRequestWhereInput = {
    AND?: MatchRequestWhereInput | MatchRequestWhereInput[]
    OR?: MatchRequestWhereInput[]
    NOT?: MatchRequestWhereInput | MatchRequestWhereInput[]
    id?: IntFilter<"MatchRequest"> | number
    userId?: IntFilter<"MatchRequest"> | number
    futsalName?: StringFilter<"MatchRequest"> | string
    futsalType?: EnumFutsalTypeFilter<"MatchRequest"> | $Enums.FutsalType
    matchDate?: DateTimeFilter<"MatchRequest"> | Date | string
    startTime?: DateTimeFilter<"MatchRequest"> | Date | string
    endTime?: DateTimeFilter<"MatchRequest"> | Date | string
    matchType?: StringFilter<"MatchRequest"> | string
    status?: EnumRequestStatusFilter<"MatchRequest"> | $Enums.RequestStatus
    users?: XOR<UsersRelationFilter, UsersWhereInput>
  }

  export type MatchRequestOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    futsalName?: SortOrder
    futsalType?: SortOrder
    matchDate?: SortOrder
    startTime?: SortOrder
    endTime?: SortOrder
    matchType?: SortOrder
    status?: SortOrder
    users?: UsersOrderByWithRelationInput
  }

  export type MatchRequestWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    userId?: number
    AND?: MatchRequestWhereInput | MatchRequestWhereInput[]
    OR?: MatchRequestWhereInput[]
    NOT?: MatchRequestWhereInput | MatchRequestWhereInput[]
    futsalName?: StringFilter<"MatchRequest"> | string
    futsalType?: EnumFutsalTypeFilter<"MatchRequest"> | $Enums.FutsalType
    matchDate?: DateTimeFilter<"MatchRequest"> | Date | string
    startTime?: DateTimeFilter<"MatchRequest"> | Date | string
    endTime?: DateTimeFilter<"MatchRequest"> | Date | string
    matchType?: StringFilter<"MatchRequest"> | string
    status?: EnumRequestStatusFilter<"MatchRequest"> | $Enums.RequestStatus
    users?: XOR<UsersRelationFilter, UsersWhereInput>
  }, "id" | "userId">

  export type MatchRequestOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    futsalName?: SortOrder
    futsalType?: SortOrder
    matchDate?: SortOrder
    startTime?: SortOrder
    endTime?: SortOrder
    matchType?: SortOrder
    status?: SortOrder
    _count?: MatchRequestCountOrderByAggregateInput
    _avg?: MatchRequestAvgOrderByAggregateInput
    _max?: MatchRequestMaxOrderByAggregateInput
    _min?: MatchRequestMinOrderByAggregateInput
    _sum?: MatchRequestSumOrderByAggregateInput
  }

  export type MatchRequestScalarWhereWithAggregatesInput = {
    AND?: MatchRequestScalarWhereWithAggregatesInput | MatchRequestScalarWhereWithAggregatesInput[]
    OR?: MatchRequestScalarWhereWithAggregatesInput[]
    NOT?: MatchRequestScalarWhereWithAggregatesInput | MatchRequestScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"MatchRequest"> | number
    userId?: IntWithAggregatesFilter<"MatchRequest"> | number
    futsalName?: StringWithAggregatesFilter<"MatchRequest"> | string
    futsalType?: EnumFutsalTypeWithAggregatesFilter<"MatchRequest"> | $Enums.FutsalType
    matchDate?: DateTimeWithAggregatesFilter<"MatchRequest"> | Date | string
    startTime?: DateTimeWithAggregatesFilter<"MatchRequest"> | Date | string
    endTime?: DateTimeWithAggregatesFilter<"MatchRequest"> | Date | string
    matchType?: StringWithAggregatesFilter<"MatchRequest"> | string
    status?: EnumRequestStatusWithAggregatesFilter<"MatchRequest"> | $Enums.RequestStatus
  }

  export type MatchesWhereInput = {
    AND?: MatchesWhereInput | MatchesWhereInput[]
    OR?: MatchesWhereInput[]
    NOT?: MatchesWhereInput | MatchesWhereInput[]
    id?: IntFilter<"Matches"> | number
    futsalName?: StringFilter<"Matches"> | string
    futsalType?: EnumFutsalTypeFilter<"Matches"> | $Enums.FutsalType
    matchType?: StringFilter<"Matches"> | string
    matchDate?: DateTimeFilter<"Matches"> | Date | string
    startTime?: DateTimeFilter<"Matches"> | Date | string
    endTime?: DateTimeFilter<"Matches"> | Date | string
    status?: EnumMatchStatusFilter<"Matches"> | $Enums.MatchStatus
    organizerId?: IntFilter<"Matches"> | number
    opponentId?: IntFilter<"Matches"> | number
    organizer?: XOR<UsersRelationFilter, UsersWhereInput>
    opponent?: XOR<UsersRelationFilter, UsersWhereInput>
  }

  export type MatchesOrderByWithRelationInput = {
    id?: SortOrder
    futsalName?: SortOrder
    futsalType?: SortOrder
    matchType?: SortOrder
    matchDate?: SortOrder
    startTime?: SortOrder
    endTime?: SortOrder
    status?: SortOrder
    organizerId?: SortOrder
    opponentId?: SortOrder
    organizer?: UsersOrderByWithRelationInput
    opponent?: UsersOrderByWithRelationInput
  }

  export type MatchesWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    organizerId?: number
    opponentId?: number
    AND?: MatchesWhereInput | MatchesWhereInput[]
    OR?: MatchesWhereInput[]
    NOT?: MatchesWhereInput | MatchesWhereInput[]
    futsalName?: StringFilter<"Matches"> | string
    futsalType?: EnumFutsalTypeFilter<"Matches"> | $Enums.FutsalType
    matchType?: StringFilter<"Matches"> | string
    matchDate?: DateTimeFilter<"Matches"> | Date | string
    startTime?: DateTimeFilter<"Matches"> | Date | string
    endTime?: DateTimeFilter<"Matches"> | Date | string
    status?: EnumMatchStatusFilter<"Matches"> | $Enums.MatchStatus
    organizer?: XOR<UsersRelationFilter, UsersWhereInput>
    opponent?: XOR<UsersRelationFilter, UsersWhereInput>
  }, "id" | "organizerId" | "opponentId">

  export type MatchesOrderByWithAggregationInput = {
    id?: SortOrder
    futsalName?: SortOrder
    futsalType?: SortOrder
    matchType?: SortOrder
    matchDate?: SortOrder
    startTime?: SortOrder
    endTime?: SortOrder
    status?: SortOrder
    organizerId?: SortOrder
    opponentId?: SortOrder
    _count?: MatchesCountOrderByAggregateInput
    _avg?: MatchesAvgOrderByAggregateInput
    _max?: MatchesMaxOrderByAggregateInput
    _min?: MatchesMinOrderByAggregateInput
    _sum?: MatchesSumOrderByAggregateInput
  }

  export type MatchesScalarWhereWithAggregatesInput = {
    AND?: MatchesScalarWhereWithAggregatesInput | MatchesScalarWhereWithAggregatesInput[]
    OR?: MatchesScalarWhereWithAggregatesInput[]
    NOT?: MatchesScalarWhereWithAggregatesInput | MatchesScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Matches"> | number
    futsalName?: StringWithAggregatesFilter<"Matches"> | string
    futsalType?: EnumFutsalTypeWithAggregatesFilter<"Matches"> | $Enums.FutsalType
    matchType?: StringWithAggregatesFilter<"Matches"> | string
    matchDate?: DateTimeWithAggregatesFilter<"Matches"> | Date | string
    startTime?: DateTimeWithAggregatesFilter<"Matches"> | Date | string
    endTime?: DateTimeWithAggregatesFilter<"Matches"> | Date | string
    status?: EnumMatchStatusWithAggregatesFilter<"Matches"> | $Enums.MatchStatus
    organizerId?: IntWithAggregatesFilter<"Matches"> | number
    opponentId?: IntWithAggregatesFilter<"Matches"> | number
  }

  export type RolesCreateInput = {
    title: string
    Users?: UsersCreateNestedManyWithoutRolesInput
  }

  export type RolesUncheckedCreateInput = {
    id?: number
    title: string
    Users?: UsersUncheckedCreateNestedManyWithoutRolesInput
  }

  export type RolesUpdateInput = {
    title?: StringFieldUpdateOperationsInput | string
    Users?: UsersUpdateManyWithoutRolesNestedInput
  }

  export type RolesUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    Users?: UsersUncheckedUpdateManyWithoutRolesNestedInput
  }

  export type RolesCreateManyInput = {
    id?: number
    title: string
  }

  export type RolesUpdateManyMutationInput = {
    title?: StringFieldUpdateOperationsInput | string
  }

  export type RolesUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
  }

  export type UsersCreateInput = {
    googleId?: string | null
    facebookId?: string | null
    name: string
    email: string
    phone: string
    image?: string | null
    password: string
    address: string
    roles: RolesCreateNestedOneWithoutUsersInput
    Futsals?: FutsalsCreateNestedOneWithoutUsersInput
    Bookings?: BookingsCreateNestedManyWithoutUsersInput
    MatchRequest?: MatchRequestCreateNestedOneWithoutUsersInput
    organizedMatches?: MatchesCreateNestedManyWithoutOrganizerInput
    opponentMatches?: MatchesCreateNestedManyWithoutOpponentInput
  }

  export type UsersUncheckedCreateInput = {
    id?: number
    googleId?: string | null
    facebookId?: string | null
    name: string
    email: string
    phone: string
    image?: string | null
    password: string
    address: string
    roleId: number
    Futsals?: FutsalsUncheckedCreateNestedOneWithoutUsersInput
    Bookings?: BookingsUncheckedCreateNestedManyWithoutUsersInput
    MatchRequest?: MatchRequestUncheckedCreateNestedOneWithoutUsersInput
    organizedMatches?: MatchesUncheckedCreateNestedManyWithoutOrganizerInput
    opponentMatches?: MatchesUncheckedCreateNestedManyWithoutOpponentInput
  }

  export type UsersUpdateInput = {
    googleId?: NullableStringFieldUpdateOperationsInput | string | null
    facebookId?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    image?: NullableStringFieldUpdateOperationsInput | string | null
    password?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    roles?: RolesUpdateOneRequiredWithoutUsersNestedInput
    Futsals?: FutsalsUpdateOneWithoutUsersNestedInput
    Bookings?: BookingsUpdateManyWithoutUsersNestedInput
    MatchRequest?: MatchRequestUpdateOneWithoutUsersNestedInput
    organizedMatches?: MatchesUpdateManyWithoutOrganizerNestedInput
    opponentMatches?: MatchesUpdateManyWithoutOpponentNestedInput
  }

  export type UsersUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    googleId?: NullableStringFieldUpdateOperationsInput | string | null
    facebookId?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    image?: NullableStringFieldUpdateOperationsInput | string | null
    password?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    roleId?: IntFieldUpdateOperationsInput | number
    Futsals?: FutsalsUncheckedUpdateOneWithoutUsersNestedInput
    Bookings?: BookingsUncheckedUpdateManyWithoutUsersNestedInput
    MatchRequest?: MatchRequestUncheckedUpdateOneWithoutUsersNestedInput
    organizedMatches?: MatchesUncheckedUpdateManyWithoutOrganizerNestedInput
    opponentMatches?: MatchesUncheckedUpdateManyWithoutOpponentNestedInput
  }

  export type UsersCreateManyInput = {
    id?: number
    googleId?: string | null
    facebookId?: string | null
    name: string
    email: string
    phone: string
    image?: string | null
    password: string
    address: string
    roleId: number
  }

  export type UsersUpdateManyMutationInput = {
    googleId?: NullableStringFieldUpdateOperationsInput | string | null
    facebookId?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    image?: NullableStringFieldUpdateOperationsInput | string | null
    password?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
  }

  export type UsersUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    googleId?: NullableStringFieldUpdateOperationsInput | string | null
    facebookId?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    image?: NullableStringFieldUpdateOperationsInput | string | null
    password?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    roleId?: IntFieldUpdateOperationsInput | number
  }

  export type FutsalsCreateInput = {
    name: string
    phone: string
    address: string
    type: $Enums.FutsalType
    startTime: Date | string
    endTime: Date | string
    amenities?: FutsalsCreateamenitiesInput | string[]
    stdPrice: number
    rating: Decimal | DecimalJsLike | number | string
    pan: string
    images?: FutsalImageCreateNestedManyWithoutFutsalInput
    users: UsersCreateNestedOneWithoutFutsalsInput
    PriceLists?: PriceListsCreateNestedManyWithoutFutsalsInput
    Bookings?: BookingsCreateNestedManyWithoutFutsalsInput
    timeSlots?: TimeSlotsCreateNestedManyWithoutFutsalsInput
  }

  export type FutsalsUncheckedCreateInput = {
    id?: number
    name: string
    phone: string
    address: string
    type: $Enums.FutsalType
    startTime: Date | string
    endTime: Date | string
    amenities?: FutsalsCreateamenitiesInput | string[]
    stdPrice: number
    rating: Decimal | DecimalJsLike | number | string
    pan: string
    userId: number
    images?: FutsalImageUncheckedCreateNestedManyWithoutFutsalInput
    PriceLists?: PriceListsUncheckedCreateNestedManyWithoutFutsalsInput
    Bookings?: BookingsUncheckedCreateNestedManyWithoutFutsalsInput
    timeSlots?: TimeSlotsUncheckedCreateNestedManyWithoutFutsalsInput
  }

  export type FutsalsUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    type?: EnumFutsalTypeFieldUpdateOperationsInput | $Enums.FutsalType
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: DateTimeFieldUpdateOperationsInput | Date | string
    amenities?: FutsalsUpdateamenitiesInput | string[]
    stdPrice?: IntFieldUpdateOperationsInput | number
    rating?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    pan?: StringFieldUpdateOperationsInput | string
    images?: FutsalImageUpdateManyWithoutFutsalNestedInput
    users?: UsersUpdateOneRequiredWithoutFutsalsNestedInput
    PriceLists?: PriceListsUpdateManyWithoutFutsalsNestedInput
    Bookings?: BookingsUpdateManyWithoutFutsalsNestedInput
    timeSlots?: TimeSlotsUpdateManyWithoutFutsalsNestedInput
  }

  export type FutsalsUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    type?: EnumFutsalTypeFieldUpdateOperationsInput | $Enums.FutsalType
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: DateTimeFieldUpdateOperationsInput | Date | string
    amenities?: FutsalsUpdateamenitiesInput | string[]
    stdPrice?: IntFieldUpdateOperationsInput | number
    rating?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    pan?: StringFieldUpdateOperationsInput | string
    userId?: IntFieldUpdateOperationsInput | number
    images?: FutsalImageUncheckedUpdateManyWithoutFutsalNestedInput
    PriceLists?: PriceListsUncheckedUpdateManyWithoutFutsalsNestedInput
    Bookings?: BookingsUncheckedUpdateManyWithoutFutsalsNestedInput
    timeSlots?: TimeSlotsUncheckedUpdateManyWithoutFutsalsNestedInput
  }

  export type FutsalsCreateManyInput = {
    id?: number
    name: string
    phone: string
    address: string
    type: $Enums.FutsalType
    startTime: Date | string
    endTime: Date | string
    amenities?: FutsalsCreateamenitiesInput | string[]
    stdPrice: number
    rating: Decimal | DecimalJsLike | number | string
    pan: string
    userId: number
  }

  export type FutsalsUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    type?: EnumFutsalTypeFieldUpdateOperationsInput | $Enums.FutsalType
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: DateTimeFieldUpdateOperationsInput | Date | string
    amenities?: FutsalsUpdateamenitiesInput | string[]
    stdPrice?: IntFieldUpdateOperationsInput | number
    rating?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    pan?: StringFieldUpdateOperationsInput | string
  }

  export type FutsalsUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    type?: EnumFutsalTypeFieldUpdateOperationsInput | $Enums.FutsalType
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: DateTimeFieldUpdateOperationsInput | Date | string
    amenities?: FutsalsUpdateamenitiesInput | string[]
    stdPrice?: IntFieldUpdateOperationsInput | number
    rating?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    pan?: StringFieldUpdateOperationsInput | string
    userId?: IntFieldUpdateOperationsInput | number
  }

  export type FutsalImageCreateInput = {
    url: string
    futsal: FutsalsCreateNestedOneWithoutImagesInput
  }

  export type FutsalImageUncheckedCreateInput = {
    id?: number
    url: string
    futsalId: number
  }

  export type FutsalImageUpdateInput = {
    url?: StringFieldUpdateOperationsInput | string
    futsal?: FutsalsUpdateOneRequiredWithoutImagesNestedInput
  }

  export type FutsalImageUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    url?: StringFieldUpdateOperationsInput | string
    futsalId?: IntFieldUpdateOperationsInput | number
  }

  export type FutsalImageCreateManyInput = {
    id?: number
    url: string
    futsalId: number
  }

  export type FutsalImageUpdateManyMutationInput = {
    url?: StringFieldUpdateOperationsInput | string
  }

  export type FutsalImageUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    url?: StringFieldUpdateOperationsInput | string
    futsalId?: IntFieldUpdateOperationsInput | number
  }

  export type PriceListsCreateInput = {
    startTime: Date | string
    endTime: Date | string
    dayOfWeek: string
    price: number
    futsals: FutsalsCreateNestedOneWithoutPriceListsInput
  }

  export type PriceListsUncheckedCreateInput = {
    id?: number
    startTime: Date | string
    endTime: Date | string
    dayOfWeek: string
    price: number
    futsalId: number
  }

  export type PriceListsUpdateInput = {
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: DateTimeFieldUpdateOperationsInput | Date | string
    dayOfWeek?: StringFieldUpdateOperationsInput | string
    price?: IntFieldUpdateOperationsInput | number
    futsals?: FutsalsUpdateOneRequiredWithoutPriceListsNestedInput
  }

  export type PriceListsUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: DateTimeFieldUpdateOperationsInput | Date | string
    dayOfWeek?: StringFieldUpdateOperationsInput | string
    price?: IntFieldUpdateOperationsInput | number
    futsalId?: IntFieldUpdateOperationsInput | number
  }

  export type PriceListsCreateManyInput = {
    id?: number
    startTime: Date | string
    endTime: Date | string
    dayOfWeek: string
    price: number
    futsalId: number
  }

  export type PriceListsUpdateManyMutationInput = {
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: DateTimeFieldUpdateOperationsInput | Date | string
    dayOfWeek?: StringFieldUpdateOperationsInput | string
    price?: IntFieldUpdateOperationsInput | number
  }

  export type PriceListsUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: DateTimeFieldUpdateOperationsInput | Date | string
    dayOfWeek?: StringFieldUpdateOperationsInput | string
    price?: IntFieldUpdateOperationsInput | number
    futsalId?: IntFieldUpdateOperationsInput | number
  }

  export type BookingsCreateInput = {
    bookDate: Date | string
    startTime: Date | string
    endTime: Date | string
    type: $Enums.FutsalType
    price: number
    confirmation?: $Enums.BookingStatus
    paymentStatus?: $Enums.Payment
    users: UsersCreateNestedOneWithoutBookingsInput
    futsals: FutsalsCreateNestedOneWithoutBookingsInput
  }

  export type BookingsUncheckedCreateInput = {
    id?: number
    userId: number
    futsalId: number
    bookDate: Date | string
    startTime: Date | string
    endTime: Date | string
    type: $Enums.FutsalType
    price: number
    confirmation?: $Enums.BookingStatus
    paymentStatus?: $Enums.Payment
  }

  export type BookingsUpdateInput = {
    bookDate?: DateTimeFieldUpdateOperationsInput | Date | string
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: DateTimeFieldUpdateOperationsInput | Date | string
    type?: EnumFutsalTypeFieldUpdateOperationsInput | $Enums.FutsalType
    price?: IntFieldUpdateOperationsInput | number
    confirmation?: EnumBookingStatusFieldUpdateOperationsInput | $Enums.BookingStatus
    paymentStatus?: EnumPaymentFieldUpdateOperationsInput | $Enums.Payment
    users?: UsersUpdateOneRequiredWithoutBookingsNestedInput
    futsals?: FutsalsUpdateOneRequiredWithoutBookingsNestedInput
  }

  export type BookingsUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    futsalId?: IntFieldUpdateOperationsInput | number
    bookDate?: DateTimeFieldUpdateOperationsInput | Date | string
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: DateTimeFieldUpdateOperationsInput | Date | string
    type?: EnumFutsalTypeFieldUpdateOperationsInput | $Enums.FutsalType
    price?: IntFieldUpdateOperationsInput | number
    confirmation?: EnumBookingStatusFieldUpdateOperationsInput | $Enums.BookingStatus
    paymentStatus?: EnumPaymentFieldUpdateOperationsInput | $Enums.Payment
  }

  export type BookingsCreateManyInput = {
    id?: number
    userId: number
    futsalId: number
    bookDate: Date | string
    startTime: Date | string
    endTime: Date | string
    type: $Enums.FutsalType
    price: number
    confirmation?: $Enums.BookingStatus
    paymentStatus?: $Enums.Payment
  }

  export type BookingsUpdateManyMutationInput = {
    bookDate?: DateTimeFieldUpdateOperationsInput | Date | string
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: DateTimeFieldUpdateOperationsInput | Date | string
    type?: EnumFutsalTypeFieldUpdateOperationsInput | $Enums.FutsalType
    price?: IntFieldUpdateOperationsInput | number
    confirmation?: EnumBookingStatusFieldUpdateOperationsInput | $Enums.BookingStatus
    paymentStatus?: EnumPaymentFieldUpdateOperationsInput | $Enums.Payment
  }

  export type BookingsUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    futsalId?: IntFieldUpdateOperationsInput | number
    bookDate?: DateTimeFieldUpdateOperationsInput | Date | string
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: DateTimeFieldUpdateOperationsInput | Date | string
    type?: EnumFutsalTypeFieldUpdateOperationsInput | $Enums.FutsalType
    price?: IntFieldUpdateOperationsInput | number
    confirmation?: EnumBookingStatusFieldUpdateOperationsInput | $Enums.BookingStatus
    paymentStatus?: EnumPaymentFieldUpdateOperationsInput | $Enums.Payment
  }

  export type TimeSlotsCreateInput = {
    startTime: Date | string
    endTime: Date | string
    date: Date | string
    price: number
    futsalType: $Enums.FutsalType
    futsals: FutsalsCreateNestedOneWithoutTimeSlotsInput
  }

  export type TimeSlotsUncheckedCreateInput = {
    id?: number
    startTime: Date | string
    endTime: Date | string
    date: Date | string
    price: number
    futsalType: $Enums.FutsalType
    futsalId: number
  }

  export type TimeSlotsUpdateInput = {
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: DateTimeFieldUpdateOperationsInput | Date | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    price?: IntFieldUpdateOperationsInput | number
    futsalType?: EnumFutsalTypeFieldUpdateOperationsInput | $Enums.FutsalType
    futsals?: FutsalsUpdateOneRequiredWithoutTimeSlotsNestedInput
  }

  export type TimeSlotsUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: DateTimeFieldUpdateOperationsInput | Date | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    price?: IntFieldUpdateOperationsInput | number
    futsalType?: EnumFutsalTypeFieldUpdateOperationsInput | $Enums.FutsalType
    futsalId?: IntFieldUpdateOperationsInput | number
  }

  export type TimeSlotsCreateManyInput = {
    id?: number
    startTime: Date | string
    endTime: Date | string
    date: Date | string
    price: number
    futsalType: $Enums.FutsalType
    futsalId: number
  }

  export type TimeSlotsUpdateManyMutationInput = {
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: DateTimeFieldUpdateOperationsInput | Date | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    price?: IntFieldUpdateOperationsInput | number
    futsalType?: EnumFutsalTypeFieldUpdateOperationsInput | $Enums.FutsalType
  }

  export type TimeSlotsUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: DateTimeFieldUpdateOperationsInput | Date | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    price?: IntFieldUpdateOperationsInput | number
    futsalType?: EnumFutsalTypeFieldUpdateOperationsInput | $Enums.FutsalType
    futsalId?: IntFieldUpdateOperationsInput | number
  }

  export type MatchRequestCreateInput = {
    futsalName: string
    futsalType: $Enums.FutsalType
    matchDate: Date | string
    startTime: Date | string
    endTime: Date | string
    matchType: string
    status?: $Enums.RequestStatus
    users: UsersCreateNestedOneWithoutMatchRequestInput
  }

  export type MatchRequestUncheckedCreateInput = {
    id?: number
    userId: number
    futsalName: string
    futsalType: $Enums.FutsalType
    matchDate: Date | string
    startTime: Date | string
    endTime: Date | string
    matchType: string
    status?: $Enums.RequestStatus
  }

  export type MatchRequestUpdateInput = {
    futsalName?: StringFieldUpdateOperationsInput | string
    futsalType?: EnumFutsalTypeFieldUpdateOperationsInput | $Enums.FutsalType
    matchDate?: DateTimeFieldUpdateOperationsInput | Date | string
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: DateTimeFieldUpdateOperationsInput | Date | string
    matchType?: StringFieldUpdateOperationsInput | string
    status?: EnumRequestStatusFieldUpdateOperationsInput | $Enums.RequestStatus
    users?: UsersUpdateOneRequiredWithoutMatchRequestNestedInput
  }

  export type MatchRequestUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    futsalName?: StringFieldUpdateOperationsInput | string
    futsalType?: EnumFutsalTypeFieldUpdateOperationsInput | $Enums.FutsalType
    matchDate?: DateTimeFieldUpdateOperationsInput | Date | string
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: DateTimeFieldUpdateOperationsInput | Date | string
    matchType?: StringFieldUpdateOperationsInput | string
    status?: EnumRequestStatusFieldUpdateOperationsInput | $Enums.RequestStatus
  }

  export type MatchRequestCreateManyInput = {
    id?: number
    userId: number
    futsalName: string
    futsalType: $Enums.FutsalType
    matchDate: Date | string
    startTime: Date | string
    endTime: Date | string
    matchType: string
    status?: $Enums.RequestStatus
  }

  export type MatchRequestUpdateManyMutationInput = {
    futsalName?: StringFieldUpdateOperationsInput | string
    futsalType?: EnumFutsalTypeFieldUpdateOperationsInput | $Enums.FutsalType
    matchDate?: DateTimeFieldUpdateOperationsInput | Date | string
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: DateTimeFieldUpdateOperationsInput | Date | string
    matchType?: StringFieldUpdateOperationsInput | string
    status?: EnumRequestStatusFieldUpdateOperationsInput | $Enums.RequestStatus
  }

  export type MatchRequestUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    futsalName?: StringFieldUpdateOperationsInput | string
    futsalType?: EnumFutsalTypeFieldUpdateOperationsInput | $Enums.FutsalType
    matchDate?: DateTimeFieldUpdateOperationsInput | Date | string
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: DateTimeFieldUpdateOperationsInput | Date | string
    matchType?: StringFieldUpdateOperationsInput | string
    status?: EnumRequestStatusFieldUpdateOperationsInput | $Enums.RequestStatus
  }

  export type MatchesCreateInput = {
    futsalName: string
    futsalType: $Enums.FutsalType
    matchType: string
    matchDate: Date | string
    startTime: Date | string
    endTime: Date | string
    status?: $Enums.MatchStatus
    organizer: UsersCreateNestedOneWithoutOrganizedMatchesInput
    opponent: UsersCreateNestedOneWithoutOpponentMatchesInput
  }

  export type MatchesUncheckedCreateInput = {
    id?: number
    futsalName: string
    futsalType: $Enums.FutsalType
    matchType: string
    matchDate: Date | string
    startTime: Date | string
    endTime: Date | string
    status?: $Enums.MatchStatus
    organizerId: number
    opponentId: number
  }

  export type MatchesUpdateInput = {
    futsalName?: StringFieldUpdateOperationsInput | string
    futsalType?: EnumFutsalTypeFieldUpdateOperationsInput | $Enums.FutsalType
    matchType?: StringFieldUpdateOperationsInput | string
    matchDate?: DateTimeFieldUpdateOperationsInput | Date | string
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumMatchStatusFieldUpdateOperationsInput | $Enums.MatchStatus
    organizer?: UsersUpdateOneRequiredWithoutOrganizedMatchesNestedInput
    opponent?: UsersUpdateOneRequiredWithoutOpponentMatchesNestedInput
  }

  export type MatchesUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    futsalName?: StringFieldUpdateOperationsInput | string
    futsalType?: EnumFutsalTypeFieldUpdateOperationsInput | $Enums.FutsalType
    matchType?: StringFieldUpdateOperationsInput | string
    matchDate?: DateTimeFieldUpdateOperationsInput | Date | string
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumMatchStatusFieldUpdateOperationsInput | $Enums.MatchStatus
    organizerId?: IntFieldUpdateOperationsInput | number
    opponentId?: IntFieldUpdateOperationsInput | number
  }

  export type MatchesCreateManyInput = {
    id?: number
    futsalName: string
    futsalType: $Enums.FutsalType
    matchType: string
    matchDate: Date | string
    startTime: Date | string
    endTime: Date | string
    status?: $Enums.MatchStatus
    organizerId: number
    opponentId: number
  }

  export type MatchesUpdateManyMutationInput = {
    futsalName?: StringFieldUpdateOperationsInput | string
    futsalType?: EnumFutsalTypeFieldUpdateOperationsInput | $Enums.FutsalType
    matchType?: StringFieldUpdateOperationsInput | string
    matchDate?: DateTimeFieldUpdateOperationsInput | Date | string
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumMatchStatusFieldUpdateOperationsInput | $Enums.MatchStatus
  }

  export type MatchesUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    futsalName?: StringFieldUpdateOperationsInput | string
    futsalType?: EnumFutsalTypeFieldUpdateOperationsInput | $Enums.FutsalType
    matchType?: StringFieldUpdateOperationsInput | string
    matchDate?: DateTimeFieldUpdateOperationsInput | Date | string
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumMatchStatusFieldUpdateOperationsInput | $Enums.MatchStatus
    organizerId?: IntFieldUpdateOperationsInput | number
    opponentId?: IntFieldUpdateOperationsInput | number
  }

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type UsersListRelationFilter = {
    every?: UsersWhereInput
    some?: UsersWhereInput
    none?: UsersWhereInput
  }

  export type UsersOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type RolesCountOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
  }

  export type RolesAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type RolesMaxOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
  }

  export type RolesMinOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
  }

  export type RolesSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type RolesRelationFilter = {
    is?: RolesWhereInput
    isNot?: RolesWhereInput
  }

  export type FutsalsNullableRelationFilter = {
    is?: FutsalsWhereInput | null
    isNot?: FutsalsWhereInput | null
  }

  export type BookingsListRelationFilter = {
    every?: BookingsWhereInput
    some?: BookingsWhereInput
    none?: BookingsWhereInput
  }

  export type MatchRequestNullableRelationFilter = {
    is?: MatchRequestWhereInput | null
    isNot?: MatchRequestWhereInput | null
  }

  export type MatchesListRelationFilter = {
    every?: MatchesWhereInput
    some?: MatchesWhereInput
    none?: MatchesWhereInput
  }

  export type SortOrderInput = {
    sort: SortOrder
    nulls?: NullsOrder
  }

  export type BookingsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type MatchesOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UsersCountOrderByAggregateInput = {
    id?: SortOrder
    googleId?: SortOrder
    facebookId?: SortOrder
    name?: SortOrder
    email?: SortOrder
    phone?: SortOrder
    image?: SortOrder
    password?: SortOrder
    address?: SortOrder
    roleId?: SortOrder
  }

  export type UsersAvgOrderByAggregateInput = {
    id?: SortOrder
    roleId?: SortOrder
  }

  export type UsersMaxOrderByAggregateInput = {
    id?: SortOrder
    googleId?: SortOrder
    facebookId?: SortOrder
    name?: SortOrder
    email?: SortOrder
    phone?: SortOrder
    image?: SortOrder
    password?: SortOrder
    address?: SortOrder
    roleId?: SortOrder
  }

  export type UsersMinOrderByAggregateInput = {
    id?: SortOrder
    googleId?: SortOrder
    facebookId?: SortOrder
    name?: SortOrder
    email?: SortOrder
    phone?: SortOrder
    image?: SortOrder
    password?: SortOrder
    address?: SortOrder
    roleId?: SortOrder
  }

  export type UsersSumOrderByAggregateInput = {
    id?: SortOrder
    roleId?: SortOrder
  }

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type EnumFutsalTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.FutsalType | EnumFutsalTypeFieldRefInput<$PrismaModel>
    in?: $Enums.FutsalType[] | ListEnumFutsalTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.FutsalType[] | ListEnumFutsalTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumFutsalTypeFilter<$PrismaModel> | $Enums.FutsalType
  }

  export type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type StringNullableListFilter<$PrismaModel = never> = {
    equals?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    has?: string | StringFieldRefInput<$PrismaModel> | null
    hasEvery?: string[] | ListStringFieldRefInput<$PrismaModel>
    hasSome?: string[] | ListStringFieldRefInput<$PrismaModel>
    isEmpty?: boolean
  }

  export type DecimalFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
  }

  export type FutsalImageListRelationFilter = {
    every?: FutsalImageWhereInput
    some?: FutsalImageWhereInput
    none?: FutsalImageWhereInput
  }

  export type UsersRelationFilter = {
    is?: UsersWhereInput
    isNot?: UsersWhereInput
  }

  export type PriceListsListRelationFilter = {
    every?: PriceListsWhereInput
    some?: PriceListsWhereInput
    none?: PriceListsWhereInput
  }

  export type TimeSlotsListRelationFilter = {
    every?: TimeSlotsWhereInput
    some?: TimeSlotsWhereInput
    none?: TimeSlotsWhereInput
  }

  export type FutsalImageOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PriceListsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type TimeSlotsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type FutsalsCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    phone?: SortOrder
    address?: SortOrder
    type?: SortOrder
    startTime?: SortOrder
    endTime?: SortOrder
    amenities?: SortOrder
    stdPrice?: SortOrder
    rating?: SortOrder
    pan?: SortOrder
    userId?: SortOrder
  }

  export type FutsalsAvgOrderByAggregateInput = {
    id?: SortOrder
    stdPrice?: SortOrder
    rating?: SortOrder
    userId?: SortOrder
  }

  export type FutsalsMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    phone?: SortOrder
    address?: SortOrder
    type?: SortOrder
    startTime?: SortOrder
    endTime?: SortOrder
    stdPrice?: SortOrder
    rating?: SortOrder
    pan?: SortOrder
    userId?: SortOrder
  }

  export type FutsalsMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    phone?: SortOrder
    address?: SortOrder
    type?: SortOrder
    startTime?: SortOrder
    endTime?: SortOrder
    stdPrice?: SortOrder
    rating?: SortOrder
    pan?: SortOrder
    userId?: SortOrder
  }

  export type FutsalsSumOrderByAggregateInput = {
    id?: SortOrder
    stdPrice?: SortOrder
    rating?: SortOrder
    userId?: SortOrder
  }

  export type EnumFutsalTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.FutsalType | EnumFutsalTypeFieldRefInput<$PrismaModel>
    in?: $Enums.FutsalType[] | ListEnumFutsalTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.FutsalType[] | ListEnumFutsalTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumFutsalTypeWithAggregatesFilter<$PrismaModel> | $Enums.FutsalType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumFutsalTypeFilter<$PrismaModel>
    _max?: NestedEnumFutsalTypeFilter<$PrismaModel>
  }

  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type DecimalWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalWithAggregatesFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedDecimalFilter<$PrismaModel>
    _sum?: NestedDecimalFilter<$PrismaModel>
    _min?: NestedDecimalFilter<$PrismaModel>
    _max?: NestedDecimalFilter<$PrismaModel>
  }

  export type FutsalsRelationFilter = {
    is?: FutsalsWhereInput
    isNot?: FutsalsWhereInput
  }

  export type FutsalImageCountOrderByAggregateInput = {
    id?: SortOrder
    url?: SortOrder
    futsalId?: SortOrder
  }

  export type FutsalImageAvgOrderByAggregateInput = {
    id?: SortOrder
    futsalId?: SortOrder
  }

  export type FutsalImageMaxOrderByAggregateInput = {
    id?: SortOrder
    url?: SortOrder
    futsalId?: SortOrder
  }

  export type FutsalImageMinOrderByAggregateInput = {
    id?: SortOrder
    url?: SortOrder
    futsalId?: SortOrder
  }

  export type FutsalImageSumOrderByAggregateInput = {
    id?: SortOrder
    futsalId?: SortOrder
  }

  export type PriceListsCountOrderByAggregateInput = {
    id?: SortOrder
    startTime?: SortOrder
    endTime?: SortOrder
    dayOfWeek?: SortOrder
    price?: SortOrder
    futsalId?: SortOrder
  }

  export type PriceListsAvgOrderByAggregateInput = {
    id?: SortOrder
    price?: SortOrder
    futsalId?: SortOrder
  }

  export type PriceListsMaxOrderByAggregateInput = {
    id?: SortOrder
    startTime?: SortOrder
    endTime?: SortOrder
    dayOfWeek?: SortOrder
    price?: SortOrder
    futsalId?: SortOrder
  }

  export type PriceListsMinOrderByAggregateInput = {
    id?: SortOrder
    startTime?: SortOrder
    endTime?: SortOrder
    dayOfWeek?: SortOrder
    price?: SortOrder
    futsalId?: SortOrder
  }

  export type PriceListsSumOrderByAggregateInput = {
    id?: SortOrder
    price?: SortOrder
    futsalId?: SortOrder
  }

  export type EnumBookingStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.BookingStatus | EnumBookingStatusFieldRefInput<$PrismaModel>
    in?: $Enums.BookingStatus[] | ListEnumBookingStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.BookingStatus[] | ListEnumBookingStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumBookingStatusFilter<$PrismaModel> | $Enums.BookingStatus
  }

  export type EnumPaymentFilter<$PrismaModel = never> = {
    equals?: $Enums.Payment | EnumPaymentFieldRefInput<$PrismaModel>
    in?: $Enums.Payment[] | ListEnumPaymentFieldRefInput<$PrismaModel>
    notIn?: $Enums.Payment[] | ListEnumPaymentFieldRefInput<$PrismaModel>
    not?: NestedEnumPaymentFilter<$PrismaModel> | $Enums.Payment
  }

  export type BookingsCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    futsalId?: SortOrder
    bookDate?: SortOrder
    startTime?: SortOrder
    endTime?: SortOrder
    type?: SortOrder
    price?: SortOrder
    confirmation?: SortOrder
    paymentStatus?: SortOrder
  }

  export type BookingsAvgOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    futsalId?: SortOrder
    price?: SortOrder
  }

  export type BookingsMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    futsalId?: SortOrder
    bookDate?: SortOrder
    startTime?: SortOrder
    endTime?: SortOrder
    type?: SortOrder
    price?: SortOrder
    confirmation?: SortOrder
    paymentStatus?: SortOrder
  }

  export type BookingsMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    futsalId?: SortOrder
    bookDate?: SortOrder
    startTime?: SortOrder
    endTime?: SortOrder
    type?: SortOrder
    price?: SortOrder
    confirmation?: SortOrder
    paymentStatus?: SortOrder
  }

  export type BookingsSumOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    futsalId?: SortOrder
    price?: SortOrder
  }

  export type EnumBookingStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.BookingStatus | EnumBookingStatusFieldRefInput<$PrismaModel>
    in?: $Enums.BookingStatus[] | ListEnumBookingStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.BookingStatus[] | ListEnumBookingStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumBookingStatusWithAggregatesFilter<$PrismaModel> | $Enums.BookingStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumBookingStatusFilter<$PrismaModel>
    _max?: NestedEnumBookingStatusFilter<$PrismaModel>
  }

  export type EnumPaymentWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Payment | EnumPaymentFieldRefInput<$PrismaModel>
    in?: $Enums.Payment[] | ListEnumPaymentFieldRefInput<$PrismaModel>
    notIn?: $Enums.Payment[] | ListEnumPaymentFieldRefInput<$PrismaModel>
    not?: NestedEnumPaymentWithAggregatesFilter<$PrismaModel> | $Enums.Payment
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumPaymentFilter<$PrismaModel>
    _max?: NestedEnumPaymentFilter<$PrismaModel>
  }

  export type TimeSlotsCountOrderByAggregateInput = {
    id?: SortOrder
    startTime?: SortOrder
    endTime?: SortOrder
    date?: SortOrder
    price?: SortOrder
    futsalType?: SortOrder
    futsalId?: SortOrder
  }

  export type TimeSlotsAvgOrderByAggregateInput = {
    id?: SortOrder
    price?: SortOrder
    futsalId?: SortOrder
  }

  export type TimeSlotsMaxOrderByAggregateInput = {
    id?: SortOrder
    startTime?: SortOrder
    endTime?: SortOrder
    date?: SortOrder
    price?: SortOrder
    futsalType?: SortOrder
    futsalId?: SortOrder
  }

  export type TimeSlotsMinOrderByAggregateInput = {
    id?: SortOrder
    startTime?: SortOrder
    endTime?: SortOrder
    date?: SortOrder
    price?: SortOrder
    futsalType?: SortOrder
    futsalId?: SortOrder
  }

  export type TimeSlotsSumOrderByAggregateInput = {
    id?: SortOrder
    price?: SortOrder
    futsalId?: SortOrder
  }

  export type EnumRequestStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.RequestStatus | EnumRequestStatusFieldRefInput<$PrismaModel>
    in?: $Enums.RequestStatus[] | ListEnumRequestStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.RequestStatus[] | ListEnumRequestStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumRequestStatusFilter<$PrismaModel> | $Enums.RequestStatus
  }

  export type MatchRequestCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    futsalName?: SortOrder
    futsalType?: SortOrder
    matchDate?: SortOrder
    startTime?: SortOrder
    endTime?: SortOrder
    matchType?: SortOrder
    status?: SortOrder
  }

  export type MatchRequestAvgOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
  }

  export type MatchRequestMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    futsalName?: SortOrder
    futsalType?: SortOrder
    matchDate?: SortOrder
    startTime?: SortOrder
    endTime?: SortOrder
    matchType?: SortOrder
    status?: SortOrder
  }

  export type MatchRequestMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    futsalName?: SortOrder
    futsalType?: SortOrder
    matchDate?: SortOrder
    startTime?: SortOrder
    endTime?: SortOrder
    matchType?: SortOrder
    status?: SortOrder
  }

  export type MatchRequestSumOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
  }

  export type EnumRequestStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.RequestStatus | EnumRequestStatusFieldRefInput<$PrismaModel>
    in?: $Enums.RequestStatus[] | ListEnumRequestStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.RequestStatus[] | ListEnumRequestStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumRequestStatusWithAggregatesFilter<$PrismaModel> | $Enums.RequestStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumRequestStatusFilter<$PrismaModel>
    _max?: NestedEnumRequestStatusFilter<$PrismaModel>
  }

  export type EnumMatchStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.MatchStatus | EnumMatchStatusFieldRefInput<$PrismaModel>
    in?: $Enums.MatchStatus[] | ListEnumMatchStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.MatchStatus[] | ListEnumMatchStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumMatchStatusFilter<$PrismaModel> | $Enums.MatchStatus
  }

  export type MatchesCountOrderByAggregateInput = {
    id?: SortOrder
    futsalName?: SortOrder
    futsalType?: SortOrder
    matchType?: SortOrder
    matchDate?: SortOrder
    startTime?: SortOrder
    endTime?: SortOrder
    status?: SortOrder
    organizerId?: SortOrder
    opponentId?: SortOrder
  }

  export type MatchesAvgOrderByAggregateInput = {
    id?: SortOrder
    organizerId?: SortOrder
    opponentId?: SortOrder
  }

  export type MatchesMaxOrderByAggregateInput = {
    id?: SortOrder
    futsalName?: SortOrder
    futsalType?: SortOrder
    matchType?: SortOrder
    matchDate?: SortOrder
    startTime?: SortOrder
    endTime?: SortOrder
    status?: SortOrder
    organizerId?: SortOrder
    opponentId?: SortOrder
  }

  export type MatchesMinOrderByAggregateInput = {
    id?: SortOrder
    futsalName?: SortOrder
    futsalType?: SortOrder
    matchType?: SortOrder
    matchDate?: SortOrder
    startTime?: SortOrder
    endTime?: SortOrder
    status?: SortOrder
    organizerId?: SortOrder
    opponentId?: SortOrder
  }

  export type MatchesSumOrderByAggregateInput = {
    id?: SortOrder
    organizerId?: SortOrder
    opponentId?: SortOrder
  }

  export type EnumMatchStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.MatchStatus | EnumMatchStatusFieldRefInput<$PrismaModel>
    in?: $Enums.MatchStatus[] | ListEnumMatchStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.MatchStatus[] | ListEnumMatchStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumMatchStatusWithAggregatesFilter<$PrismaModel> | $Enums.MatchStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumMatchStatusFilter<$PrismaModel>
    _max?: NestedEnumMatchStatusFilter<$PrismaModel>
  }

  export type UsersCreateNestedManyWithoutRolesInput = {
    create?: XOR<UsersCreateWithoutRolesInput, UsersUncheckedCreateWithoutRolesInput> | UsersCreateWithoutRolesInput[] | UsersUncheckedCreateWithoutRolesInput[]
    connectOrCreate?: UsersCreateOrConnectWithoutRolesInput | UsersCreateOrConnectWithoutRolesInput[]
    createMany?: UsersCreateManyRolesInputEnvelope
    connect?: UsersWhereUniqueInput | UsersWhereUniqueInput[]
  }

  export type UsersUncheckedCreateNestedManyWithoutRolesInput = {
    create?: XOR<UsersCreateWithoutRolesInput, UsersUncheckedCreateWithoutRolesInput> | UsersCreateWithoutRolesInput[] | UsersUncheckedCreateWithoutRolesInput[]
    connectOrCreate?: UsersCreateOrConnectWithoutRolesInput | UsersCreateOrConnectWithoutRolesInput[]
    createMany?: UsersCreateManyRolesInputEnvelope
    connect?: UsersWhereUniqueInput | UsersWhereUniqueInput[]
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type UsersUpdateManyWithoutRolesNestedInput = {
    create?: XOR<UsersCreateWithoutRolesInput, UsersUncheckedCreateWithoutRolesInput> | UsersCreateWithoutRolesInput[] | UsersUncheckedCreateWithoutRolesInput[]
    connectOrCreate?: UsersCreateOrConnectWithoutRolesInput | UsersCreateOrConnectWithoutRolesInput[]
    upsert?: UsersUpsertWithWhereUniqueWithoutRolesInput | UsersUpsertWithWhereUniqueWithoutRolesInput[]
    createMany?: UsersCreateManyRolesInputEnvelope
    set?: UsersWhereUniqueInput | UsersWhereUniqueInput[]
    disconnect?: UsersWhereUniqueInput | UsersWhereUniqueInput[]
    delete?: UsersWhereUniqueInput | UsersWhereUniqueInput[]
    connect?: UsersWhereUniqueInput | UsersWhereUniqueInput[]
    update?: UsersUpdateWithWhereUniqueWithoutRolesInput | UsersUpdateWithWhereUniqueWithoutRolesInput[]
    updateMany?: UsersUpdateManyWithWhereWithoutRolesInput | UsersUpdateManyWithWhereWithoutRolesInput[]
    deleteMany?: UsersScalarWhereInput | UsersScalarWhereInput[]
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type UsersUncheckedUpdateManyWithoutRolesNestedInput = {
    create?: XOR<UsersCreateWithoutRolesInput, UsersUncheckedCreateWithoutRolesInput> | UsersCreateWithoutRolesInput[] | UsersUncheckedCreateWithoutRolesInput[]
    connectOrCreate?: UsersCreateOrConnectWithoutRolesInput | UsersCreateOrConnectWithoutRolesInput[]
    upsert?: UsersUpsertWithWhereUniqueWithoutRolesInput | UsersUpsertWithWhereUniqueWithoutRolesInput[]
    createMany?: UsersCreateManyRolesInputEnvelope
    set?: UsersWhereUniqueInput | UsersWhereUniqueInput[]
    disconnect?: UsersWhereUniqueInput | UsersWhereUniqueInput[]
    delete?: UsersWhereUniqueInput | UsersWhereUniqueInput[]
    connect?: UsersWhereUniqueInput | UsersWhereUniqueInput[]
    update?: UsersUpdateWithWhereUniqueWithoutRolesInput | UsersUpdateWithWhereUniqueWithoutRolesInput[]
    updateMany?: UsersUpdateManyWithWhereWithoutRolesInput | UsersUpdateManyWithWhereWithoutRolesInput[]
    deleteMany?: UsersScalarWhereInput | UsersScalarWhereInput[]
  }

  export type RolesCreateNestedOneWithoutUsersInput = {
    create?: XOR<RolesCreateWithoutUsersInput, RolesUncheckedCreateWithoutUsersInput>
    connectOrCreate?: RolesCreateOrConnectWithoutUsersInput
    connect?: RolesWhereUniqueInput
  }

  export type FutsalsCreateNestedOneWithoutUsersInput = {
    create?: XOR<FutsalsCreateWithoutUsersInput, FutsalsUncheckedCreateWithoutUsersInput>
    connectOrCreate?: FutsalsCreateOrConnectWithoutUsersInput
    connect?: FutsalsWhereUniqueInput
  }

  export type BookingsCreateNestedManyWithoutUsersInput = {
    create?: XOR<BookingsCreateWithoutUsersInput, BookingsUncheckedCreateWithoutUsersInput> | BookingsCreateWithoutUsersInput[] | BookingsUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: BookingsCreateOrConnectWithoutUsersInput | BookingsCreateOrConnectWithoutUsersInput[]
    createMany?: BookingsCreateManyUsersInputEnvelope
    connect?: BookingsWhereUniqueInput | BookingsWhereUniqueInput[]
  }

  export type MatchRequestCreateNestedOneWithoutUsersInput = {
    create?: XOR<MatchRequestCreateWithoutUsersInput, MatchRequestUncheckedCreateWithoutUsersInput>
    connectOrCreate?: MatchRequestCreateOrConnectWithoutUsersInput
    connect?: MatchRequestWhereUniqueInput
  }

  export type MatchesCreateNestedManyWithoutOrganizerInput = {
    create?: XOR<MatchesCreateWithoutOrganizerInput, MatchesUncheckedCreateWithoutOrganizerInput> | MatchesCreateWithoutOrganizerInput[] | MatchesUncheckedCreateWithoutOrganizerInput[]
    connectOrCreate?: MatchesCreateOrConnectWithoutOrganizerInput | MatchesCreateOrConnectWithoutOrganizerInput[]
    createMany?: MatchesCreateManyOrganizerInputEnvelope
    connect?: MatchesWhereUniqueInput | MatchesWhereUniqueInput[]
  }

  export type MatchesCreateNestedManyWithoutOpponentInput = {
    create?: XOR<MatchesCreateWithoutOpponentInput, MatchesUncheckedCreateWithoutOpponentInput> | MatchesCreateWithoutOpponentInput[] | MatchesUncheckedCreateWithoutOpponentInput[]
    connectOrCreate?: MatchesCreateOrConnectWithoutOpponentInput | MatchesCreateOrConnectWithoutOpponentInput[]
    createMany?: MatchesCreateManyOpponentInputEnvelope
    connect?: MatchesWhereUniqueInput | MatchesWhereUniqueInput[]
  }

  export type FutsalsUncheckedCreateNestedOneWithoutUsersInput = {
    create?: XOR<FutsalsCreateWithoutUsersInput, FutsalsUncheckedCreateWithoutUsersInput>
    connectOrCreate?: FutsalsCreateOrConnectWithoutUsersInput
    connect?: FutsalsWhereUniqueInput
  }

  export type BookingsUncheckedCreateNestedManyWithoutUsersInput = {
    create?: XOR<BookingsCreateWithoutUsersInput, BookingsUncheckedCreateWithoutUsersInput> | BookingsCreateWithoutUsersInput[] | BookingsUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: BookingsCreateOrConnectWithoutUsersInput | BookingsCreateOrConnectWithoutUsersInput[]
    createMany?: BookingsCreateManyUsersInputEnvelope
    connect?: BookingsWhereUniqueInput | BookingsWhereUniqueInput[]
  }

  export type MatchRequestUncheckedCreateNestedOneWithoutUsersInput = {
    create?: XOR<MatchRequestCreateWithoutUsersInput, MatchRequestUncheckedCreateWithoutUsersInput>
    connectOrCreate?: MatchRequestCreateOrConnectWithoutUsersInput
    connect?: MatchRequestWhereUniqueInput
  }

  export type MatchesUncheckedCreateNestedManyWithoutOrganizerInput = {
    create?: XOR<MatchesCreateWithoutOrganizerInput, MatchesUncheckedCreateWithoutOrganizerInput> | MatchesCreateWithoutOrganizerInput[] | MatchesUncheckedCreateWithoutOrganizerInput[]
    connectOrCreate?: MatchesCreateOrConnectWithoutOrganizerInput | MatchesCreateOrConnectWithoutOrganizerInput[]
    createMany?: MatchesCreateManyOrganizerInputEnvelope
    connect?: MatchesWhereUniqueInput | MatchesWhereUniqueInput[]
  }

  export type MatchesUncheckedCreateNestedManyWithoutOpponentInput = {
    create?: XOR<MatchesCreateWithoutOpponentInput, MatchesUncheckedCreateWithoutOpponentInput> | MatchesCreateWithoutOpponentInput[] | MatchesUncheckedCreateWithoutOpponentInput[]
    connectOrCreate?: MatchesCreateOrConnectWithoutOpponentInput | MatchesCreateOrConnectWithoutOpponentInput[]
    createMany?: MatchesCreateManyOpponentInputEnvelope
    connect?: MatchesWhereUniqueInput | MatchesWhereUniqueInput[]
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type RolesUpdateOneRequiredWithoutUsersNestedInput = {
    create?: XOR<RolesCreateWithoutUsersInput, RolesUncheckedCreateWithoutUsersInput>
    connectOrCreate?: RolesCreateOrConnectWithoutUsersInput
    upsert?: RolesUpsertWithoutUsersInput
    connect?: RolesWhereUniqueInput
    update?: XOR<XOR<RolesUpdateToOneWithWhereWithoutUsersInput, RolesUpdateWithoutUsersInput>, RolesUncheckedUpdateWithoutUsersInput>
  }

  export type FutsalsUpdateOneWithoutUsersNestedInput = {
    create?: XOR<FutsalsCreateWithoutUsersInput, FutsalsUncheckedCreateWithoutUsersInput>
    connectOrCreate?: FutsalsCreateOrConnectWithoutUsersInput
    upsert?: FutsalsUpsertWithoutUsersInput
    disconnect?: FutsalsWhereInput | boolean
    delete?: FutsalsWhereInput | boolean
    connect?: FutsalsWhereUniqueInput
    update?: XOR<XOR<FutsalsUpdateToOneWithWhereWithoutUsersInput, FutsalsUpdateWithoutUsersInput>, FutsalsUncheckedUpdateWithoutUsersInput>
  }

  export type BookingsUpdateManyWithoutUsersNestedInput = {
    create?: XOR<BookingsCreateWithoutUsersInput, BookingsUncheckedCreateWithoutUsersInput> | BookingsCreateWithoutUsersInput[] | BookingsUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: BookingsCreateOrConnectWithoutUsersInput | BookingsCreateOrConnectWithoutUsersInput[]
    upsert?: BookingsUpsertWithWhereUniqueWithoutUsersInput | BookingsUpsertWithWhereUniqueWithoutUsersInput[]
    createMany?: BookingsCreateManyUsersInputEnvelope
    set?: BookingsWhereUniqueInput | BookingsWhereUniqueInput[]
    disconnect?: BookingsWhereUniqueInput | BookingsWhereUniqueInput[]
    delete?: BookingsWhereUniqueInput | BookingsWhereUniqueInput[]
    connect?: BookingsWhereUniqueInput | BookingsWhereUniqueInput[]
    update?: BookingsUpdateWithWhereUniqueWithoutUsersInput | BookingsUpdateWithWhereUniqueWithoutUsersInput[]
    updateMany?: BookingsUpdateManyWithWhereWithoutUsersInput | BookingsUpdateManyWithWhereWithoutUsersInput[]
    deleteMany?: BookingsScalarWhereInput | BookingsScalarWhereInput[]
  }

  export type MatchRequestUpdateOneWithoutUsersNestedInput = {
    create?: XOR<MatchRequestCreateWithoutUsersInput, MatchRequestUncheckedCreateWithoutUsersInput>
    connectOrCreate?: MatchRequestCreateOrConnectWithoutUsersInput
    upsert?: MatchRequestUpsertWithoutUsersInput
    disconnect?: MatchRequestWhereInput | boolean
    delete?: MatchRequestWhereInput | boolean
    connect?: MatchRequestWhereUniqueInput
    update?: XOR<XOR<MatchRequestUpdateToOneWithWhereWithoutUsersInput, MatchRequestUpdateWithoutUsersInput>, MatchRequestUncheckedUpdateWithoutUsersInput>
  }

  export type MatchesUpdateManyWithoutOrganizerNestedInput = {
    create?: XOR<MatchesCreateWithoutOrganizerInput, MatchesUncheckedCreateWithoutOrganizerInput> | MatchesCreateWithoutOrganizerInput[] | MatchesUncheckedCreateWithoutOrganizerInput[]
    connectOrCreate?: MatchesCreateOrConnectWithoutOrganizerInput | MatchesCreateOrConnectWithoutOrganizerInput[]
    upsert?: MatchesUpsertWithWhereUniqueWithoutOrganizerInput | MatchesUpsertWithWhereUniqueWithoutOrganizerInput[]
    createMany?: MatchesCreateManyOrganizerInputEnvelope
    set?: MatchesWhereUniqueInput | MatchesWhereUniqueInput[]
    disconnect?: MatchesWhereUniqueInput | MatchesWhereUniqueInput[]
    delete?: MatchesWhereUniqueInput | MatchesWhereUniqueInput[]
    connect?: MatchesWhereUniqueInput | MatchesWhereUniqueInput[]
    update?: MatchesUpdateWithWhereUniqueWithoutOrganizerInput | MatchesUpdateWithWhereUniqueWithoutOrganizerInput[]
    updateMany?: MatchesUpdateManyWithWhereWithoutOrganizerInput | MatchesUpdateManyWithWhereWithoutOrganizerInput[]
    deleteMany?: MatchesScalarWhereInput | MatchesScalarWhereInput[]
  }

  export type MatchesUpdateManyWithoutOpponentNestedInput = {
    create?: XOR<MatchesCreateWithoutOpponentInput, MatchesUncheckedCreateWithoutOpponentInput> | MatchesCreateWithoutOpponentInput[] | MatchesUncheckedCreateWithoutOpponentInput[]
    connectOrCreate?: MatchesCreateOrConnectWithoutOpponentInput | MatchesCreateOrConnectWithoutOpponentInput[]
    upsert?: MatchesUpsertWithWhereUniqueWithoutOpponentInput | MatchesUpsertWithWhereUniqueWithoutOpponentInput[]
    createMany?: MatchesCreateManyOpponentInputEnvelope
    set?: MatchesWhereUniqueInput | MatchesWhereUniqueInput[]
    disconnect?: MatchesWhereUniqueInput | MatchesWhereUniqueInput[]
    delete?: MatchesWhereUniqueInput | MatchesWhereUniqueInput[]
    connect?: MatchesWhereUniqueInput | MatchesWhereUniqueInput[]
    update?: MatchesUpdateWithWhereUniqueWithoutOpponentInput | MatchesUpdateWithWhereUniqueWithoutOpponentInput[]
    updateMany?: MatchesUpdateManyWithWhereWithoutOpponentInput | MatchesUpdateManyWithWhereWithoutOpponentInput[]
    deleteMany?: MatchesScalarWhereInput | MatchesScalarWhereInput[]
  }

  export type FutsalsUncheckedUpdateOneWithoutUsersNestedInput = {
    create?: XOR<FutsalsCreateWithoutUsersInput, FutsalsUncheckedCreateWithoutUsersInput>
    connectOrCreate?: FutsalsCreateOrConnectWithoutUsersInput
    upsert?: FutsalsUpsertWithoutUsersInput
    disconnect?: FutsalsWhereInput | boolean
    delete?: FutsalsWhereInput | boolean
    connect?: FutsalsWhereUniqueInput
    update?: XOR<XOR<FutsalsUpdateToOneWithWhereWithoutUsersInput, FutsalsUpdateWithoutUsersInput>, FutsalsUncheckedUpdateWithoutUsersInput>
  }

  export type BookingsUncheckedUpdateManyWithoutUsersNestedInput = {
    create?: XOR<BookingsCreateWithoutUsersInput, BookingsUncheckedCreateWithoutUsersInput> | BookingsCreateWithoutUsersInput[] | BookingsUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: BookingsCreateOrConnectWithoutUsersInput | BookingsCreateOrConnectWithoutUsersInput[]
    upsert?: BookingsUpsertWithWhereUniqueWithoutUsersInput | BookingsUpsertWithWhereUniqueWithoutUsersInput[]
    createMany?: BookingsCreateManyUsersInputEnvelope
    set?: BookingsWhereUniqueInput | BookingsWhereUniqueInput[]
    disconnect?: BookingsWhereUniqueInput | BookingsWhereUniqueInput[]
    delete?: BookingsWhereUniqueInput | BookingsWhereUniqueInput[]
    connect?: BookingsWhereUniqueInput | BookingsWhereUniqueInput[]
    update?: BookingsUpdateWithWhereUniqueWithoutUsersInput | BookingsUpdateWithWhereUniqueWithoutUsersInput[]
    updateMany?: BookingsUpdateManyWithWhereWithoutUsersInput | BookingsUpdateManyWithWhereWithoutUsersInput[]
    deleteMany?: BookingsScalarWhereInput | BookingsScalarWhereInput[]
  }

  export type MatchRequestUncheckedUpdateOneWithoutUsersNestedInput = {
    create?: XOR<MatchRequestCreateWithoutUsersInput, MatchRequestUncheckedCreateWithoutUsersInput>
    connectOrCreate?: MatchRequestCreateOrConnectWithoutUsersInput
    upsert?: MatchRequestUpsertWithoutUsersInput
    disconnect?: MatchRequestWhereInput | boolean
    delete?: MatchRequestWhereInput | boolean
    connect?: MatchRequestWhereUniqueInput
    update?: XOR<XOR<MatchRequestUpdateToOneWithWhereWithoutUsersInput, MatchRequestUpdateWithoutUsersInput>, MatchRequestUncheckedUpdateWithoutUsersInput>
  }

  export type MatchesUncheckedUpdateManyWithoutOrganizerNestedInput = {
    create?: XOR<MatchesCreateWithoutOrganizerInput, MatchesUncheckedCreateWithoutOrganizerInput> | MatchesCreateWithoutOrganizerInput[] | MatchesUncheckedCreateWithoutOrganizerInput[]
    connectOrCreate?: MatchesCreateOrConnectWithoutOrganizerInput | MatchesCreateOrConnectWithoutOrganizerInput[]
    upsert?: MatchesUpsertWithWhereUniqueWithoutOrganizerInput | MatchesUpsertWithWhereUniqueWithoutOrganizerInput[]
    createMany?: MatchesCreateManyOrganizerInputEnvelope
    set?: MatchesWhereUniqueInput | MatchesWhereUniqueInput[]
    disconnect?: MatchesWhereUniqueInput | MatchesWhereUniqueInput[]
    delete?: MatchesWhereUniqueInput | MatchesWhereUniqueInput[]
    connect?: MatchesWhereUniqueInput | MatchesWhereUniqueInput[]
    update?: MatchesUpdateWithWhereUniqueWithoutOrganizerInput | MatchesUpdateWithWhereUniqueWithoutOrganizerInput[]
    updateMany?: MatchesUpdateManyWithWhereWithoutOrganizerInput | MatchesUpdateManyWithWhereWithoutOrganizerInput[]
    deleteMany?: MatchesScalarWhereInput | MatchesScalarWhereInput[]
  }

  export type MatchesUncheckedUpdateManyWithoutOpponentNestedInput = {
    create?: XOR<MatchesCreateWithoutOpponentInput, MatchesUncheckedCreateWithoutOpponentInput> | MatchesCreateWithoutOpponentInput[] | MatchesUncheckedCreateWithoutOpponentInput[]
    connectOrCreate?: MatchesCreateOrConnectWithoutOpponentInput | MatchesCreateOrConnectWithoutOpponentInput[]
    upsert?: MatchesUpsertWithWhereUniqueWithoutOpponentInput | MatchesUpsertWithWhereUniqueWithoutOpponentInput[]
    createMany?: MatchesCreateManyOpponentInputEnvelope
    set?: MatchesWhereUniqueInput | MatchesWhereUniqueInput[]
    disconnect?: MatchesWhereUniqueInput | MatchesWhereUniqueInput[]
    delete?: MatchesWhereUniqueInput | MatchesWhereUniqueInput[]
    connect?: MatchesWhereUniqueInput | MatchesWhereUniqueInput[]
    update?: MatchesUpdateWithWhereUniqueWithoutOpponentInput | MatchesUpdateWithWhereUniqueWithoutOpponentInput[]
    updateMany?: MatchesUpdateManyWithWhereWithoutOpponentInput | MatchesUpdateManyWithWhereWithoutOpponentInput[]
    deleteMany?: MatchesScalarWhereInput | MatchesScalarWhereInput[]
  }

  export type FutsalsCreateamenitiesInput = {
    set: string[]
  }

  export type FutsalImageCreateNestedManyWithoutFutsalInput = {
    create?: XOR<FutsalImageCreateWithoutFutsalInput, FutsalImageUncheckedCreateWithoutFutsalInput> | FutsalImageCreateWithoutFutsalInput[] | FutsalImageUncheckedCreateWithoutFutsalInput[]
    connectOrCreate?: FutsalImageCreateOrConnectWithoutFutsalInput | FutsalImageCreateOrConnectWithoutFutsalInput[]
    createMany?: FutsalImageCreateManyFutsalInputEnvelope
    connect?: FutsalImageWhereUniqueInput | FutsalImageWhereUniqueInput[]
  }

  export type UsersCreateNestedOneWithoutFutsalsInput = {
    create?: XOR<UsersCreateWithoutFutsalsInput, UsersUncheckedCreateWithoutFutsalsInput>
    connectOrCreate?: UsersCreateOrConnectWithoutFutsalsInput
    connect?: UsersWhereUniqueInput
  }

  export type PriceListsCreateNestedManyWithoutFutsalsInput = {
    create?: XOR<PriceListsCreateWithoutFutsalsInput, PriceListsUncheckedCreateWithoutFutsalsInput> | PriceListsCreateWithoutFutsalsInput[] | PriceListsUncheckedCreateWithoutFutsalsInput[]
    connectOrCreate?: PriceListsCreateOrConnectWithoutFutsalsInput | PriceListsCreateOrConnectWithoutFutsalsInput[]
    createMany?: PriceListsCreateManyFutsalsInputEnvelope
    connect?: PriceListsWhereUniqueInput | PriceListsWhereUniqueInput[]
  }

  export type BookingsCreateNestedManyWithoutFutsalsInput = {
    create?: XOR<BookingsCreateWithoutFutsalsInput, BookingsUncheckedCreateWithoutFutsalsInput> | BookingsCreateWithoutFutsalsInput[] | BookingsUncheckedCreateWithoutFutsalsInput[]
    connectOrCreate?: BookingsCreateOrConnectWithoutFutsalsInput | BookingsCreateOrConnectWithoutFutsalsInput[]
    createMany?: BookingsCreateManyFutsalsInputEnvelope
    connect?: BookingsWhereUniqueInput | BookingsWhereUniqueInput[]
  }

  export type TimeSlotsCreateNestedManyWithoutFutsalsInput = {
    create?: XOR<TimeSlotsCreateWithoutFutsalsInput, TimeSlotsUncheckedCreateWithoutFutsalsInput> | TimeSlotsCreateWithoutFutsalsInput[] | TimeSlotsUncheckedCreateWithoutFutsalsInput[]
    connectOrCreate?: TimeSlotsCreateOrConnectWithoutFutsalsInput | TimeSlotsCreateOrConnectWithoutFutsalsInput[]
    createMany?: TimeSlotsCreateManyFutsalsInputEnvelope
    connect?: TimeSlotsWhereUniqueInput | TimeSlotsWhereUniqueInput[]
  }

  export type FutsalImageUncheckedCreateNestedManyWithoutFutsalInput = {
    create?: XOR<FutsalImageCreateWithoutFutsalInput, FutsalImageUncheckedCreateWithoutFutsalInput> | FutsalImageCreateWithoutFutsalInput[] | FutsalImageUncheckedCreateWithoutFutsalInput[]
    connectOrCreate?: FutsalImageCreateOrConnectWithoutFutsalInput | FutsalImageCreateOrConnectWithoutFutsalInput[]
    createMany?: FutsalImageCreateManyFutsalInputEnvelope
    connect?: FutsalImageWhereUniqueInput | FutsalImageWhereUniqueInput[]
  }

  export type PriceListsUncheckedCreateNestedManyWithoutFutsalsInput = {
    create?: XOR<PriceListsCreateWithoutFutsalsInput, PriceListsUncheckedCreateWithoutFutsalsInput> | PriceListsCreateWithoutFutsalsInput[] | PriceListsUncheckedCreateWithoutFutsalsInput[]
    connectOrCreate?: PriceListsCreateOrConnectWithoutFutsalsInput | PriceListsCreateOrConnectWithoutFutsalsInput[]
    createMany?: PriceListsCreateManyFutsalsInputEnvelope
    connect?: PriceListsWhereUniqueInput | PriceListsWhereUniqueInput[]
  }

  export type BookingsUncheckedCreateNestedManyWithoutFutsalsInput = {
    create?: XOR<BookingsCreateWithoutFutsalsInput, BookingsUncheckedCreateWithoutFutsalsInput> | BookingsCreateWithoutFutsalsInput[] | BookingsUncheckedCreateWithoutFutsalsInput[]
    connectOrCreate?: BookingsCreateOrConnectWithoutFutsalsInput | BookingsCreateOrConnectWithoutFutsalsInput[]
    createMany?: BookingsCreateManyFutsalsInputEnvelope
    connect?: BookingsWhereUniqueInput | BookingsWhereUniqueInput[]
  }

  export type TimeSlotsUncheckedCreateNestedManyWithoutFutsalsInput = {
    create?: XOR<TimeSlotsCreateWithoutFutsalsInput, TimeSlotsUncheckedCreateWithoutFutsalsInput> | TimeSlotsCreateWithoutFutsalsInput[] | TimeSlotsUncheckedCreateWithoutFutsalsInput[]
    connectOrCreate?: TimeSlotsCreateOrConnectWithoutFutsalsInput | TimeSlotsCreateOrConnectWithoutFutsalsInput[]
    createMany?: TimeSlotsCreateManyFutsalsInputEnvelope
    connect?: TimeSlotsWhereUniqueInput | TimeSlotsWhereUniqueInput[]
  }

  export type EnumFutsalTypeFieldUpdateOperationsInput = {
    set?: $Enums.FutsalType
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type FutsalsUpdateamenitiesInput = {
    set?: string[]
    push?: string | string[]
  }

  export type DecimalFieldUpdateOperationsInput = {
    set?: Decimal | DecimalJsLike | number | string
    increment?: Decimal | DecimalJsLike | number | string
    decrement?: Decimal | DecimalJsLike | number | string
    multiply?: Decimal | DecimalJsLike | number | string
    divide?: Decimal | DecimalJsLike | number | string
  }

  export type FutsalImageUpdateManyWithoutFutsalNestedInput = {
    create?: XOR<FutsalImageCreateWithoutFutsalInput, FutsalImageUncheckedCreateWithoutFutsalInput> | FutsalImageCreateWithoutFutsalInput[] | FutsalImageUncheckedCreateWithoutFutsalInput[]
    connectOrCreate?: FutsalImageCreateOrConnectWithoutFutsalInput | FutsalImageCreateOrConnectWithoutFutsalInput[]
    upsert?: FutsalImageUpsertWithWhereUniqueWithoutFutsalInput | FutsalImageUpsertWithWhereUniqueWithoutFutsalInput[]
    createMany?: FutsalImageCreateManyFutsalInputEnvelope
    set?: FutsalImageWhereUniqueInput | FutsalImageWhereUniqueInput[]
    disconnect?: FutsalImageWhereUniqueInput | FutsalImageWhereUniqueInput[]
    delete?: FutsalImageWhereUniqueInput | FutsalImageWhereUniqueInput[]
    connect?: FutsalImageWhereUniqueInput | FutsalImageWhereUniqueInput[]
    update?: FutsalImageUpdateWithWhereUniqueWithoutFutsalInput | FutsalImageUpdateWithWhereUniqueWithoutFutsalInput[]
    updateMany?: FutsalImageUpdateManyWithWhereWithoutFutsalInput | FutsalImageUpdateManyWithWhereWithoutFutsalInput[]
    deleteMany?: FutsalImageScalarWhereInput | FutsalImageScalarWhereInput[]
  }

  export type UsersUpdateOneRequiredWithoutFutsalsNestedInput = {
    create?: XOR<UsersCreateWithoutFutsalsInput, UsersUncheckedCreateWithoutFutsalsInput>
    connectOrCreate?: UsersCreateOrConnectWithoutFutsalsInput
    upsert?: UsersUpsertWithoutFutsalsInput
    connect?: UsersWhereUniqueInput
    update?: XOR<XOR<UsersUpdateToOneWithWhereWithoutFutsalsInput, UsersUpdateWithoutFutsalsInput>, UsersUncheckedUpdateWithoutFutsalsInput>
  }

  export type PriceListsUpdateManyWithoutFutsalsNestedInput = {
    create?: XOR<PriceListsCreateWithoutFutsalsInput, PriceListsUncheckedCreateWithoutFutsalsInput> | PriceListsCreateWithoutFutsalsInput[] | PriceListsUncheckedCreateWithoutFutsalsInput[]
    connectOrCreate?: PriceListsCreateOrConnectWithoutFutsalsInput | PriceListsCreateOrConnectWithoutFutsalsInput[]
    upsert?: PriceListsUpsertWithWhereUniqueWithoutFutsalsInput | PriceListsUpsertWithWhereUniqueWithoutFutsalsInput[]
    createMany?: PriceListsCreateManyFutsalsInputEnvelope
    set?: PriceListsWhereUniqueInput | PriceListsWhereUniqueInput[]
    disconnect?: PriceListsWhereUniqueInput | PriceListsWhereUniqueInput[]
    delete?: PriceListsWhereUniqueInput | PriceListsWhereUniqueInput[]
    connect?: PriceListsWhereUniqueInput | PriceListsWhereUniqueInput[]
    update?: PriceListsUpdateWithWhereUniqueWithoutFutsalsInput | PriceListsUpdateWithWhereUniqueWithoutFutsalsInput[]
    updateMany?: PriceListsUpdateManyWithWhereWithoutFutsalsInput | PriceListsUpdateManyWithWhereWithoutFutsalsInput[]
    deleteMany?: PriceListsScalarWhereInput | PriceListsScalarWhereInput[]
  }

  export type BookingsUpdateManyWithoutFutsalsNestedInput = {
    create?: XOR<BookingsCreateWithoutFutsalsInput, BookingsUncheckedCreateWithoutFutsalsInput> | BookingsCreateWithoutFutsalsInput[] | BookingsUncheckedCreateWithoutFutsalsInput[]
    connectOrCreate?: BookingsCreateOrConnectWithoutFutsalsInput | BookingsCreateOrConnectWithoutFutsalsInput[]
    upsert?: BookingsUpsertWithWhereUniqueWithoutFutsalsInput | BookingsUpsertWithWhereUniqueWithoutFutsalsInput[]
    createMany?: BookingsCreateManyFutsalsInputEnvelope
    set?: BookingsWhereUniqueInput | BookingsWhereUniqueInput[]
    disconnect?: BookingsWhereUniqueInput | BookingsWhereUniqueInput[]
    delete?: BookingsWhereUniqueInput | BookingsWhereUniqueInput[]
    connect?: BookingsWhereUniqueInput | BookingsWhereUniqueInput[]
    update?: BookingsUpdateWithWhereUniqueWithoutFutsalsInput | BookingsUpdateWithWhereUniqueWithoutFutsalsInput[]
    updateMany?: BookingsUpdateManyWithWhereWithoutFutsalsInput | BookingsUpdateManyWithWhereWithoutFutsalsInput[]
    deleteMany?: BookingsScalarWhereInput | BookingsScalarWhereInput[]
  }

  export type TimeSlotsUpdateManyWithoutFutsalsNestedInput = {
    create?: XOR<TimeSlotsCreateWithoutFutsalsInput, TimeSlotsUncheckedCreateWithoutFutsalsInput> | TimeSlotsCreateWithoutFutsalsInput[] | TimeSlotsUncheckedCreateWithoutFutsalsInput[]
    connectOrCreate?: TimeSlotsCreateOrConnectWithoutFutsalsInput | TimeSlotsCreateOrConnectWithoutFutsalsInput[]
    upsert?: TimeSlotsUpsertWithWhereUniqueWithoutFutsalsInput | TimeSlotsUpsertWithWhereUniqueWithoutFutsalsInput[]
    createMany?: TimeSlotsCreateManyFutsalsInputEnvelope
    set?: TimeSlotsWhereUniqueInput | TimeSlotsWhereUniqueInput[]
    disconnect?: TimeSlotsWhereUniqueInput | TimeSlotsWhereUniqueInput[]
    delete?: TimeSlotsWhereUniqueInput | TimeSlotsWhereUniqueInput[]
    connect?: TimeSlotsWhereUniqueInput | TimeSlotsWhereUniqueInput[]
    update?: TimeSlotsUpdateWithWhereUniqueWithoutFutsalsInput | TimeSlotsUpdateWithWhereUniqueWithoutFutsalsInput[]
    updateMany?: TimeSlotsUpdateManyWithWhereWithoutFutsalsInput | TimeSlotsUpdateManyWithWhereWithoutFutsalsInput[]
    deleteMany?: TimeSlotsScalarWhereInput | TimeSlotsScalarWhereInput[]
  }

  export type FutsalImageUncheckedUpdateManyWithoutFutsalNestedInput = {
    create?: XOR<FutsalImageCreateWithoutFutsalInput, FutsalImageUncheckedCreateWithoutFutsalInput> | FutsalImageCreateWithoutFutsalInput[] | FutsalImageUncheckedCreateWithoutFutsalInput[]
    connectOrCreate?: FutsalImageCreateOrConnectWithoutFutsalInput | FutsalImageCreateOrConnectWithoutFutsalInput[]
    upsert?: FutsalImageUpsertWithWhereUniqueWithoutFutsalInput | FutsalImageUpsertWithWhereUniqueWithoutFutsalInput[]
    createMany?: FutsalImageCreateManyFutsalInputEnvelope
    set?: FutsalImageWhereUniqueInput | FutsalImageWhereUniqueInput[]
    disconnect?: FutsalImageWhereUniqueInput | FutsalImageWhereUniqueInput[]
    delete?: FutsalImageWhereUniqueInput | FutsalImageWhereUniqueInput[]
    connect?: FutsalImageWhereUniqueInput | FutsalImageWhereUniqueInput[]
    update?: FutsalImageUpdateWithWhereUniqueWithoutFutsalInput | FutsalImageUpdateWithWhereUniqueWithoutFutsalInput[]
    updateMany?: FutsalImageUpdateManyWithWhereWithoutFutsalInput | FutsalImageUpdateManyWithWhereWithoutFutsalInput[]
    deleteMany?: FutsalImageScalarWhereInput | FutsalImageScalarWhereInput[]
  }

  export type PriceListsUncheckedUpdateManyWithoutFutsalsNestedInput = {
    create?: XOR<PriceListsCreateWithoutFutsalsInput, PriceListsUncheckedCreateWithoutFutsalsInput> | PriceListsCreateWithoutFutsalsInput[] | PriceListsUncheckedCreateWithoutFutsalsInput[]
    connectOrCreate?: PriceListsCreateOrConnectWithoutFutsalsInput | PriceListsCreateOrConnectWithoutFutsalsInput[]
    upsert?: PriceListsUpsertWithWhereUniqueWithoutFutsalsInput | PriceListsUpsertWithWhereUniqueWithoutFutsalsInput[]
    createMany?: PriceListsCreateManyFutsalsInputEnvelope
    set?: PriceListsWhereUniqueInput | PriceListsWhereUniqueInput[]
    disconnect?: PriceListsWhereUniqueInput | PriceListsWhereUniqueInput[]
    delete?: PriceListsWhereUniqueInput | PriceListsWhereUniqueInput[]
    connect?: PriceListsWhereUniqueInput | PriceListsWhereUniqueInput[]
    update?: PriceListsUpdateWithWhereUniqueWithoutFutsalsInput | PriceListsUpdateWithWhereUniqueWithoutFutsalsInput[]
    updateMany?: PriceListsUpdateManyWithWhereWithoutFutsalsInput | PriceListsUpdateManyWithWhereWithoutFutsalsInput[]
    deleteMany?: PriceListsScalarWhereInput | PriceListsScalarWhereInput[]
  }

  export type BookingsUncheckedUpdateManyWithoutFutsalsNestedInput = {
    create?: XOR<BookingsCreateWithoutFutsalsInput, BookingsUncheckedCreateWithoutFutsalsInput> | BookingsCreateWithoutFutsalsInput[] | BookingsUncheckedCreateWithoutFutsalsInput[]
    connectOrCreate?: BookingsCreateOrConnectWithoutFutsalsInput | BookingsCreateOrConnectWithoutFutsalsInput[]
    upsert?: BookingsUpsertWithWhereUniqueWithoutFutsalsInput | BookingsUpsertWithWhereUniqueWithoutFutsalsInput[]
    createMany?: BookingsCreateManyFutsalsInputEnvelope
    set?: BookingsWhereUniqueInput | BookingsWhereUniqueInput[]
    disconnect?: BookingsWhereUniqueInput | BookingsWhereUniqueInput[]
    delete?: BookingsWhereUniqueInput | BookingsWhereUniqueInput[]
    connect?: BookingsWhereUniqueInput | BookingsWhereUniqueInput[]
    update?: BookingsUpdateWithWhereUniqueWithoutFutsalsInput | BookingsUpdateWithWhereUniqueWithoutFutsalsInput[]
    updateMany?: BookingsUpdateManyWithWhereWithoutFutsalsInput | BookingsUpdateManyWithWhereWithoutFutsalsInput[]
    deleteMany?: BookingsScalarWhereInput | BookingsScalarWhereInput[]
  }

  export type TimeSlotsUncheckedUpdateManyWithoutFutsalsNestedInput = {
    create?: XOR<TimeSlotsCreateWithoutFutsalsInput, TimeSlotsUncheckedCreateWithoutFutsalsInput> | TimeSlotsCreateWithoutFutsalsInput[] | TimeSlotsUncheckedCreateWithoutFutsalsInput[]
    connectOrCreate?: TimeSlotsCreateOrConnectWithoutFutsalsInput | TimeSlotsCreateOrConnectWithoutFutsalsInput[]
    upsert?: TimeSlotsUpsertWithWhereUniqueWithoutFutsalsInput | TimeSlotsUpsertWithWhereUniqueWithoutFutsalsInput[]
    createMany?: TimeSlotsCreateManyFutsalsInputEnvelope
    set?: TimeSlotsWhereUniqueInput | TimeSlotsWhereUniqueInput[]
    disconnect?: TimeSlotsWhereUniqueInput | TimeSlotsWhereUniqueInput[]
    delete?: TimeSlotsWhereUniqueInput | TimeSlotsWhereUniqueInput[]
    connect?: TimeSlotsWhereUniqueInput | TimeSlotsWhereUniqueInput[]
    update?: TimeSlotsUpdateWithWhereUniqueWithoutFutsalsInput | TimeSlotsUpdateWithWhereUniqueWithoutFutsalsInput[]
    updateMany?: TimeSlotsUpdateManyWithWhereWithoutFutsalsInput | TimeSlotsUpdateManyWithWhereWithoutFutsalsInput[]
    deleteMany?: TimeSlotsScalarWhereInput | TimeSlotsScalarWhereInput[]
  }

  export type FutsalsCreateNestedOneWithoutImagesInput = {
    create?: XOR<FutsalsCreateWithoutImagesInput, FutsalsUncheckedCreateWithoutImagesInput>
    connectOrCreate?: FutsalsCreateOrConnectWithoutImagesInput
    connect?: FutsalsWhereUniqueInput
  }

  export type FutsalsUpdateOneRequiredWithoutImagesNestedInput = {
    create?: XOR<FutsalsCreateWithoutImagesInput, FutsalsUncheckedCreateWithoutImagesInput>
    connectOrCreate?: FutsalsCreateOrConnectWithoutImagesInput
    upsert?: FutsalsUpsertWithoutImagesInput
    connect?: FutsalsWhereUniqueInput
    update?: XOR<XOR<FutsalsUpdateToOneWithWhereWithoutImagesInput, FutsalsUpdateWithoutImagesInput>, FutsalsUncheckedUpdateWithoutImagesInput>
  }

  export type FutsalsCreateNestedOneWithoutPriceListsInput = {
    create?: XOR<FutsalsCreateWithoutPriceListsInput, FutsalsUncheckedCreateWithoutPriceListsInput>
    connectOrCreate?: FutsalsCreateOrConnectWithoutPriceListsInput
    connect?: FutsalsWhereUniqueInput
  }

  export type FutsalsUpdateOneRequiredWithoutPriceListsNestedInput = {
    create?: XOR<FutsalsCreateWithoutPriceListsInput, FutsalsUncheckedCreateWithoutPriceListsInput>
    connectOrCreate?: FutsalsCreateOrConnectWithoutPriceListsInput
    upsert?: FutsalsUpsertWithoutPriceListsInput
    connect?: FutsalsWhereUniqueInput
    update?: XOR<XOR<FutsalsUpdateToOneWithWhereWithoutPriceListsInput, FutsalsUpdateWithoutPriceListsInput>, FutsalsUncheckedUpdateWithoutPriceListsInput>
  }

  export type UsersCreateNestedOneWithoutBookingsInput = {
    create?: XOR<UsersCreateWithoutBookingsInput, UsersUncheckedCreateWithoutBookingsInput>
    connectOrCreate?: UsersCreateOrConnectWithoutBookingsInput
    connect?: UsersWhereUniqueInput
  }

  export type FutsalsCreateNestedOneWithoutBookingsInput = {
    create?: XOR<FutsalsCreateWithoutBookingsInput, FutsalsUncheckedCreateWithoutBookingsInput>
    connectOrCreate?: FutsalsCreateOrConnectWithoutBookingsInput
    connect?: FutsalsWhereUniqueInput
  }

  export type EnumBookingStatusFieldUpdateOperationsInput = {
    set?: $Enums.BookingStatus
  }

  export type EnumPaymentFieldUpdateOperationsInput = {
    set?: $Enums.Payment
  }

  export type UsersUpdateOneRequiredWithoutBookingsNestedInput = {
    create?: XOR<UsersCreateWithoutBookingsInput, UsersUncheckedCreateWithoutBookingsInput>
    connectOrCreate?: UsersCreateOrConnectWithoutBookingsInput
    upsert?: UsersUpsertWithoutBookingsInput
    connect?: UsersWhereUniqueInput
    update?: XOR<XOR<UsersUpdateToOneWithWhereWithoutBookingsInput, UsersUpdateWithoutBookingsInput>, UsersUncheckedUpdateWithoutBookingsInput>
  }

  export type FutsalsUpdateOneRequiredWithoutBookingsNestedInput = {
    create?: XOR<FutsalsCreateWithoutBookingsInput, FutsalsUncheckedCreateWithoutBookingsInput>
    connectOrCreate?: FutsalsCreateOrConnectWithoutBookingsInput
    upsert?: FutsalsUpsertWithoutBookingsInput
    connect?: FutsalsWhereUniqueInput
    update?: XOR<XOR<FutsalsUpdateToOneWithWhereWithoutBookingsInput, FutsalsUpdateWithoutBookingsInput>, FutsalsUncheckedUpdateWithoutBookingsInput>
  }

  export type FutsalsCreateNestedOneWithoutTimeSlotsInput = {
    create?: XOR<FutsalsCreateWithoutTimeSlotsInput, FutsalsUncheckedCreateWithoutTimeSlotsInput>
    connectOrCreate?: FutsalsCreateOrConnectWithoutTimeSlotsInput
    connect?: FutsalsWhereUniqueInput
  }

  export type FutsalsUpdateOneRequiredWithoutTimeSlotsNestedInput = {
    create?: XOR<FutsalsCreateWithoutTimeSlotsInput, FutsalsUncheckedCreateWithoutTimeSlotsInput>
    connectOrCreate?: FutsalsCreateOrConnectWithoutTimeSlotsInput
    upsert?: FutsalsUpsertWithoutTimeSlotsInput
    connect?: FutsalsWhereUniqueInput
    update?: XOR<XOR<FutsalsUpdateToOneWithWhereWithoutTimeSlotsInput, FutsalsUpdateWithoutTimeSlotsInput>, FutsalsUncheckedUpdateWithoutTimeSlotsInput>
  }

  export type UsersCreateNestedOneWithoutMatchRequestInput = {
    create?: XOR<UsersCreateWithoutMatchRequestInput, UsersUncheckedCreateWithoutMatchRequestInput>
    connectOrCreate?: UsersCreateOrConnectWithoutMatchRequestInput
    connect?: UsersWhereUniqueInput
  }

  export type EnumRequestStatusFieldUpdateOperationsInput = {
    set?: $Enums.RequestStatus
  }

  export type UsersUpdateOneRequiredWithoutMatchRequestNestedInput = {
    create?: XOR<UsersCreateWithoutMatchRequestInput, UsersUncheckedCreateWithoutMatchRequestInput>
    connectOrCreate?: UsersCreateOrConnectWithoutMatchRequestInput
    upsert?: UsersUpsertWithoutMatchRequestInput
    connect?: UsersWhereUniqueInput
    update?: XOR<XOR<UsersUpdateToOneWithWhereWithoutMatchRequestInput, UsersUpdateWithoutMatchRequestInput>, UsersUncheckedUpdateWithoutMatchRequestInput>
  }

  export type UsersCreateNestedOneWithoutOrganizedMatchesInput = {
    create?: XOR<UsersCreateWithoutOrganizedMatchesInput, UsersUncheckedCreateWithoutOrganizedMatchesInput>
    connectOrCreate?: UsersCreateOrConnectWithoutOrganizedMatchesInput
    connect?: UsersWhereUniqueInput
  }

  export type UsersCreateNestedOneWithoutOpponentMatchesInput = {
    create?: XOR<UsersCreateWithoutOpponentMatchesInput, UsersUncheckedCreateWithoutOpponentMatchesInput>
    connectOrCreate?: UsersCreateOrConnectWithoutOpponentMatchesInput
    connect?: UsersWhereUniqueInput
  }

  export type EnumMatchStatusFieldUpdateOperationsInput = {
    set?: $Enums.MatchStatus
  }

  export type UsersUpdateOneRequiredWithoutOrganizedMatchesNestedInput = {
    create?: XOR<UsersCreateWithoutOrganizedMatchesInput, UsersUncheckedCreateWithoutOrganizedMatchesInput>
    connectOrCreate?: UsersCreateOrConnectWithoutOrganizedMatchesInput
    upsert?: UsersUpsertWithoutOrganizedMatchesInput
    connect?: UsersWhereUniqueInput
    update?: XOR<XOR<UsersUpdateToOneWithWhereWithoutOrganizedMatchesInput, UsersUpdateWithoutOrganizedMatchesInput>, UsersUncheckedUpdateWithoutOrganizedMatchesInput>
  }

  export type UsersUpdateOneRequiredWithoutOpponentMatchesNestedInput = {
    create?: XOR<UsersCreateWithoutOpponentMatchesInput, UsersUncheckedCreateWithoutOpponentMatchesInput>
    connectOrCreate?: UsersCreateOrConnectWithoutOpponentMatchesInput
    upsert?: UsersUpsertWithoutOpponentMatchesInput
    connect?: UsersWhereUniqueInput
    update?: XOR<XOR<UsersUpdateToOneWithWhereWithoutOpponentMatchesInput, UsersUpdateWithoutOpponentMatchesInput>, UsersUncheckedUpdateWithoutOpponentMatchesInput>
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type NestedEnumFutsalTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.FutsalType | EnumFutsalTypeFieldRefInput<$PrismaModel>
    in?: $Enums.FutsalType[] | ListEnumFutsalTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.FutsalType[] | ListEnumFutsalTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumFutsalTypeFilter<$PrismaModel> | $Enums.FutsalType
  }

  export type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type NestedDecimalFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
  }

  export type NestedEnumFutsalTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.FutsalType | EnumFutsalTypeFieldRefInput<$PrismaModel>
    in?: $Enums.FutsalType[] | ListEnumFutsalTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.FutsalType[] | ListEnumFutsalTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumFutsalTypeWithAggregatesFilter<$PrismaModel> | $Enums.FutsalType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumFutsalTypeFilter<$PrismaModel>
    _max?: NestedEnumFutsalTypeFilter<$PrismaModel>
  }

  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type NestedDecimalWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalWithAggregatesFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedDecimalFilter<$PrismaModel>
    _sum?: NestedDecimalFilter<$PrismaModel>
    _min?: NestedDecimalFilter<$PrismaModel>
    _max?: NestedDecimalFilter<$PrismaModel>
  }

  export type NestedEnumBookingStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.BookingStatus | EnumBookingStatusFieldRefInput<$PrismaModel>
    in?: $Enums.BookingStatus[] | ListEnumBookingStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.BookingStatus[] | ListEnumBookingStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumBookingStatusFilter<$PrismaModel> | $Enums.BookingStatus
  }

  export type NestedEnumPaymentFilter<$PrismaModel = never> = {
    equals?: $Enums.Payment | EnumPaymentFieldRefInput<$PrismaModel>
    in?: $Enums.Payment[] | ListEnumPaymentFieldRefInput<$PrismaModel>
    notIn?: $Enums.Payment[] | ListEnumPaymentFieldRefInput<$PrismaModel>
    not?: NestedEnumPaymentFilter<$PrismaModel> | $Enums.Payment
  }

  export type NestedEnumBookingStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.BookingStatus | EnumBookingStatusFieldRefInput<$PrismaModel>
    in?: $Enums.BookingStatus[] | ListEnumBookingStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.BookingStatus[] | ListEnumBookingStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumBookingStatusWithAggregatesFilter<$PrismaModel> | $Enums.BookingStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumBookingStatusFilter<$PrismaModel>
    _max?: NestedEnumBookingStatusFilter<$PrismaModel>
  }

  export type NestedEnumPaymentWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Payment | EnumPaymentFieldRefInput<$PrismaModel>
    in?: $Enums.Payment[] | ListEnumPaymentFieldRefInput<$PrismaModel>
    notIn?: $Enums.Payment[] | ListEnumPaymentFieldRefInput<$PrismaModel>
    not?: NestedEnumPaymentWithAggregatesFilter<$PrismaModel> | $Enums.Payment
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumPaymentFilter<$PrismaModel>
    _max?: NestedEnumPaymentFilter<$PrismaModel>
  }

  export type NestedEnumRequestStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.RequestStatus | EnumRequestStatusFieldRefInput<$PrismaModel>
    in?: $Enums.RequestStatus[] | ListEnumRequestStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.RequestStatus[] | ListEnumRequestStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumRequestStatusFilter<$PrismaModel> | $Enums.RequestStatus
  }

  export type NestedEnumRequestStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.RequestStatus | EnumRequestStatusFieldRefInput<$PrismaModel>
    in?: $Enums.RequestStatus[] | ListEnumRequestStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.RequestStatus[] | ListEnumRequestStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumRequestStatusWithAggregatesFilter<$PrismaModel> | $Enums.RequestStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumRequestStatusFilter<$PrismaModel>
    _max?: NestedEnumRequestStatusFilter<$PrismaModel>
  }

  export type NestedEnumMatchStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.MatchStatus | EnumMatchStatusFieldRefInput<$PrismaModel>
    in?: $Enums.MatchStatus[] | ListEnumMatchStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.MatchStatus[] | ListEnumMatchStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumMatchStatusFilter<$PrismaModel> | $Enums.MatchStatus
  }

  export type NestedEnumMatchStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.MatchStatus | EnumMatchStatusFieldRefInput<$PrismaModel>
    in?: $Enums.MatchStatus[] | ListEnumMatchStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.MatchStatus[] | ListEnumMatchStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumMatchStatusWithAggregatesFilter<$PrismaModel> | $Enums.MatchStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumMatchStatusFilter<$PrismaModel>
    _max?: NestedEnumMatchStatusFilter<$PrismaModel>
  }

  export type UsersCreateWithoutRolesInput = {
    googleId?: string | null
    facebookId?: string | null
    name: string
    email: string
    phone: string
    image?: string | null
    password: string
    address: string
    Futsals?: FutsalsCreateNestedOneWithoutUsersInput
    Bookings?: BookingsCreateNestedManyWithoutUsersInput
    MatchRequest?: MatchRequestCreateNestedOneWithoutUsersInput
    organizedMatches?: MatchesCreateNestedManyWithoutOrganizerInput
    opponentMatches?: MatchesCreateNestedManyWithoutOpponentInput
  }

  export type UsersUncheckedCreateWithoutRolesInput = {
    id?: number
    googleId?: string | null
    facebookId?: string | null
    name: string
    email: string
    phone: string
    image?: string | null
    password: string
    address: string
    Futsals?: FutsalsUncheckedCreateNestedOneWithoutUsersInput
    Bookings?: BookingsUncheckedCreateNestedManyWithoutUsersInput
    MatchRequest?: MatchRequestUncheckedCreateNestedOneWithoutUsersInput
    organizedMatches?: MatchesUncheckedCreateNestedManyWithoutOrganizerInput
    opponentMatches?: MatchesUncheckedCreateNestedManyWithoutOpponentInput
  }

  export type UsersCreateOrConnectWithoutRolesInput = {
    where: UsersWhereUniqueInput
    create: XOR<UsersCreateWithoutRolesInput, UsersUncheckedCreateWithoutRolesInput>
  }

  export type UsersCreateManyRolesInputEnvelope = {
    data: UsersCreateManyRolesInput | UsersCreateManyRolesInput[]
    skipDuplicates?: boolean
  }

  export type UsersUpsertWithWhereUniqueWithoutRolesInput = {
    where: UsersWhereUniqueInput
    update: XOR<UsersUpdateWithoutRolesInput, UsersUncheckedUpdateWithoutRolesInput>
    create: XOR<UsersCreateWithoutRolesInput, UsersUncheckedCreateWithoutRolesInput>
  }

  export type UsersUpdateWithWhereUniqueWithoutRolesInput = {
    where: UsersWhereUniqueInput
    data: XOR<UsersUpdateWithoutRolesInput, UsersUncheckedUpdateWithoutRolesInput>
  }

  export type UsersUpdateManyWithWhereWithoutRolesInput = {
    where: UsersScalarWhereInput
    data: XOR<UsersUpdateManyMutationInput, UsersUncheckedUpdateManyWithoutRolesInput>
  }

  export type UsersScalarWhereInput = {
    AND?: UsersScalarWhereInput | UsersScalarWhereInput[]
    OR?: UsersScalarWhereInput[]
    NOT?: UsersScalarWhereInput | UsersScalarWhereInput[]
    id?: IntFilter<"Users"> | number
    googleId?: StringNullableFilter<"Users"> | string | null
    facebookId?: StringNullableFilter<"Users"> | string | null
    name?: StringFilter<"Users"> | string
    email?: StringFilter<"Users"> | string
    phone?: StringFilter<"Users"> | string
    image?: StringNullableFilter<"Users"> | string | null
    password?: StringFilter<"Users"> | string
    address?: StringFilter<"Users"> | string
    roleId?: IntFilter<"Users"> | number
  }

  export type RolesCreateWithoutUsersInput = {
    title: string
  }

  export type RolesUncheckedCreateWithoutUsersInput = {
    id?: number
    title: string
  }

  export type RolesCreateOrConnectWithoutUsersInput = {
    where: RolesWhereUniqueInput
    create: XOR<RolesCreateWithoutUsersInput, RolesUncheckedCreateWithoutUsersInput>
  }

  export type FutsalsCreateWithoutUsersInput = {
    name: string
    phone: string
    address: string
    type: $Enums.FutsalType
    startTime: Date | string
    endTime: Date | string
    amenities?: FutsalsCreateamenitiesInput | string[]
    stdPrice: number
    rating: Decimal | DecimalJsLike | number | string
    pan: string
    images?: FutsalImageCreateNestedManyWithoutFutsalInput
    PriceLists?: PriceListsCreateNestedManyWithoutFutsalsInput
    Bookings?: BookingsCreateNestedManyWithoutFutsalsInput
    timeSlots?: TimeSlotsCreateNestedManyWithoutFutsalsInput
  }

  export type FutsalsUncheckedCreateWithoutUsersInput = {
    id?: number
    name: string
    phone: string
    address: string
    type: $Enums.FutsalType
    startTime: Date | string
    endTime: Date | string
    amenities?: FutsalsCreateamenitiesInput | string[]
    stdPrice: number
    rating: Decimal | DecimalJsLike | number | string
    pan: string
    images?: FutsalImageUncheckedCreateNestedManyWithoutFutsalInput
    PriceLists?: PriceListsUncheckedCreateNestedManyWithoutFutsalsInput
    Bookings?: BookingsUncheckedCreateNestedManyWithoutFutsalsInput
    timeSlots?: TimeSlotsUncheckedCreateNestedManyWithoutFutsalsInput
  }

  export type FutsalsCreateOrConnectWithoutUsersInput = {
    where: FutsalsWhereUniqueInput
    create: XOR<FutsalsCreateWithoutUsersInput, FutsalsUncheckedCreateWithoutUsersInput>
  }

  export type BookingsCreateWithoutUsersInput = {
    bookDate: Date | string
    startTime: Date | string
    endTime: Date | string
    type: $Enums.FutsalType
    price: number
    confirmation?: $Enums.BookingStatus
    paymentStatus?: $Enums.Payment
    futsals: FutsalsCreateNestedOneWithoutBookingsInput
  }

  export type BookingsUncheckedCreateWithoutUsersInput = {
    id?: number
    futsalId: number
    bookDate: Date | string
    startTime: Date | string
    endTime: Date | string
    type: $Enums.FutsalType
    price: number
    confirmation?: $Enums.BookingStatus
    paymentStatus?: $Enums.Payment
  }

  export type BookingsCreateOrConnectWithoutUsersInput = {
    where: BookingsWhereUniqueInput
    create: XOR<BookingsCreateWithoutUsersInput, BookingsUncheckedCreateWithoutUsersInput>
  }

  export type BookingsCreateManyUsersInputEnvelope = {
    data: BookingsCreateManyUsersInput | BookingsCreateManyUsersInput[]
    skipDuplicates?: boolean
  }

  export type MatchRequestCreateWithoutUsersInput = {
    futsalName: string
    futsalType: $Enums.FutsalType
    matchDate: Date | string
    startTime: Date | string
    endTime: Date | string
    matchType: string
    status?: $Enums.RequestStatus
  }

  export type MatchRequestUncheckedCreateWithoutUsersInput = {
    id?: number
    futsalName: string
    futsalType: $Enums.FutsalType
    matchDate: Date | string
    startTime: Date | string
    endTime: Date | string
    matchType: string
    status?: $Enums.RequestStatus
  }

  export type MatchRequestCreateOrConnectWithoutUsersInput = {
    where: MatchRequestWhereUniqueInput
    create: XOR<MatchRequestCreateWithoutUsersInput, MatchRequestUncheckedCreateWithoutUsersInput>
  }

  export type MatchesCreateWithoutOrganizerInput = {
    futsalName: string
    futsalType: $Enums.FutsalType
    matchType: string
    matchDate: Date | string
    startTime: Date | string
    endTime: Date | string
    status?: $Enums.MatchStatus
    opponent: UsersCreateNestedOneWithoutOpponentMatchesInput
  }

  export type MatchesUncheckedCreateWithoutOrganizerInput = {
    id?: number
    futsalName: string
    futsalType: $Enums.FutsalType
    matchType: string
    matchDate: Date | string
    startTime: Date | string
    endTime: Date | string
    status?: $Enums.MatchStatus
    opponentId: number
  }

  export type MatchesCreateOrConnectWithoutOrganizerInput = {
    where: MatchesWhereUniqueInput
    create: XOR<MatchesCreateWithoutOrganizerInput, MatchesUncheckedCreateWithoutOrganizerInput>
  }

  export type MatchesCreateManyOrganizerInputEnvelope = {
    data: MatchesCreateManyOrganizerInput | MatchesCreateManyOrganizerInput[]
    skipDuplicates?: boolean
  }

  export type MatchesCreateWithoutOpponentInput = {
    futsalName: string
    futsalType: $Enums.FutsalType
    matchType: string
    matchDate: Date | string
    startTime: Date | string
    endTime: Date | string
    status?: $Enums.MatchStatus
    organizer: UsersCreateNestedOneWithoutOrganizedMatchesInput
  }

  export type MatchesUncheckedCreateWithoutOpponentInput = {
    id?: number
    futsalName: string
    futsalType: $Enums.FutsalType
    matchType: string
    matchDate: Date | string
    startTime: Date | string
    endTime: Date | string
    status?: $Enums.MatchStatus
    organizerId: number
  }

  export type MatchesCreateOrConnectWithoutOpponentInput = {
    where: MatchesWhereUniqueInput
    create: XOR<MatchesCreateWithoutOpponentInput, MatchesUncheckedCreateWithoutOpponentInput>
  }

  export type MatchesCreateManyOpponentInputEnvelope = {
    data: MatchesCreateManyOpponentInput | MatchesCreateManyOpponentInput[]
    skipDuplicates?: boolean
  }

  export type RolesUpsertWithoutUsersInput = {
    update: XOR<RolesUpdateWithoutUsersInput, RolesUncheckedUpdateWithoutUsersInput>
    create: XOR<RolesCreateWithoutUsersInput, RolesUncheckedCreateWithoutUsersInput>
    where?: RolesWhereInput
  }

  export type RolesUpdateToOneWithWhereWithoutUsersInput = {
    where?: RolesWhereInput
    data: XOR<RolesUpdateWithoutUsersInput, RolesUncheckedUpdateWithoutUsersInput>
  }

  export type RolesUpdateWithoutUsersInput = {
    title?: StringFieldUpdateOperationsInput | string
  }

  export type RolesUncheckedUpdateWithoutUsersInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
  }

  export type FutsalsUpsertWithoutUsersInput = {
    update: XOR<FutsalsUpdateWithoutUsersInput, FutsalsUncheckedUpdateWithoutUsersInput>
    create: XOR<FutsalsCreateWithoutUsersInput, FutsalsUncheckedCreateWithoutUsersInput>
    where?: FutsalsWhereInput
  }

  export type FutsalsUpdateToOneWithWhereWithoutUsersInput = {
    where?: FutsalsWhereInput
    data: XOR<FutsalsUpdateWithoutUsersInput, FutsalsUncheckedUpdateWithoutUsersInput>
  }

  export type FutsalsUpdateWithoutUsersInput = {
    name?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    type?: EnumFutsalTypeFieldUpdateOperationsInput | $Enums.FutsalType
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: DateTimeFieldUpdateOperationsInput | Date | string
    amenities?: FutsalsUpdateamenitiesInput | string[]
    stdPrice?: IntFieldUpdateOperationsInput | number
    rating?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    pan?: StringFieldUpdateOperationsInput | string
    images?: FutsalImageUpdateManyWithoutFutsalNestedInput
    PriceLists?: PriceListsUpdateManyWithoutFutsalsNestedInput
    Bookings?: BookingsUpdateManyWithoutFutsalsNestedInput
    timeSlots?: TimeSlotsUpdateManyWithoutFutsalsNestedInput
  }

  export type FutsalsUncheckedUpdateWithoutUsersInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    type?: EnumFutsalTypeFieldUpdateOperationsInput | $Enums.FutsalType
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: DateTimeFieldUpdateOperationsInput | Date | string
    amenities?: FutsalsUpdateamenitiesInput | string[]
    stdPrice?: IntFieldUpdateOperationsInput | number
    rating?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    pan?: StringFieldUpdateOperationsInput | string
    images?: FutsalImageUncheckedUpdateManyWithoutFutsalNestedInput
    PriceLists?: PriceListsUncheckedUpdateManyWithoutFutsalsNestedInput
    Bookings?: BookingsUncheckedUpdateManyWithoutFutsalsNestedInput
    timeSlots?: TimeSlotsUncheckedUpdateManyWithoutFutsalsNestedInput
  }

  export type BookingsUpsertWithWhereUniqueWithoutUsersInput = {
    where: BookingsWhereUniqueInput
    update: XOR<BookingsUpdateWithoutUsersInput, BookingsUncheckedUpdateWithoutUsersInput>
    create: XOR<BookingsCreateWithoutUsersInput, BookingsUncheckedCreateWithoutUsersInput>
  }

  export type BookingsUpdateWithWhereUniqueWithoutUsersInput = {
    where: BookingsWhereUniqueInput
    data: XOR<BookingsUpdateWithoutUsersInput, BookingsUncheckedUpdateWithoutUsersInput>
  }

  export type BookingsUpdateManyWithWhereWithoutUsersInput = {
    where: BookingsScalarWhereInput
    data: XOR<BookingsUpdateManyMutationInput, BookingsUncheckedUpdateManyWithoutUsersInput>
  }

  export type BookingsScalarWhereInput = {
    AND?: BookingsScalarWhereInput | BookingsScalarWhereInput[]
    OR?: BookingsScalarWhereInput[]
    NOT?: BookingsScalarWhereInput | BookingsScalarWhereInput[]
    id?: IntFilter<"Bookings"> | number
    userId?: IntFilter<"Bookings"> | number
    futsalId?: IntFilter<"Bookings"> | number
    bookDate?: DateTimeFilter<"Bookings"> | Date | string
    startTime?: DateTimeFilter<"Bookings"> | Date | string
    endTime?: DateTimeFilter<"Bookings"> | Date | string
    type?: EnumFutsalTypeFilter<"Bookings"> | $Enums.FutsalType
    price?: IntFilter<"Bookings"> | number
    confirmation?: EnumBookingStatusFilter<"Bookings"> | $Enums.BookingStatus
    paymentStatus?: EnumPaymentFilter<"Bookings"> | $Enums.Payment
  }

  export type MatchRequestUpsertWithoutUsersInput = {
    update: XOR<MatchRequestUpdateWithoutUsersInput, MatchRequestUncheckedUpdateWithoutUsersInput>
    create: XOR<MatchRequestCreateWithoutUsersInput, MatchRequestUncheckedCreateWithoutUsersInput>
    where?: MatchRequestWhereInput
  }

  export type MatchRequestUpdateToOneWithWhereWithoutUsersInput = {
    where?: MatchRequestWhereInput
    data: XOR<MatchRequestUpdateWithoutUsersInput, MatchRequestUncheckedUpdateWithoutUsersInput>
  }

  export type MatchRequestUpdateWithoutUsersInput = {
    futsalName?: StringFieldUpdateOperationsInput | string
    futsalType?: EnumFutsalTypeFieldUpdateOperationsInput | $Enums.FutsalType
    matchDate?: DateTimeFieldUpdateOperationsInput | Date | string
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: DateTimeFieldUpdateOperationsInput | Date | string
    matchType?: StringFieldUpdateOperationsInput | string
    status?: EnumRequestStatusFieldUpdateOperationsInput | $Enums.RequestStatus
  }

  export type MatchRequestUncheckedUpdateWithoutUsersInput = {
    id?: IntFieldUpdateOperationsInput | number
    futsalName?: StringFieldUpdateOperationsInput | string
    futsalType?: EnumFutsalTypeFieldUpdateOperationsInput | $Enums.FutsalType
    matchDate?: DateTimeFieldUpdateOperationsInput | Date | string
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: DateTimeFieldUpdateOperationsInput | Date | string
    matchType?: StringFieldUpdateOperationsInput | string
    status?: EnumRequestStatusFieldUpdateOperationsInput | $Enums.RequestStatus
  }

  export type MatchesUpsertWithWhereUniqueWithoutOrganizerInput = {
    where: MatchesWhereUniqueInput
    update: XOR<MatchesUpdateWithoutOrganizerInput, MatchesUncheckedUpdateWithoutOrganizerInput>
    create: XOR<MatchesCreateWithoutOrganizerInput, MatchesUncheckedCreateWithoutOrganizerInput>
  }

  export type MatchesUpdateWithWhereUniqueWithoutOrganizerInput = {
    where: MatchesWhereUniqueInput
    data: XOR<MatchesUpdateWithoutOrganizerInput, MatchesUncheckedUpdateWithoutOrganizerInput>
  }

  export type MatchesUpdateManyWithWhereWithoutOrganizerInput = {
    where: MatchesScalarWhereInput
    data: XOR<MatchesUpdateManyMutationInput, MatchesUncheckedUpdateManyWithoutOrganizerInput>
  }

  export type MatchesScalarWhereInput = {
    AND?: MatchesScalarWhereInput | MatchesScalarWhereInput[]
    OR?: MatchesScalarWhereInput[]
    NOT?: MatchesScalarWhereInput | MatchesScalarWhereInput[]
    id?: IntFilter<"Matches"> | number
    futsalName?: StringFilter<"Matches"> | string
    futsalType?: EnumFutsalTypeFilter<"Matches"> | $Enums.FutsalType
    matchType?: StringFilter<"Matches"> | string
    matchDate?: DateTimeFilter<"Matches"> | Date | string
    startTime?: DateTimeFilter<"Matches"> | Date | string
    endTime?: DateTimeFilter<"Matches"> | Date | string
    status?: EnumMatchStatusFilter<"Matches"> | $Enums.MatchStatus
    organizerId?: IntFilter<"Matches"> | number
    opponentId?: IntFilter<"Matches"> | number
  }

  export type MatchesUpsertWithWhereUniqueWithoutOpponentInput = {
    where: MatchesWhereUniqueInput
    update: XOR<MatchesUpdateWithoutOpponentInput, MatchesUncheckedUpdateWithoutOpponentInput>
    create: XOR<MatchesCreateWithoutOpponentInput, MatchesUncheckedCreateWithoutOpponentInput>
  }

  export type MatchesUpdateWithWhereUniqueWithoutOpponentInput = {
    where: MatchesWhereUniqueInput
    data: XOR<MatchesUpdateWithoutOpponentInput, MatchesUncheckedUpdateWithoutOpponentInput>
  }

  export type MatchesUpdateManyWithWhereWithoutOpponentInput = {
    where: MatchesScalarWhereInput
    data: XOR<MatchesUpdateManyMutationInput, MatchesUncheckedUpdateManyWithoutOpponentInput>
  }

  export type FutsalImageCreateWithoutFutsalInput = {
    url: string
  }

  export type FutsalImageUncheckedCreateWithoutFutsalInput = {
    id?: number
    url: string
  }

  export type FutsalImageCreateOrConnectWithoutFutsalInput = {
    where: FutsalImageWhereUniqueInput
    create: XOR<FutsalImageCreateWithoutFutsalInput, FutsalImageUncheckedCreateWithoutFutsalInput>
  }

  export type FutsalImageCreateManyFutsalInputEnvelope = {
    data: FutsalImageCreateManyFutsalInput | FutsalImageCreateManyFutsalInput[]
    skipDuplicates?: boolean
  }

  export type UsersCreateWithoutFutsalsInput = {
    googleId?: string | null
    facebookId?: string | null
    name: string
    email: string
    phone: string
    image?: string | null
    password: string
    address: string
    roles: RolesCreateNestedOneWithoutUsersInput
    Bookings?: BookingsCreateNestedManyWithoutUsersInput
    MatchRequest?: MatchRequestCreateNestedOneWithoutUsersInput
    organizedMatches?: MatchesCreateNestedManyWithoutOrganizerInput
    opponentMatches?: MatchesCreateNestedManyWithoutOpponentInput
  }

  export type UsersUncheckedCreateWithoutFutsalsInput = {
    id?: number
    googleId?: string | null
    facebookId?: string | null
    name: string
    email: string
    phone: string
    image?: string | null
    password: string
    address: string
    roleId: number
    Bookings?: BookingsUncheckedCreateNestedManyWithoutUsersInput
    MatchRequest?: MatchRequestUncheckedCreateNestedOneWithoutUsersInput
    organizedMatches?: MatchesUncheckedCreateNestedManyWithoutOrganizerInput
    opponentMatches?: MatchesUncheckedCreateNestedManyWithoutOpponentInput
  }

  export type UsersCreateOrConnectWithoutFutsalsInput = {
    where: UsersWhereUniqueInput
    create: XOR<UsersCreateWithoutFutsalsInput, UsersUncheckedCreateWithoutFutsalsInput>
  }

  export type PriceListsCreateWithoutFutsalsInput = {
    startTime: Date | string
    endTime: Date | string
    dayOfWeek: string
    price: number
  }

  export type PriceListsUncheckedCreateWithoutFutsalsInput = {
    id?: number
    startTime: Date | string
    endTime: Date | string
    dayOfWeek: string
    price: number
  }

  export type PriceListsCreateOrConnectWithoutFutsalsInput = {
    where: PriceListsWhereUniqueInput
    create: XOR<PriceListsCreateWithoutFutsalsInput, PriceListsUncheckedCreateWithoutFutsalsInput>
  }

  export type PriceListsCreateManyFutsalsInputEnvelope = {
    data: PriceListsCreateManyFutsalsInput | PriceListsCreateManyFutsalsInput[]
    skipDuplicates?: boolean
  }

  export type BookingsCreateWithoutFutsalsInput = {
    bookDate: Date | string
    startTime: Date | string
    endTime: Date | string
    type: $Enums.FutsalType
    price: number
    confirmation?: $Enums.BookingStatus
    paymentStatus?: $Enums.Payment
    users: UsersCreateNestedOneWithoutBookingsInput
  }

  export type BookingsUncheckedCreateWithoutFutsalsInput = {
    id?: number
    userId: number
    bookDate: Date | string
    startTime: Date | string
    endTime: Date | string
    type: $Enums.FutsalType
    price: number
    confirmation?: $Enums.BookingStatus
    paymentStatus?: $Enums.Payment
  }

  export type BookingsCreateOrConnectWithoutFutsalsInput = {
    where: BookingsWhereUniqueInput
    create: XOR<BookingsCreateWithoutFutsalsInput, BookingsUncheckedCreateWithoutFutsalsInput>
  }

  export type BookingsCreateManyFutsalsInputEnvelope = {
    data: BookingsCreateManyFutsalsInput | BookingsCreateManyFutsalsInput[]
    skipDuplicates?: boolean
  }

  export type TimeSlotsCreateWithoutFutsalsInput = {
    startTime: Date | string
    endTime: Date | string
    date: Date | string
    price: number
    futsalType: $Enums.FutsalType
  }

  export type TimeSlotsUncheckedCreateWithoutFutsalsInput = {
    id?: number
    startTime: Date | string
    endTime: Date | string
    date: Date | string
    price: number
    futsalType: $Enums.FutsalType
  }

  export type TimeSlotsCreateOrConnectWithoutFutsalsInput = {
    where: TimeSlotsWhereUniqueInput
    create: XOR<TimeSlotsCreateWithoutFutsalsInput, TimeSlotsUncheckedCreateWithoutFutsalsInput>
  }

  export type TimeSlotsCreateManyFutsalsInputEnvelope = {
    data: TimeSlotsCreateManyFutsalsInput | TimeSlotsCreateManyFutsalsInput[]
    skipDuplicates?: boolean
  }

  export type FutsalImageUpsertWithWhereUniqueWithoutFutsalInput = {
    where: FutsalImageWhereUniqueInput
    update: XOR<FutsalImageUpdateWithoutFutsalInput, FutsalImageUncheckedUpdateWithoutFutsalInput>
    create: XOR<FutsalImageCreateWithoutFutsalInput, FutsalImageUncheckedCreateWithoutFutsalInput>
  }

  export type FutsalImageUpdateWithWhereUniqueWithoutFutsalInput = {
    where: FutsalImageWhereUniqueInput
    data: XOR<FutsalImageUpdateWithoutFutsalInput, FutsalImageUncheckedUpdateWithoutFutsalInput>
  }

  export type FutsalImageUpdateManyWithWhereWithoutFutsalInput = {
    where: FutsalImageScalarWhereInput
    data: XOR<FutsalImageUpdateManyMutationInput, FutsalImageUncheckedUpdateManyWithoutFutsalInput>
  }

  export type FutsalImageScalarWhereInput = {
    AND?: FutsalImageScalarWhereInput | FutsalImageScalarWhereInput[]
    OR?: FutsalImageScalarWhereInput[]
    NOT?: FutsalImageScalarWhereInput | FutsalImageScalarWhereInput[]
    id?: IntFilter<"FutsalImage"> | number
    url?: StringFilter<"FutsalImage"> | string
    futsalId?: IntFilter<"FutsalImage"> | number
  }

  export type UsersUpsertWithoutFutsalsInput = {
    update: XOR<UsersUpdateWithoutFutsalsInput, UsersUncheckedUpdateWithoutFutsalsInput>
    create: XOR<UsersCreateWithoutFutsalsInput, UsersUncheckedCreateWithoutFutsalsInput>
    where?: UsersWhereInput
  }

  export type UsersUpdateToOneWithWhereWithoutFutsalsInput = {
    where?: UsersWhereInput
    data: XOR<UsersUpdateWithoutFutsalsInput, UsersUncheckedUpdateWithoutFutsalsInput>
  }

  export type UsersUpdateWithoutFutsalsInput = {
    googleId?: NullableStringFieldUpdateOperationsInput | string | null
    facebookId?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    image?: NullableStringFieldUpdateOperationsInput | string | null
    password?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    roles?: RolesUpdateOneRequiredWithoutUsersNestedInput
    Bookings?: BookingsUpdateManyWithoutUsersNestedInput
    MatchRequest?: MatchRequestUpdateOneWithoutUsersNestedInput
    organizedMatches?: MatchesUpdateManyWithoutOrganizerNestedInput
    opponentMatches?: MatchesUpdateManyWithoutOpponentNestedInput
  }

  export type UsersUncheckedUpdateWithoutFutsalsInput = {
    id?: IntFieldUpdateOperationsInput | number
    googleId?: NullableStringFieldUpdateOperationsInput | string | null
    facebookId?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    image?: NullableStringFieldUpdateOperationsInput | string | null
    password?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    roleId?: IntFieldUpdateOperationsInput | number
    Bookings?: BookingsUncheckedUpdateManyWithoutUsersNestedInput
    MatchRequest?: MatchRequestUncheckedUpdateOneWithoutUsersNestedInput
    organizedMatches?: MatchesUncheckedUpdateManyWithoutOrganizerNestedInput
    opponentMatches?: MatchesUncheckedUpdateManyWithoutOpponentNestedInput
  }

  export type PriceListsUpsertWithWhereUniqueWithoutFutsalsInput = {
    where: PriceListsWhereUniqueInput
    update: XOR<PriceListsUpdateWithoutFutsalsInput, PriceListsUncheckedUpdateWithoutFutsalsInput>
    create: XOR<PriceListsCreateWithoutFutsalsInput, PriceListsUncheckedCreateWithoutFutsalsInput>
  }

  export type PriceListsUpdateWithWhereUniqueWithoutFutsalsInput = {
    where: PriceListsWhereUniqueInput
    data: XOR<PriceListsUpdateWithoutFutsalsInput, PriceListsUncheckedUpdateWithoutFutsalsInput>
  }

  export type PriceListsUpdateManyWithWhereWithoutFutsalsInput = {
    where: PriceListsScalarWhereInput
    data: XOR<PriceListsUpdateManyMutationInput, PriceListsUncheckedUpdateManyWithoutFutsalsInput>
  }

  export type PriceListsScalarWhereInput = {
    AND?: PriceListsScalarWhereInput | PriceListsScalarWhereInput[]
    OR?: PriceListsScalarWhereInput[]
    NOT?: PriceListsScalarWhereInput | PriceListsScalarWhereInput[]
    id?: IntFilter<"PriceLists"> | number
    startTime?: DateTimeFilter<"PriceLists"> | Date | string
    endTime?: DateTimeFilter<"PriceLists"> | Date | string
    dayOfWeek?: StringFilter<"PriceLists"> | string
    price?: IntFilter<"PriceLists"> | number
    futsalId?: IntFilter<"PriceLists"> | number
  }

  export type BookingsUpsertWithWhereUniqueWithoutFutsalsInput = {
    where: BookingsWhereUniqueInput
    update: XOR<BookingsUpdateWithoutFutsalsInput, BookingsUncheckedUpdateWithoutFutsalsInput>
    create: XOR<BookingsCreateWithoutFutsalsInput, BookingsUncheckedCreateWithoutFutsalsInput>
  }

  export type BookingsUpdateWithWhereUniqueWithoutFutsalsInput = {
    where: BookingsWhereUniqueInput
    data: XOR<BookingsUpdateWithoutFutsalsInput, BookingsUncheckedUpdateWithoutFutsalsInput>
  }

  export type BookingsUpdateManyWithWhereWithoutFutsalsInput = {
    where: BookingsScalarWhereInput
    data: XOR<BookingsUpdateManyMutationInput, BookingsUncheckedUpdateManyWithoutFutsalsInput>
  }

  export type TimeSlotsUpsertWithWhereUniqueWithoutFutsalsInput = {
    where: TimeSlotsWhereUniqueInput
    update: XOR<TimeSlotsUpdateWithoutFutsalsInput, TimeSlotsUncheckedUpdateWithoutFutsalsInput>
    create: XOR<TimeSlotsCreateWithoutFutsalsInput, TimeSlotsUncheckedCreateWithoutFutsalsInput>
  }

  export type TimeSlotsUpdateWithWhereUniqueWithoutFutsalsInput = {
    where: TimeSlotsWhereUniqueInput
    data: XOR<TimeSlotsUpdateWithoutFutsalsInput, TimeSlotsUncheckedUpdateWithoutFutsalsInput>
  }

  export type TimeSlotsUpdateManyWithWhereWithoutFutsalsInput = {
    where: TimeSlotsScalarWhereInput
    data: XOR<TimeSlotsUpdateManyMutationInput, TimeSlotsUncheckedUpdateManyWithoutFutsalsInput>
  }

  export type TimeSlotsScalarWhereInput = {
    AND?: TimeSlotsScalarWhereInput | TimeSlotsScalarWhereInput[]
    OR?: TimeSlotsScalarWhereInput[]
    NOT?: TimeSlotsScalarWhereInput | TimeSlotsScalarWhereInput[]
    id?: IntFilter<"TimeSlots"> | number
    startTime?: DateTimeFilter<"TimeSlots"> | Date | string
    endTime?: DateTimeFilter<"TimeSlots"> | Date | string
    date?: DateTimeFilter<"TimeSlots"> | Date | string
    price?: IntFilter<"TimeSlots"> | number
    futsalType?: EnumFutsalTypeFilter<"TimeSlots"> | $Enums.FutsalType
    futsalId?: IntFilter<"TimeSlots"> | number
  }

  export type FutsalsCreateWithoutImagesInput = {
    name: string
    phone: string
    address: string
    type: $Enums.FutsalType
    startTime: Date | string
    endTime: Date | string
    amenities?: FutsalsCreateamenitiesInput | string[]
    stdPrice: number
    rating: Decimal | DecimalJsLike | number | string
    pan: string
    users: UsersCreateNestedOneWithoutFutsalsInput
    PriceLists?: PriceListsCreateNestedManyWithoutFutsalsInput
    Bookings?: BookingsCreateNestedManyWithoutFutsalsInput
    timeSlots?: TimeSlotsCreateNestedManyWithoutFutsalsInput
  }

  export type FutsalsUncheckedCreateWithoutImagesInput = {
    id?: number
    name: string
    phone: string
    address: string
    type: $Enums.FutsalType
    startTime: Date | string
    endTime: Date | string
    amenities?: FutsalsCreateamenitiesInput | string[]
    stdPrice: number
    rating: Decimal | DecimalJsLike | number | string
    pan: string
    userId: number
    PriceLists?: PriceListsUncheckedCreateNestedManyWithoutFutsalsInput
    Bookings?: BookingsUncheckedCreateNestedManyWithoutFutsalsInput
    timeSlots?: TimeSlotsUncheckedCreateNestedManyWithoutFutsalsInput
  }

  export type FutsalsCreateOrConnectWithoutImagesInput = {
    where: FutsalsWhereUniqueInput
    create: XOR<FutsalsCreateWithoutImagesInput, FutsalsUncheckedCreateWithoutImagesInput>
  }

  export type FutsalsUpsertWithoutImagesInput = {
    update: XOR<FutsalsUpdateWithoutImagesInput, FutsalsUncheckedUpdateWithoutImagesInput>
    create: XOR<FutsalsCreateWithoutImagesInput, FutsalsUncheckedCreateWithoutImagesInput>
    where?: FutsalsWhereInput
  }

  export type FutsalsUpdateToOneWithWhereWithoutImagesInput = {
    where?: FutsalsWhereInput
    data: XOR<FutsalsUpdateWithoutImagesInput, FutsalsUncheckedUpdateWithoutImagesInput>
  }

  export type FutsalsUpdateWithoutImagesInput = {
    name?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    type?: EnumFutsalTypeFieldUpdateOperationsInput | $Enums.FutsalType
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: DateTimeFieldUpdateOperationsInput | Date | string
    amenities?: FutsalsUpdateamenitiesInput | string[]
    stdPrice?: IntFieldUpdateOperationsInput | number
    rating?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    pan?: StringFieldUpdateOperationsInput | string
    users?: UsersUpdateOneRequiredWithoutFutsalsNestedInput
    PriceLists?: PriceListsUpdateManyWithoutFutsalsNestedInput
    Bookings?: BookingsUpdateManyWithoutFutsalsNestedInput
    timeSlots?: TimeSlotsUpdateManyWithoutFutsalsNestedInput
  }

  export type FutsalsUncheckedUpdateWithoutImagesInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    type?: EnumFutsalTypeFieldUpdateOperationsInput | $Enums.FutsalType
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: DateTimeFieldUpdateOperationsInput | Date | string
    amenities?: FutsalsUpdateamenitiesInput | string[]
    stdPrice?: IntFieldUpdateOperationsInput | number
    rating?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    pan?: StringFieldUpdateOperationsInput | string
    userId?: IntFieldUpdateOperationsInput | number
    PriceLists?: PriceListsUncheckedUpdateManyWithoutFutsalsNestedInput
    Bookings?: BookingsUncheckedUpdateManyWithoutFutsalsNestedInput
    timeSlots?: TimeSlotsUncheckedUpdateManyWithoutFutsalsNestedInput
  }

  export type FutsalsCreateWithoutPriceListsInput = {
    name: string
    phone: string
    address: string
    type: $Enums.FutsalType
    startTime: Date | string
    endTime: Date | string
    amenities?: FutsalsCreateamenitiesInput | string[]
    stdPrice: number
    rating: Decimal | DecimalJsLike | number | string
    pan: string
    images?: FutsalImageCreateNestedManyWithoutFutsalInput
    users: UsersCreateNestedOneWithoutFutsalsInput
    Bookings?: BookingsCreateNestedManyWithoutFutsalsInput
    timeSlots?: TimeSlotsCreateNestedManyWithoutFutsalsInput
  }

  export type FutsalsUncheckedCreateWithoutPriceListsInput = {
    id?: number
    name: string
    phone: string
    address: string
    type: $Enums.FutsalType
    startTime: Date | string
    endTime: Date | string
    amenities?: FutsalsCreateamenitiesInput | string[]
    stdPrice: number
    rating: Decimal | DecimalJsLike | number | string
    pan: string
    userId: number
    images?: FutsalImageUncheckedCreateNestedManyWithoutFutsalInput
    Bookings?: BookingsUncheckedCreateNestedManyWithoutFutsalsInput
    timeSlots?: TimeSlotsUncheckedCreateNestedManyWithoutFutsalsInput
  }

  export type FutsalsCreateOrConnectWithoutPriceListsInput = {
    where: FutsalsWhereUniqueInput
    create: XOR<FutsalsCreateWithoutPriceListsInput, FutsalsUncheckedCreateWithoutPriceListsInput>
  }

  export type FutsalsUpsertWithoutPriceListsInput = {
    update: XOR<FutsalsUpdateWithoutPriceListsInput, FutsalsUncheckedUpdateWithoutPriceListsInput>
    create: XOR<FutsalsCreateWithoutPriceListsInput, FutsalsUncheckedCreateWithoutPriceListsInput>
    where?: FutsalsWhereInput
  }

  export type FutsalsUpdateToOneWithWhereWithoutPriceListsInput = {
    where?: FutsalsWhereInput
    data: XOR<FutsalsUpdateWithoutPriceListsInput, FutsalsUncheckedUpdateWithoutPriceListsInput>
  }

  export type FutsalsUpdateWithoutPriceListsInput = {
    name?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    type?: EnumFutsalTypeFieldUpdateOperationsInput | $Enums.FutsalType
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: DateTimeFieldUpdateOperationsInput | Date | string
    amenities?: FutsalsUpdateamenitiesInput | string[]
    stdPrice?: IntFieldUpdateOperationsInput | number
    rating?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    pan?: StringFieldUpdateOperationsInput | string
    images?: FutsalImageUpdateManyWithoutFutsalNestedInput
    users?: UsersUpdateOneRequiredWithoutFutsalsNestedInput
    Bookings?: BookingsUpdateManyWithoutFutsalsNestedInput
    timeSlots?: TimeSlotsUpdateManyWithoutFutsalsNestedInput
  }

  export type FutsalsUncheckedUpdateWithoutPriceListsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    type?: EnumFutsalTypeFieldUpdateOperationsInput | $Enums.FutsalType
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: DateTimeFieldUpdateOperationsInput | Date | string
    amenities?: FutsalsUpdateamenitiesInput | string[]
    stdPrice?: IntFieldUpdateOperationsInput | number
    rating?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    pan?: StringFieldUpdateOperationsInput | string
    userId?: IntFieldUpdateOperationsInput | number
    images?: FutsalImageUncheckedUpdateManyWithoutFutsalNestedInput
    Bookings?: BookingsUncheckedUpdateManyWithoutFutsalsNestedInput
    timeSlots?: TimeSlotsUncheckedUpdateManyWithoutFutsalsNestedInput
  }

  export type UsersCreateWithoutBookingsInput = {
    googleId?: string | null
    facebookId?: string | null
    name: string
    email: string
    phone: string
    image?: string | null
    password: string
    address: string
    roles: RolesCreateNestedOneWithoutUsersInput
    Futsals?: FutsalsCreateNestedOneWithoutUsersInput
    MatchRequest?: MatchRequestCreateNestedOneWithoutUsersInput
    organizedMatches?: MatchesCreateNestedManyWithoutOrganizerInput
    opponentMatches?: MatchesCreateNestedManyWithoutOpponentInput
  }

  export type UsersUncheckedCreateWithoutBookingsInput = {
    id?: number
    googleId?: string | null
    facebookId?: string | null
    name: string
    email: string
    phone: string
    image?: string | null
    password: string
    address: string
    roleId: number
    Futsals?: FutsalsUncheckedCreateNestedOneWithoutUsersInput
    MatchRequest?: MatchRequestUncheckedCreateNestedOneWithoutUsersInput
    organizedMatches?: MatchesUncheckedCreateNestedManyWithoutOrganizerInput
    opponentMatches?: MatchesUncheckedCreateNestedManyWithoutOpponentInput
  }

  export type UsersCreateOrConnectWithoutBookingsInput = {
    where: UsersWhereUniqueInput
    create: XOR<UsersCreateWithoutBookingsInput, UsersUncheckedCreateWithoutBookingsInput>
  }

  export type FutsalsCreateWithoutBookingsInput = {
    name: string
    phone: string
    address: string
    type: $Enums.FutsalType
    startTime: Date | string
    endTime: Date | string
    amenities?: FutsalsCreateamenitiesInput | string[]
    stdPrice: number
    rating: Decimal | DecimalJsLike | number | string
    pan: string
    images?: FutsalImageCreateNestedManyWithoutFutsalInput
    users: UsersCreateNestedOneWithoutFutsalsInput
    PriceLists?: PriceListsCreateNestedManyWithoutFutsalsInput
    timeSlots?: TimeSlotsCreateNestedManyWithoutFutsalsInput
  }

  export type FutsalsUncheckedCreateWithoutBookingsInput = {
    id?: number
    name: string
    phone: string
    address: string
    type: $Enums.FutsalType
    startTime: Date | string
    endTime: Date | string
    amenities?: FutsalsCreateamenitiesInput | string[]
    stdPrice: number
    rating: Decimal | DecimalJsLike | number | string
    pan: string
    userId: number
    images?: FutsalImageUncheckedCreateNestedManyWithoutFutsalInput
    PriceLists?: PriceListsUncheckedCreateNestedManyWithoutFutsalsInput
    timeSlots?: TimeSlotsUncheckedCreateNestedManyWithoutFutsalsInput
  }

  export type FutsalsCreateOrConnectWithoutBookingsInput = {
    where: FutsalsWhereUniqueInput
    create: XOR<FutsalsCreateWithoutBookingsInput, FutsalsUncheckedCreateWithoutBookingsInput>
  }

  export type UsersUpsertWithoutBookingsInput = {
    update: XOR<UsersUpdateWithoutBookingsInput, UsersUncheckedUpdateWithoutBookingsInput>
    create: XOR<UsersCreateWithoutBookingsInput, UsersUncheckedCreateWithoutBookingsInput>
    where?: UsersWhereInput
  }

  export type UsersUpdateToOneWithWhereWithoutBookingsInput = {
    where?: UsersWhereInput
    data: XOR<UsersUpdateWithoutBookingsInput, UsersUncheckedUpdateWithoutBookingsInput>
  }

  export type UsersUpdateWithoutBookingsInput = {
    googleId?: NullableStringFieldUpdateOperationsInput | string | null
    facebookId?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    image?: NullableStringFieldUpdateOperationsInput | string | null
    password?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    roles?: RolesUpdateOneRequiredWithoutUsersNestedInput
    Futsals?: FutsalsUpdateOneWithoutUsersNestedInput
    MatchRequest?: MatchRequestUpdateOneWithoutUsersNestedInput
    organizedMatches?: MatchesUpdateManyWithoutOrganizerNestedInput
    opponentMatches?: MatchesUpdateManyWithoutOpponentNestedInput
  }

  export type UsersUncheckedUpdateWithoutBookingsInput = {
    id?: IntFieldUpdateOperationsInput | number
    googleId?: NullableStringFieldUpdateOperationsInput | string | null
    facebookId?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    image?: NullableStringFieldUpdateOperationsInput | string | null
    password?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    roleId?: IntFieldUpdateOperationsInput | number
    Futsals?: FutsalsUncheckedUpdateOneWithoutUsersNestedInput
    MatchRequest?: MatchRequestUncheckedUpdateOneWithoutUsersNestedInput
    organizedMatches?: MatchesUncheckedUpdateManyWithoutOrganizerNestedInput
    opponentMatches?: MatchesUncheckedUpdateManyWithoutOpponentNestedInput
  }

  export type FutsalsUpsertWithoutBookingsInput = {
    update: XOR<FutsalsUpdateWithoutBookingsInput, FutsalsUncheckedUpdateWithoutBookingsInput>
    create: XOR<FutsalsCreateWithoutBookingsInput, FutsalsUncheckedCreateWithoutBookingsInput>
    where?: FutsalsWhereInput
  }

  export type FutsalsUpdateToOneWithWhereWithoutBookingsInput = {
    where?: FutsalsWhereInput
    data: XOR<FutsalsUpdateWithoutBookingsInput, FutsalsUncheckedUpdateWithoutBookingsInput>
  }

  export type FutsalsUpdateWithoutBookingsInput = {
    name?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    type?: EnumFutsalTypeFieldUpdateOperationsInput | $Enums.FutsalType
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: DateTimeFieldUpdateOperationsInput | Date | string
    amenities?: FutsalsUpdateamenitiesInput | string[]
    stdPrice?: IntFieldUpdateOperationsInput | number
    rating?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    pan?: StringFieldUpdateOperationsInput | string
    images?: FutsalImageUpdateManyWithoutFutsalNestedInput
    users?: UsersUpdateOneRequiredWithoutFutsalsNestedInput
    PriceLists?: PriceListsUpdateManyWithoutFutsalsNestedInput
    timeSlots?: TimeSlotsUpdateManyWithoutFutsalsNestedInput
  }

  export type FutsalsUncheckedUpdateWithoutBookingsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    type?: EnumFutsalTypeFieldUpdateOperationsInput | $Enums.FutsalType
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: DateTimeFieldUpdateOperationsInput | Date | string
    amenities?: FutsalsUpdateamenitiesInput | string[]
    stdPrice?: IntFieldUpdateOperationsInput | number
    rating?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    pan?: StringFieldUpdateOperationsInput | string
    userId?: IntFieldUpdateOperationsInput | number
    images?: FutsalImageUncheckedUpdateManyWithoutFutsalNestedInput
    PriceLists?: PriceListsUncheckedUpdateManyWithoutFutsalsNestedInput
    timeSlots?: TimeSlotsUncheckedUpdateManyWithoutFutsalsNestedInput
  }

  export type FutsalsCreateWithoutTimeSlotsInput = {
    name: string
    phone: string
    address: string
    type: $Enums.FutsalType
    startTime: Date | string
    endTime: Date | string
    amenities?: FutsalsCreateamenitiesInput | string[]
    stdPrice: number
    rating: Decimal | DecimalJsLike | number | string
    pan: string
    images?: FutsalImageCreateNestedManyWithoutFutsalInput
    users: UsersCreateNestedOneWithoutFutsalsInput
    PriceLists?: PriceListsCreateNestedManyWithoutFutsalsInput
    Bookings?: BookingsCreateNestedManyWithoutFutsalsInput
  }

  export type FutsalsUncheckedCreateWithoutTimeSlotsInput = {
    id?: number
    name: string
    phone: string
    address: string
    type: $Enums.FutsalType
    startTime: Date | string
    endTime: Date | string
    amenities?: FutsalsCreateamenitiesInput | string[]
    stdPrice: number
    rating: Decimal | DecimalJsLike | number | string
    pan: string
    userId: number
    images?: FutsalImageUncheckedCreateNestedManyWithoutFutsalInput
    PriceLists?: PriceListsUncheckedCreateNestedManyWithoutFutsalsInput
    Bookings?: BookingsUncheckedCreateNestedManyWithoutFutsalsInput
  }

  export type FutsalsCreateOrConnectWithoutTimeSlotsInput = {
    where: FutsalsWhereUniqueInput
    create: XOR<FutsalsCreateWithoutTimeSlotsInput, FutsalsUncheckedCreateWithoutTimeSlotsInput>
  }

  export type FutsalsUpsertWithoutTimeSlotsInput = {
    update: XOR<FutsalsUpdateWithoutTimeSlotsInput, FutsalsUncheckedUpdateWithoutTimeSlotsInput>
    create: XOR<FutsalsCreateWithoutTimeSlotsInput, FutsalsUncheckedCreateWithoutTimeSlotsInput>
    where?: FutsalsWhereInput
  }

  export type FutsalsUpdateToOneWithWhereWithoutTimeSlotsInput = {
    where?: FutsalsWhereInput
    data: XOR<FutsalsUpdateWithoutTimeSlotsInput, FutsalsUncheckedUpdateWithoutTimeSlotsInput>
  }

  export type FutsalsUpdateWithoutTimeSlotsInput = {
    name?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    type?: EnumFutsalTypeFieldUpdateOperationsInput | $Enums.FutsalType
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: DateTimeFieldUpdateOperationsInput | Date | string
    amenities?: FutsalsUpdateamenitiesInput | string[]
    stdPrice?: IntFieldUpdateOperationsInput | number
    rating?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    pan?: StringFieldUpdateOperationsInput | string
    images?: FutsalImageUpdateManyWithoutFutsalNestedInput
    users?: UsersUpdateOneRequiredWithoutFutsalsNestedInput
    PriceLists?: PriceListsUpdateManyWithoutFutsalsNestedInput
    Bookings?: BookingsUpdateManyWithoutFutsalsNestedInput
  }

  export type FutsalsUncheckedUpdateWithoutTimeSlotsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    type?: EnumFutsalTypeFieldUpdateOperationsInput | $Enums.FutsalType
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: DateTimeFieldUpdateOperationsInput | Date | string
    amenities?: FutsalsUpdateamenitiesInput | string[]
    stdPrice?: IntFieldUpdateOperationsInput | number
    rating?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    pan?: StringFieldUpdateOperationsInput | string
    userId?: IntFieldUpdateOperationsInput | number
    images?: FutsalImageUncheckedUpdateManyWithoutFutsalNestedInput
    PriceLists?: PriceListsUncheckedUpdateManyWithoutFutsalsNestedInput
    Bookings?: BookingsUncheckedUpdateManyWithoutFutsalsNestedInput
  }

  export type UsersCreateWithoutMatchRequestInput = {
    googleId?: string | null
    facebookId?: string | null
    name: string
    email: string
    phone: string
    image?: string | null
    password: string
    address: string
    roles: RolesCreateNestedOneWithoutUsersInput
    Futsals?: FutsalsCreateNestedOneWithoutUsersInput
    Bookings?: BookingsCreateNestedManyWithoutUsersInput
    organizedMatches?: MatchesCreateNestedManyWithoutOrganizerInput
    opponentMatches?: MatchesCreateNestedManyWithoutOpponentInput
  }

  export type UsersUncheckedCreateWithoutMatchRequestInput = {
    id?: number
    googleId?: string | null
    facebookId?: string | null
    name: string
    email: string
    phone: string
    image?: string | null
    password: string
    address: string
    roleId: number
    Futsals?: FutsalsUncheckedCreateNestedOneWithoutUsersInput
    Bookings?: BookingsUncheckedCreateNestedManyWithoutUsersInput
    organizedMatches?: MatchesUncheckedCreateNestedManyWithoutOrganizerInput
    opponentMatches?: MatchesUncheckedCreateNestedManyWithoutOpponentInput
  }

  export type UsersCreateOrConnectWithoutMatchRequestInput = {
    where: UsersWhereUniqueInput
    create: XOR<UsersCreateWithoutMatchRequestInput, UsersUncheckedCreateWithoutMatchRequestInput>
  }

  export type UsersUpsertWithoutMatchRequestInput = {
    update: XOR<UsersUpdateWithoutMatchRequestInput, UsersUncheckedUpdateWithoutMatchRequestInput>
    create: XOR<UsersCreateWithoutMatchRequestInput, UsersUncheckedCreateWithoutMatchRequestInput>
    where?: UsersWhereInput
  }

  export type UsersUpdateToOneWithWhereWithoutMatchRequestInput = {
    where?: UsersWhereInput
    data: XOR<UsersUpdateWithoutMatchRequestInput, UsersUncheckedUpdateWithoutMatchRequestInput>
  }

  export type UsersUpdateWithoutMatchRequestInput = {
    googleId?: NullableStringFieldUpdateOperationsInput | string | null
    facebookId?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    image?: NullableStringFieldUpdateOperationsInput | string | null
    password?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    roles?: RolesUpdateOneRequiredWithoutUsersNestedInput
    Futsals?: FutsalsUpdateOneWithoutUsersNestedInput
    Bookings?: BookingsUpdateManyWithoutUsersNestedInput
    organizedMatches?: MatchesUpdateManyWithoutOrganizerNestedInput
    opponentMatches?: MatchesUpdateManyWithoutOpponentNestedInput
  }

  export type UsersUncheckedUpdateWithoutMatchRequestInput = {
    id?: IntFieldUpdateOperationsInput | number
    googleId?: NullableStringFieldUpdateOperationsInput | string | null
    facebookId?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    image?: NullableStringFieldUpdateOperationsInput | string | null
    password?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    roleId?: IntFieldUpdateOperationsInput | number
    Futsals?: FutsalsUncheckedUpdateOneWithoutUsersNestedInput
    Bookings?: BookingsUncheckedUpdateManyWithoutUsersNestedInput
    organizedMatches?: MatchesUncheckedUpdateManyWithoutOrganizerNestedInput
    opponentMatches?: MatchesUncheckedUpdateManyWithoutOpponentNestedInput
  }

  export type UsersCreateWithoutOrganizedMatchesInput = {
    googleId?: string | null
    facebookId?: string | null
    name: string
    email: string
    phone: string
    image?: string | null
    password: string
    address: string
    roles: RolesCreateNestedOneWithoutUsersInput
    Futsals?: FutsalsCreateNestedOneWithoutUsersInput
    Bookings?: BookingsCreateNestedManyWithoutUsersInput
    MatchRequest?: MatchRequestCreateNestedOneWithoutUsersInput
    opponentMatches?: MatchesCreateNestedManyWithoutOpponentInput
  }

  export type UsersUncheckedCreateWithoutOrganizedMatchesInput = {
    id?: number
    googleId?: string | null
    facebookId?: string | null
    name: string
    email: string
    phone: string
    image?: string | null
    password: string
    address: string
    roleId: number
    Futsals?: FutsalsUncheckedCreateNestedOneWithoutUsersInput
    Bookings?: BookingsUncheckedCreateNestedManyWithoutUsersInput
    MatchRequest?: MatchRequestUncheckedCreateNestedOneWithoutUsersInput
    opponentMatches?: MatchesUncheckedCreateNestedManyWithoutOpponentInput
  }

  export type UsersCreateOrConnectWithoutOrganizedMatchesInput = {
    where: UsersWhereUniqueInput
    create: XOR<UsersCreateWithoutOrganizedMatchesInput, UsersUncheckedCreateWithoutOrganizedMatchesInput>
  }

  export type UsersCreateWithoutOpponentMatchesInput = {
    googleId?: string | null
    facebookId?: string | null
    name: string
    email: string
    phone: string
    image?: string | null
    password: string
    address: string
    roles: RolesCreateNestedOneWithoutUsersInput
    Futsals?: FutsalsCreateNestedOneWithoutUsersInput
    Bookings?: BookingsCreateNestedManyWithoutUsersInput
    MatchRequest?: MatchRequestCreateNestedOneWithoutUsersInput
    organizedMatches?: MatchesCreateNestedManyWithoutOrganizerInput
  }

  export type UsersUncheckedCreateWithoutOpponentMatchesInput = {
    id?: number
    googleId?: string | null
    facebookId?: string | null
    name: string
    email: string
    phone: string
    image?: string | null
    password: string
    address: string
    roleId: number
    Futsals?: FutsalsUncheckedCreateNestedOneWithoutUsersInput
    Bookings?: BookingsUncheckedCreateNestedManyWithoutUsersInput
    MatchRequest?: MatchRequestUncheckedCreateNestedOneWithoutUsersInput
    organizedMatches?: MatchesUncheckedCreateNestedManyWithoutOrganizerInput
  }

  export type UsersCreateOrConnectWithoutOpponentMatchesInput = {
    where: UsersWhereUniqueInput
    create: XOR<UsersCreateWithoutOpponentMatchesInput, UsersUncheckedCreateWithoutOpponentMatchesInput>
  }

  export type UsersUpsertWithoutOrganizedMatchesInput = {
    update: XOR<UsersUpdateWithoutOrganizedMatchesInput, UsersUncheckedUpdateWithoutOrganizedMatchesInput>
    create: XOR<UsersCreateWithoutOrganizedMatchesInput, UsersUncheckedCreateWithoutOrganizedMatchesInput>
    where?: UsersWhereInput
  }

  export type UsersUpdateToOneWithWhereWithoutOrganizedMatchesInput = {
    where?: UsersWhereInput
    data: XOR<UsersUpdateWithoutOrganizedMatchesInput, UsersUncheckedUpdateWithoutOrganizedMatchesInput>
  }

  export type UsersUpdateWithoutOrganizedMatchesInput = {
    googleId?: NullableStringFieldUpdateOperationsInput | string | null
    facebookId?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    image?: NullableStringFieldUpdateOperationsInput | string | null
    password?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    roles?: RolesUpdateOneRequiredWithoutUsersNestedInput
    Futsals?: FutsalsUpdateOneWithoutUsersNestedInput
    Bookings?: BookingsUpdateManyWithoutUsersNestedInput
    MatchRequest?: MatchRequestUpdateOneWithoutUsersNestedInput
    opponentMatches?: MatchesUpdateManyWithoutOpponentNestedInput
  }

  export type UsersUncheckedUpdateWithoutOrganizedMatchesInput = {
    id?: IntFieldUpdateOperationsInput | number
    googleId?: NullableStringFieldUpdateOperationsInput | string | null
    facebookId?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    image?: NullableStringFieldUpdateOperationsInput | string | null
    password?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    roleId?: IntFieldUpdateOperationsInput | number
    Futsals?: FutsalsUncheckedUpdateOneWithoutUsersNestedInput
    Bookings?: BookingsUncheckedUpdateManyWithoutUsersNestedInput
    MatchRequest?: MatchRequestUncheckedUpdateOneWithoutUsersNestedInput
    opponentMatches?: MatchesUncheckedUpdateManyWithoutOpponentNestedInput
  }

  export type UsersUpsertWithoutOpponentMatchesInput = {
    update: XOR<UsersUpdateWithoutOpponentMatchesInput, UsersUncheckedUpdateWithoutOpponentMatchesInput>
    create: XOR<UsersCreateWithoutOpponentMatchesInput, UsersUncheckedCreateWithoutOpponentMatchesInput>
    where?: UsersWhereInput
  }

  export type UsersUpdateToOneWithWhereWithoutOpponentMatchesInput = {
    where?: UsersWhereInput
    data: XOR<UsersUpdateWithoutOpponentMatchesInput, UsersUncheckedUpdateWithoutOpponentMatchesInput>
  }

  export type UsersUpdateWithoutOpponentMatchesInput = {
    googleId?: NullableStringFieldUpdateOperationsInput | string | null
    facebookId?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    image?: NullableStringFieldUpdateOperationsInput | string | null
    password?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    roles?: RolesUpdateOneRequiredWithoutUsersNestedInput
    Futsals?: FutsalsUpdateOneWithoutUsersNestedInput
    Bookings?: BookingsUpdateManyWithoutUsersNestedInput
    MatchRequest?: MatchRequestUpdateOneWithoutUsersNestedInput
    organizedMatches?: MatchesUpdateManyWithoutOrganizerNestedInput
  }

  export type UsersUncheckedUpdateWithoutOpponentMatchesInput = {
    id?: IntFieldUpdateOperationsInput | number
    googleId?: NullableStringFieldUpdateOperationsInput | string | null
    facebookId?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    image?: NullableStringFieldUpdateOperationsInput | string | null
    password?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    roleId?: IntFieldUpdateOperationsInput | number
    Futsals?: FutsalsUncheckedUpdateOneWithoutUsersNestedInput
    Bookings?: BookingsUncheckedUpdateManyWithoutUsersNestedInput
    MatchRequest?: MatchRequestUncheckedUpdateOneWithoutUsersNestedInput
    organizedMatches?: MatchesUncheckedUpdateManyWithoutOrganizerNestedInput
  }

  export type UsersCreateManyRolesInput = {
    id?: number
    googleId?: string | null
    facebookId?: string | null
    name: string
    email: string
    phone: string
    image?: string | null
    password: string
    address: string
  }

  export type UsersUpdateWithoutRolesInput = {
    googleId?: NullableStringFieldUpdateOperationsInput | string | null
    facebookId?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    image?: NullableStringFieldUpdateOperationsInput | string | null
    password?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    Futsals?: FutsalsUpdateOneWithoutUsersNestedInput
    Bookings?: BookingsUpdateManyWithoutUsersNestedInput
    MatchRequest?: MatchRequestUpdateOneWithoutUsersNestedInput
    organizedMatches?: MatchesUpdateManyWithoutOrganizerNestedInput
    opponentMatches?: MatchesUpdateManyWithoutOpponentNestedInput
  }

  export type UsersUncheckedUpdateWithoutRolesInput = {
    id?: IntFieldUpdateOperationsInput | number
    googleId?: NullableStringFieldUpdateOperationsInput | string | null
    facebookId?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    image?: NullableStringFieldUpdateOperationsInput | string | null
    password?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    Futsals?: FutsalsUncheckedUpdateOneWithoutUsersNestedInput
    Bookings?: BookingsUncheckedUpdateManyWithoutUsersNestedInput
    MatchRequest?: MatchRequestUncheckedUpdateOneWithoutUsersNestedInput
    organizedMatches?: MatchesUncheckedUpdateManyWithoutOrganizerNestedInput
    opponentMatches?: MatchesUncheckedUpdateManyWithoutOpponentNestedInput
  }

  export type UsersUncheckedUpdateManyWithoutRolesInput = {
    id?: IntFieldUpdateOperationsInput | number
    googleId?: NullableStringFieldUpdateOperationsInput | string | null
    facebookId?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    image?: NullableStringFieldUpdateOperationsInput | string | null
    password?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
  }

  export type BookingsCreateManyUsersInput = {
    id?: number
    futsalId: number
    bookDate: Date | string
    startTime: Date | string
    endTime: Date | string
    type: $Enums.FutsalType
    price: number
    confirmation?: $Enums.BookingStatus
    paymentStatus?: $Enums.Payment
  }

  export type MatchesCreateManyOrganizerInput = {
    id?: number
    futsalName: string
    futsalType: $Enums.FutsalType
    matchType: string
    matchDate: Date | string
    startTime: Date | string
    endTime: Date | string
    status?: $Enums.MatchStatus
    opponentId: number
  }

  export type MatchesCreateManyOpponentInput = {
    id?: number
    futsalName: string
    futsalType: $Enums.FutsalType
    matchType: string
    matchDate: Date | string
    startTime: Date | string
    endTime: Date | string
    status?: $Enums.MatchStatus
    organizerId: number
  }

  export type BookingsUpdateWithoutUsersInput = {
    bookDate?: DateTimeFieldUpdateOperationsInput | Date | string
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: DateTimeFieldUpdateOperationsInput | Date | string
    type?: EnumFutsalTypeFieldUpdateOperationsInput | $Enums.FutsalType
    price?: IntFieldUpdateOperationsInput | number
    confirmation?: EnumBookingStatusFieldUpdateOperationsInput | $Enums.BookingStatus
    paymentStatus?: EnumPaymentFieldUpdateOperationsInput | $Enums.Payment
    futsals?: FutsalsUpdateOneRequiredWithoutBookingsNestedInput
  }

  export type BookingsUncheckedUpdateWithoutUsersInput = {
    id?: IntFieldUpdateOperationsInput | number
    futsalId?: IntFieldUpdateOperationsInput | number
    bookDate?: DateTimeFieldUpdateOperationsInput | Date | string
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: DateTimeFieldUpdateOperationsInput | Date | string
    type?: EnumFutsalTypeFieldUpdateOperationsInput | $Enums.FutsalType
    price?: IntFieldUpdateOperationsInput | number
    confirmation?: EnumBookingStatusFieldUpdateOperationsInput | $Enums.BookingStatus
    paymentStatus?: EnumPaymentFieldUpdateOperationsInput | $Enums.Payment
  }

  export type BookingsUncheckedUpdateManyWithoutUsersInput = {
    id?: IntFieldUpdateOperationsInput | number
    futsalId?: IntFieldUpdateOperationsInput | number
    bookDate?: DateTimeFieldUpdateOperationsInput | Date | string
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: DateTimeFieldUpdateOperationsInput | Date | string
    type?: EnumFutsalTypeFieldUpdateOperationsInput | $Enums.FutsalType
    price?: IntFieldUpdateOperationsInput | number
    confirmation?: EnumBookingStatusFieldUpdateOperationsInput | $Enums.BookingStatus
    paymentStatus?: EnumPaymentFieldUpdateOperationsInput | $Enums.Payment
  }

  export type MatchesUpdateWithoutOrganizerInput = {
    futsalName?: StringFieldUpdateOperationsInput | string
    futsalType?: EnumFutsalTypeFieldUpdateOperationsInput | $Enums.FutsalType
    matchType?: StringFieldUpdateOperationsInput | string
    matchDate?: DateTimeFieldUpdateOperationsInput | Date | string
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumMatchStatusFieldUpdateOperationsInput | $Enums.MatchStatus
    opponent?: UsersUpdateOneRequiredWithoutOpponentMatchesNestedInput
  }

  export type MatchesUncheckedUpdateWithoutOrganizerInput = {
    id?: IntFieldUpdateOperationsInput | number
    futsalName?: StringFieldUpdateOperationsInput | string
    futsalType?: EnumFutsalTypeFieldUpdateOperationsInput | $Enums.FutsalType
    matchType?: StringFieldUpdateOperationsInput | string
    matchDate?: DateTimeFieldUpdateOperationsInput | Date | string
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumMatchStatusFieldUpdateOperationsInput | $Enums.MatchStatus
    opponentId?: IntFieldUpdateOperationsInput | number
  }

  export type MatchesUncheckedUpdateManyWithoutOrganizerInput = {
    id?: IntFieldUpdateOperationsInput | number
    futsalName?: StringFieldUpdateOperationsInput | string
    futsalType?: EnumFutsalTypeFieldUpdateOperationsInput | $Enums.FutsalType
    matchType?: StringFieldUpdateOperationsInput | string
    matchDate?: DateTimeFieldUpdateOperationsInput | Date | string
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumMatchStatusFieldUpdateOperationsInput | $Enums.MatchStatus
    opponentId?: IntFieldUpdateOperationsInput | number
  }

  export type MatchesUpdateWithoutOpponentInput = {
    futsalName?: StringFieldUpdateOperationsInput | string
    futsalType?: EnumFutsalTypeFieldUpdateOperationsInput | $Enums.FutsalType
    matchType?: StringFieldUpdateOperationsInput | string
    matchDate?: DateTimeFieldUpdateOperationsInput | Date | string
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumMatchStatusFieldUpdateOperationsInput | $Enums.MatchStatus
    organizer?: UsersUpdateOneRequiredWithoutOrganizedMatchesNestedInput
  }

  export type MatchesUncheckedUpdateWithoutOpponentInput = {
    id?: IntFieldUpdateOperationsInput | number
    futsalName?: StringFieldUpdateOperationsInput | string
    futsalType?: EnumFutsalTypeFieldUpdateOperationsInput | $Enums.FutsalType
    matchType?: StringFieldUpdateOperationsInput | string
    matchDate?: DateTimeFieldUpdateOperationsInput | Date | string
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumMatchStatusFieldUpdateOperationsInput | $Enums.MatchStatus
    organizerId?: IntFieldUpdateOperationsInput | number
  }

  export type MatchesUncheckedUpdateManyWithoutOpponentInput = {
    id?: IntFieldUpdateOperationsInput | number
    futsalName?: StringFieldUpdateOperationsInput | string
    futsalType?: EnumFutsalTypeFieldUpdateOperationsInput | $Enums.FutsalType
    matchType?: StringFieldUpdateOperationsInput | string
    matchDate?: DateTimeFieldUpdateOperationsInput | Date | string
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumMatchStatusFieldUpdateOperationsInput | $Enums.MatchStatus
    organizerId?: IntFieldUpdateOperationsInput | number
  }

  export type FutsalImageCreateManyFutsalInput = {
    id?: number
    url: string
  }

  export type PriceListsCreateManyFutsalsInput = {
    id?: number
    startTime: Date | string
    endTime: Date | string
    dayOfWeek: string
    price: number
  }

  export type BookingsCreateManyFutsalsInput = {
    id?: number
    userId: number
    bookDate: Date | string
    startTime: Date | string
    endTime: Date | string
    type: $Enums.FutsalType
    price: number
    confirmation?: $Enums.BookingStatus
    paymentStatus?: $Enums.Payment
  }

  export type TimeSlotsCreateManyFutsalsInput = {
    id?: number
    startTime: Date | string
    endTime: Date | string
    date: Date | string
    price: number
    futsalType: $Enums.FutsalType
  }

  export type FutsalImageUpdateWithoutFutsalInput = {
    url?: StringFieldUpdateOperationsInput | string
  }

  export type FutsalImageUncheckedUpdateWithoutFutsalInput = {
    id?: IntFieldUpdateOperationsInput | number
    url?: StringFieldUpdateOperationsInput | string
  }

  export type FutsalImageUncheckedUpdateManyWithoutFutsalInput = {
    id?: IntFieldUpdateOperationsInput | number
    url?: StringFieldUpdateOperationsInput | string
  }

  export type PriceListsUpdateWithoutFutsalsInput = {
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: DateTimeFieldUpdateOperationsInput | Date | string
    dayOfWeek?: StringFieldUpdateOperationsInput | string
    price?: IntFieldUpdateOperationsInput | number
  }

  export type PriceListsUncheckedUpdateWithoutFutsalsInput = {
    id?: IntFieldUpdateOperationsInput | number
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: DateTimeFieldUpdateOperationsInput | Date | string
    dayOfWeek?: StringFieldUpdateOperationsInput | string
    price?: IntFieldUpdateOperationsInput | number
  }

  export type PriceListsUncheckedUpdateManyWithoutFutsalsInput = {
    id?: IntFieldUpdateOperationsInput | number
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: DateTimeFieldUpdateOperationsInput | Date | string
    dayOfWeek?: StringFieldUpdateOperationsInput | string
    price?: IntFieldUpdateOperationsInput | number
  }

  export type BookingsUpdateWithoutFutsalsInput = {
    bookDate?: DateTimeFieldUpdateOperationsInput | Date | string
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: DateTimeFieldUpdateOperationsInput | Date | string
    type?: EnumFutsalTypeFieldUpdateOperationsInput | $Enums.FutsalType
    price?: IntFieldUpdateOperationsInput | number
    confirmation?: EnumBookingStatusFieldUpdateOperationsInput | $Enums.BookingStatus
    paymentStatus?: EnumPaymentFieldUpdateOperationsInput | $Enums.Payment
    users?: UsersUpdateOneRequiredWithoutBookingsNestedInput
  }

  export type BookingsUncheckedUpdateWithoutFutsalsInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    bookDate?: DateTimeFieldUpdateOperationsInput | Date | string
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: DateTimeFieldUpdateOperationsInput | Date | string
    type?: EnumFutsalTypeFieldUpdateOperationsInput | $Enums.FutsalType
    price?: IntFieldUpdateOperationsInput | number
    confirmation?: EnumBookingStatusFieldUpdateOperationsInput | $Enums.BookingStatus
    paymentStatus?: EnumPaymentFieldUpdateOperationsInput | $Enums.Payment
  }

  export type BookingsUncheckedUpdateManyWithoutFutsalsInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    bookDate?: DateTimeFieldUpdateOperationsInput | Date | string
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: DateTimeFieldUpdateOperationsInput | Date | string
    type?: EnumFutsalTypeFieldUpdateOperationsInput | $Enums.FutsalType
    price?: IntFieldUpdateOperationsInput | number
    confirmation?: EnumBookingStatusFieldUpdateOperationsInput | $Enums.BookingStatus
    paymentStatus?: EnumPaymentFieldUpdateOperationsInput | $Enums.Payment
  }

  export type TimeSlotsUpdateWithoutFutsalsInput = {
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: DateTimeFieldUpdateOperationsInput | Date | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    price?: IntFieldUpdateOperationsInput | number
    futsalType?: EnumFutsalTypeFieldUpdateOperationsInput | $Enums.FutsalType
  }

  export type TimeSlotsUncheckedUpdateWithoutFutsalsInput = {
    id?: IntFieldUpdateOperationsInput | number
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: DateTimeFieldUpdateOperationsInput | Date | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    price?: IntFieldUpdateOperationsInput | number
    futsalType?: EnumFutsalTypeFieldUpdateOperationsInput | $Enums.FutsalType
  }

  export type TimeSlotsUncheckedUpdateManyWithoutFutsalsInput = {
    id?: IntFieldUpdateOperationsInput | number
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: DateTimeFieldUpdateOperationsInput | Date | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    price?: IntFieldUpdateOperationsInput | number
    futsalType?: EnumFutsalTypeFieldUpdateOperationsInput | $Enums.FutsalType
  }



  /**
   * Aliases for legacy arg types
   */
    /**
     * @deprecated Use RolesCountOutputTypeDefaultArgs instead
     */
    export type RolesCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = RolesCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use UsersCountOutputTypeDefaultArgs instead
     */
    export type UsersCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = UsersCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use FutsalsCountOutputTypeDefaultArgs instead
     */
    export type FutsalsCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = FutsalsCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use RolesDefaultArgs instead
     */
    export type RolesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = RolesDefaultArgs<ExtArgs>
    /**
     * @deprecated Use UsersDefaultArgs instead
     */
    export type UsersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = UsersDefaultArgs<ExtArgs>
    /**
     * @deprecated Use FutsalsDefaultArgs instead
     */
    export type FutsalsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = FutsalsDefaultArgs<ExtArgs>
    /**
     * @deprecated Use FutsalImageDefaultArgs instead
     */
    export type FutsalImageArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = FutsalImageDefaultArgs<ExtArgs>
    /**
     * @deprecated Use PriceListsDefaultArgs instead
     */
    export type PriceListsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = PriceListsDefaultArgs<ExtArgs>
    /**
     * @deprecated Use BookingsDefaultArgs instead
     */
    export type BookingsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = BookingsDefaultArgs<ExtArgs>
    /**
     * @deprecated Use TimeSlotsDefaultArgs instead
     */
    export type TimeSlotsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = TimeSlotsDefaultArgs<ExtArgs>
    /**
     * @deprecated Use MatchRequestDefaultArgs instead
     */
    export type MatchRequestArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = MatchRequestDefaultArgs<ExtArgs>
    /**
     * @deprecated Use MatchesDefaultArgs instead
     */
    export type MatchesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = MatchesDefaultArgs<ExtArgs>

  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}